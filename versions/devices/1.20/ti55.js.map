{"version":3,"file":"ti55.js","lineCount":97,"mappings":"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","sources":["versions/devices/1.20/ti55-uncompiled.js"," [synthetic:util/objectcreate] "," [synthetic:es6/util/setprototypeof] "," [synthetic:es6/util/inherits] "," [synthetic:util/defineproperty] "," [synthetic:util/global] "," [synthetic:es6/symbol] "," [synthetic:es6/util/makeiterator] "," [synthetic:es6/util/arrayfromiterator] "," [synthetic:util/polyfill] "," [synthetic:es6/number/parseint] "," [synthetic:es6/math/trunc] "," [synthetic:es6/array/fill] "," [synthetic:es6/math/log2] "," [synthetic:es6/util/arrayfromiterable] "],"names":["$jscomp.objectCreate","$jscomp.setPrototypeOf","$jscomp.defineProperty","$jscomp.global","$jscomp.initSymbol","$jscomp.Symbol","$jscomp.SYMBOL_PREFIX","$jscomp.arrayIterator","$jscomp.initSymbolIterator","$jscomp.iteratorPrototype","$jscomp.polyfill","MACHINE","constructor","Device","idMachine","idDevice","version","config","bindings","Device.Machines","addDevice","push","checkVersion","checkOverrides","addBindings","sCommandPrev","addBinding","binding","element","device","Device.BINDING.CLEAR","onclick","element.onclick","findBinding","value","Device.BINDING.PRINT","addEventListener","onKeyPress","event","window","keyCode","which","sText","setSelectionRange","length","stopPropagation","preventDefault","blur","focus","doCommand","fDirectBindings","Array","isArray","id","document","getElementById","parms","Device.URLParms","sParms","location","search","substr","match","pl","exec","decodeURIComponent","s","replace","trim","prop","indexOf","Number","parseInt","println","sVersion","machine","findDevice","sprintf","sError","class","type","Device.Alerts.Version","Device.Alerts.list.indexOf","alert","Device.Alerts.list.push","afnHandlers","findHandlers","sCommand","slice","lastIndexOf","i","aTokens","split","c","setCategory","sResult","Device.COMMANDS.forEach","forEach","cmd","unshift","name","undefined","devices","findDeviceByClass","idClass","sType","Device.HANDLER.COMMAND","Device.Handlers","getBindingID","ROM.BINDING.ARRAY","getBindingText","ROM.BINDING.CELLDESC","textContent","getBounded","n","min","max","getDefault","idConfig","defaultValue","getResource","sURL","done","nErrorCode","sResource","xmlHTTP","XMLHttpRequest","ActiveXObject","onreadystatechange","xmlHTTP.onreadystatechange","readyState","responseText","status","protocol","open","send","hasLocalStorage","Device.LocalStorage.Available","f","localStorage","setItem","Device.LocalStorage.Test","getItem","removeItem","err","message","isUserAgent","userAgent","navigator","print","Device.Category","Device.Category.indexOf","Device.CATEGORY.BUFFER","Device.PrintBuffer","scrollTop","scrollHeight","console","log","printf","format","args","$jscomp.arrayFromIterator","$jscomp.makeIterator","setBindingText","text","category","cPrev","fFlush","sBuffer","buffer","aParts","iArg","iPart","arg","flags","minimum","precision","conversion","ach","Math","trunc","abs","round","pow","String","fromCharCode","Device.HexUpperCase","Device.HexLowerCase","CLEAR","PRINT","BUFFER","Device.COMMANDS","COMMAND","list","Version","Available","Test","Input","Input.VERSION","time","Machine.CLASS.TIME","onHover","onReset","onPower","onInput","fDrag","getDefaultBoolean","fScroll","fTouch","Input.BINDING.SURFACE","xInput","yInput","cxInput","cyInput","hGap","vGap","cxSurface","naturalWidth","cySurface","naturalHeight","xPower","yPower","cxPower","cyPower","map","nRows","nCols","fHexagonal","buttonDelay","getDefaultNumber","cxButton","cyButton","cxGap","cyGap","xStart","yStart","captureMouse","captureTouch","input","timerInputRelease","addTimer","onInputRelease","setPosition","timerKeyRelease","onKeyRelease","onKeyTimer","keyState","keysPressed","captureKeys","col","row","$jscomp.inherits","Input.BINDING.POWER","Input.BINDING.RESET","addHover","advanceKeyState","setTimer","onKeyDown","activeElement","ch","Input.KEYCODE","charCode","onMouseDown","button","x","scrollX","y","scrollY","scrollTo","processEvent","Input.ACTION.PRESS","onMouseMove","Input.ACTION.MOVE","onMouseUp","Input.ACTION.RELEASE","onMouseOut","onTouchStart","onTouchMove","onTouchEnd","rowMap","charCodeAt","shift","action","fMultiTouch","fButton","targetTouches","pageX","pageY","yOffset","xOffset","elementNext","isNaN","offsetLeft","offsetTop","offsetParent","offsetWidth","offsetHeight","fInput","fPower","cxCol","cyCol","colInput","rowInput","yCol","fRunning","iTimer","aTimers","timer","nCyclesLeft","PRESS","MOVE","RELEASE","POWER","RESET","SURFACE","VERSION","LED","LED.VERSION","container","LED.BINDING.CONTAINER","Error","canvasView","createElement","getContext","innerHTML","LED.TYPE.ROUND","LED.TYPE.SMALL","LED.TYPE.DIGIT","widthCell","LED.SIZES","heightCell","width","height","colsView","cols","rowsView","rows","widthView","heightView","colorTransparent","getRGBAColor","colorOn","getRGBColor","colorOff","colorHighlight","colorBackground","fFixed","style","fHighlight","fPersistent","setAttribute","toString","backgroundColor","appendChild","contextView","canvasGrid","widthGrid","heightGrid","contextGrid","nBufferCells","nBufferInc","nBufferIncExtra","fBufferModified","fBufferTickled","nShiftedLeft","msLastDraw","iBufferRecent","led","addAnimator","ledAnimate","t","drawBuffer","clearBuffer","initBuffer","iCell","LED.STATE.OFF","LED.FLAGS.MODIFIED","clearGrid","fillStyle","fillRect","clearRect","fForced","colRedraw","drawGrid","cxVisible","drawImage","state","color","fTransparent","colorCell","xDst","yDst","clearGridCell","coords","LED.SHAPES","beginPath","arc","PI","globalCompositeOperation","fill","LED.FLAGS.PERIOD","drawString","segments","LED.SYMBOL_SEGMENTS","drawGridSegment","LED.SEGMENTS","seg","lineTo","moveTo","closePath","colorDefault","LED.COLORS","alpha","brightness","rgb","base","setLEDState","fModified","flagsSet","LED.FLAGS.SET","SMALL","ROUND","DIGIT","CONTAINER","OFF","SET","PERIOD","MODIFIED","SQUARE","ROM","ROM.VERSION","data","addrMask","rom","addrLines","log2","ceil","floor","ledArray","configLEDs","getDefaultString","clearArray","ledInput","configInput","sCellDesc","onROMHover","chip","sDesc","addr","disassemble","opCode","getData","fInternal","ON","loadState","saveState","ARRAY","CELLDESC","Time","Time.VERSION","nCyclesMinimum","nCyclesMaximum","nCyclesPerSecond","nYieldsPerSecond","Time.YIELDS_PER_SECOND","nYieldsPerUpdate","Time.YIELDS_PER_UPDATE","fRequestAnimationFrame","fClockByFrame","nBaseMultiplier","nCurrentMultiplier","nTargetMultiplier","mhzBase","mhzCurrent","mhzTarget","nYields","msYield","aAnimators","aClockers","aUpdaters","fYield","fThrottling","idRunTimeout","nStepping","onRunTimeout","run","bind","onAnimationFrame","animate","requestAnimationFrame","webkitRequestAnimationFrame","setTimeout","nCyclesDeposited","nCyclesDepositPerFrame","onYield","getCycles","updateStatus","resetSpeed","nCyclesRun","nCyclesBurst","nCyclesRemain","setSpeedThrottle","setSpeed","callBack","Time.BINDING.RUN","stop","start","Time.BINDING.STEP","onStep","Time.BINDING.THROTTLE","onThrottleStart","onThrottleStop","onThrottleChange","msAuto","snapStart","updateTimers","endBurst","doBurst","getCyclesPerFrame","snapStop","calcCycles","nMultiplier","nCyclesPerYield","nCycles","iClocker","doOutside","fn","msStart","Date","now","msOutsideThisRun","msStop","nCyclesThisRun","ms","getSpeed","mhz","toFixed","hz","nRepeat","step","getCyclesPerBurst","elementInput","Time.BINDING.SPEED","getSpeedTarget","msStartRun","msEndRun","resetTimers","fReset","msStartThisRun","msDelta","msRemainsThisRun","msElapsed","calcSpeed","TIME","clearTimeout","onStepTimeout","fTransition","getSpeedCurrent","RUN","SPEED","STEP","THROTTLE","Reg64","digits","regMap","d","Reg64.prototype","?.prototype","add","reg","regSrc","range","carry","j","fCOND","updateR5","get","init","move","set","store","sub","fSpaces","regR5","Chip","Chip.VERSION","regsO","regA","regB","regC","regD","regsX","regsY","regSupp","regTemp","regKey","regPC","regRAB","stack","nCyclesClocked","Machine.CLASS.ROM","clocker","f2nd","fINV","angleMode","addrStop","addrPrev","breakConditions","nStringFormat","Chip.SFORMAT.DEFAULT","onCommand","addHandler","checkBreakCondition","Chip.BREAK","clearDisplays","updateIndicators","Chip.prototype","nCyclesTarget","decode","Chip.OP_CYCLES","clockerOutside","mask","Chip.IW_MF.MASK","Chip.IW_MF.MMSD","Chip.IW_MF.ALL","Chip.IW_MF.MANT","Chip.IW_MF.MAEX","Chip.IW_MF.LLSD","Chip.IW_MF.EXP","Chip.IW_MF.FMAEX","Chip.IW_MF.D14","Chip.IW_MF.FLAG","Chip.IW_MF.DIGIT","Chip.IW_MF.D13","Chip.IW_MF.D15","Chip.RANGE","Chip.IW_MF.J_MASK","Chip.IW_MF.J_SHIFT","k","Chip.IW_MF.K_MASK","Chip.IW_MF.K_SHIFT","l","Chip.IW_MF.L_MASK","Chip.IW_MF.L_SHIFT","iOp","Chip.IW_MF.N_MASK","Chip.OP.SUB","Chip.OP.ADD","Chip.OP.SHR","Chip.OP.SHL","regResult","Chip.IW_MF.FF","Chip.IW_FF.J_MASK","Chip.IW_FF.J_SHIFT","Chip.IW_FF.D_MASK","Chip.IW_FF.D_SHIFT","b","Chip.IW_FF.B_MASK","Chip.IW_FF.B_SHIFT","Chip.IW_FF.MASK","Chip.IW_FF.SET","Chip.IW_FF.RESET","Chip.IW_FF.TEST","Chip.IW_FF.TOGGLE","Chip.IW_MF.PF","Chip.IW_PF.MASK","Chip.IW_PF.STYA","Chip.IW_PF.RABI","Chip.IW_PF.BRR5","Chip.IW_PF.RET","pop","Chip.IW_PF.STAX","Chip.IW_PF.STXA","Chip.IW_PF.STAY","Chip.IW_PF.DISP","opDISP","iDigit","Chip.IW_PF.BCDS","Chip.IW_PF.BCDR","Chip.IW_PF.RABR5","fCompact","sOp","sOperands","v","sDst","sSrc","sOperator","Chip.OP_INPUTS","sStore","stateChip","stateROM","nWords","condition","Chip.SFORMAT.COMPACT","setRegister","Chip.COMMANDS.forEach","Chip_prototype$onInput","onLoad","loadLocalStorage","sValue","JSON","parse","Chip_prototype$onPower","fOn","Chip_prototype$onReset","onSave","saveLocalStorage","stringify","options","regs","on","Chip.TYPE.TMS1501","opacity","angleBits","Chip.ANGLEMODE.RADIANS","Chip.ANGLEMODE.GRADIENTS","Chip.ANGLEMODE.DEGREES","Chip.ANGLEMODE.OFF","Chip_prototype$updateStatus","digit","MASK","MMSD","ALL","MANT","MAEX","LLSD","EXP","FMAEX","D14","FLAG","FF","D13","PF","D15","J_MASK","J_SHIFT","K_MASK","K_SHIFT","L_MASK","L_SHIFT","N_MASK","TEST","TOGGLE","D_MASK","D_SHIFT","B_MASK","B_SHIFT","STYA","RABI","BRR5","RET","STAX","STXA","STAY","DISP","BCDS","BCDR","RABR5","ADD","SUB","SHL","SHR","TMS1501","DEGREES","RADIANS","GRADIENTS","DEFAULT","COMPACT","Chip.COMMANDS","Machine","sConfig","Machine.VERSION","sConfigFile","fConfigLoaded","fPageLoaded","loadConfig","onLoadConfig","initDevices","onLoadPage","sEvent","onUnloadPage","iClass","Machine.CLASSORDER.length","sStatus","sClass","Machine.CLASSORDER","Machine.CLASS.CHIP","Machine.CLASS.INPUT","Machine.CLASS.LED","Machine.CLASS.MACHINE","Machine.COPYRIGHT","Machine.LICENSE","removeDevice","splice","fAutoRestore","fAutoStart","CHIP","INPUT"],"sourcesContent":["\"use strict\";\n\n/**\n * @copyright https://www.pcjs.org/modules/devices/device.js (C) Jeff Parsons 2012-2018\n */\n\n/**\n * @define {boolean}\n */\nvar COMPILED = false;\n\n/**\n * @define {boolean}\n */\nvar DEBUG = true; // (window.location.hostname == \"pcjs\" || window.location.hostname == \"jeffpar.local\");\n\n/**\n * @type {string}\n */\nvar MACHINE = \"Machine\";\n\n/**\n * @define {string}\n */\nvar VERSION = \"\";\n\n/** @typedef {{ class: (string|undefined), bindings: (Object|undefined), version: (number|undefined), overrides: (Array.<string>|undefined) }} */\nvar Config;\n\n/**\n * @class {Device}\n * @unrestricted\n * @property {string} idMachine\n * @property {string} idDevice\n * @property {Config} config\n * @property {Object} bindings [added by addBindings()]\n * @property {string} sCommandPrev\n */\nclass Device {\n    /**\n     * Device()\n     *\n     * Supported config properties:\n     *\n     *      \"bindings\": object containing name/value pairs, where name is the generic name\n     *      of a element, and value is the ID of the DOM element that should be mapped to it\n     *\n     * The properties in the \"bindings\" object are copied to our own bindings object in addBindings(),\n     * but only for DOM elements that actually exist, and it is the elements themselves (rather than\n     * their IDs) that we store.\n     *\n     * Also, URL parameters can be used to override config properties.  For example, the URL:\n     *\n     *      http://pcjs:8088/devices/ti57/machine/?cyclesPerSecond=100000\n     *\n     * will set the Time device's cyclesPerSecond config property to 100000.  In general, the values\n     * will be treated as strings, unless they contain all digits (number), or equal \"true\" or \"false\"\n     * (boolean).\n     *\n     * @this {Device}\n     * @param {string} idMachine\n     * @param {string} idDevice\n     * @param {number} [version]\n     * @param {Config} [config]\n     */\n    constructor(idMachine, idDevice, version, config)\n    {\n        this.config = config || {};\n        this.idMachine = idMachine;\n        this.idDevice = idDevice;\n        this.version = version || 0;\n        this.bindings = {};\n        this.addDevice();\n        this.checkVersion(this.config);\n        this.checkOverrides(this.config);\n        this.addBindings(this.config['bindings']);\n        this.sCommandPrev = \"\";\n    }\n\n    /**\n     * addBinding(binding, element)\n     *\n     * @this {Device}\n     * @param {string} binding\n     * @param {Element} element\n     */\n    addBinding(binding, element)\n    {\n        let device = this;\n\n        switch (binding) {\n\n        case Device.BINDING.CLEAR:\n            element.onclick = function onClickClear() {\n                device.clear();\n            };\n            break;\n\n        case Device.BINDING.PRINT:\n            let elementTextArea = /** @type {HTMLTextAreaElement} */ (element);\n            /*\n             * This was added for Firefox (Safari will clear the <textarea> on a page reload, but Firefox does not).\n             */\n            elementTextArea.value = \"\";\n            /*\n             * An onKeyPress handler has been added to this element simply to stop event propagation, so that if the\n             * element has been explicitly given focus, any key presses won't be picked up by the Input device (which,\n             * as that device's constructor explains, is monitoring key presses for the entire document).\n             */\n            elementTextArea.addEventListener(\n                'keypress',\n                function onKeyPress(event) {\n                    event = event || window.event;\n                    let keyCode = event.which || event.keyCode;\n                    if (keyCode) {\n                        /*\n                         * Move the caret to the end of any text in the textarea.\n                         */\n                        let sText = elementTextArea.value;\n                        elementTextArea.setSelectionRange(sText.length, sText.length);\n\n                        /*\n                         * Don't let the Input device's document-based keypress handler see any key presses\n                         * that came to this element first.\n                         */\n                        event.stopPropagation();\n\n                        /*\n                         * On the ENTER key, look for any COMMAND handlers and invoke them until one of them\n                         * returns true.\n                         */\n                        if (keyCode == 13) {\n                            /*\n                             * At the time we call any command handlers, a linefeed will not yet have been\n                             * appended to the text, so for consistency, we prevent the default behavior and\n                             * add the linefeed ourselves.  Unfortunately, one side-effect is that we must\n                             * go to some extra effort to ensure the cursor remains in view; hence the stupid\n                             * blur() and focus() calls.\n                             */\n                            event.preventDefault();\n                            sText = (elementTextArea.value += '\\n');\n                            elementTextArea.blur();\n                            elementTextArea.focus();\n                            device.doCommand(sText);\n                        }\n                    }\n                }\n            );\n            break;\n        }\n    }\n\n    /**\n     * addBindings(bindings)\n     *\n     * Builds the set of ACTUAL bindings (this.bindings) from the set of DESIRED bindings (this.config['bindings']),\n     * using either a \"bindings\" object map OR an array of \"direct bindings\".\n     *\n     * @this {Device}\n     * @param {Object} bindings\n     */\n    addBindings(bindings)\n    {\n        let fDirectBindings = Array.isArray(bindings);\n        for (let binding in bindings) {\n            let id = bindings[binding];\n            if (fDirectBindings) binding = id;\n            let element = document.getElementById(id);\n            if (element) {\n                this.bindings[binding] = element;\n                this.addBinding(binding, element);\n                continue;\n            }\n            if (DEBUG && !fDirectBindings) this.println(\"unable to find device ID: \" + id);\n        }\n    }\n\n    /**\n     * addBindingOptions(element, options, fReset, sDefault)\n     *\n     * @this {Device}\n     * @param {Element|HTMLSelectElement} element\n     * @param {Object} options (eg, key/value pairs for a series of \"option\" elements)\n     * @param {boolean} [fReset]\n     * @param {string} [sDefault]\n     */\n    addBindingOptions(element, options, fReset, sDefault)\n    {\n        if (fReset) {\n            element.options.length = 0;\n        }\n        if (options) {\n            for (let prop in options) {\n                let option = document.createElement(\"option\");\n                option.text = prop;\n                option.value = (typeof options[prop] == \"string\"? options[prop] : prop);\n                element.appendChild(option);\n                if (option.value == sDefault) element.selectedIndex = element.options.length - 1;\n            }\n        }\n    }\n\n    /**\n     * addDevice()\n     *\n     * Adds this Device to the global set of Devices, so that findDevice(), findBinding(), etc, will work.\n     *\n     * @this {Device}\n     */\n    addDevice()\n    {\n        if (!Device.Machines[this.idMachine]) Device.Machines[this.idMachine] = [];\n        Device.Machines[this.idMachine].push(this);\n    }\n\n    /**\n     * addHandler(sType, fn)\n     *\n     * @this {Device}\n     * @param {string} sType\n     * @param {function(Array.<string>,Device)} fn\n     */\n    addHandler(sType, fn)\n    {\n        if (!Device.Handlers[this.idMachine]) Device.Handlers[this.idMachine] = {};\n        if (!Device.Handlers[this.idMachine][sType]) Device.Handlers[this.idMachine][sType] = [];\n        Device.Handlers[this.idMachine][sType].push(fn);\n    }\n\n    /**\n     * alert(s, type)\n     *\n     * @this {Device}\n     * @param {string} s\n     * @param {string} [type]\n     */\n    alert(s, type)\n    {\n        if (type && Device.Alerts.list.indexOf(type) < 0) {\n            alert(s);\n            Device.Alerts.list.push(type);\n        }\n        this.println(s);\n    }\n\n    /**\n     * assert(f, s)\n     *\n     * Verifies conditions that must be true (for DEBUG builds only).\n     *\n     * The Closure Compiler should automatically remove all references to assert() in non-DEBUG builds.\n     * TODO: Add a task to the build process that \"asserts\" there are no instances of \"assertion failure\" in RELEASE builds.\n     *\n     * @this {Device}\n     * @param {*} f is the expression asserted to be true\n     * @param {string} [s] is description of the assertion on failure\n     */\n    assert(f, s)\n    {\n        if (DEBUG) {\n            if (!f) {\n                throw new Error(s || \"assertion failure\");\n            }\n        }\n    }\n\n    /**\n     * checkOverrides(config)\n     *\n     * @this {Device}\n     * @param {Config} config\n     */\n    checkOverrides(config)\n    {\n        /*\n         * If this device's config contains an \"overrides\" array, then any of the properties listed in\n         * that array may be overridden with a URL parameter.  We don't impose any checks on the overriding\n         * value, so it is the responsibility of the component with overridable properties to validate them.\n         */\n        if (config['overrides']) {\n            let parms = this.getURLParms();\n            for (let prop in parms) {\n                if (config['overrides'].indexOf(prop) >= 0) {\n                    let value;\n                    let s = parms[prop];\n                    /*\n                     * You might think we could simply call parseInt() and check isNaN(), but parseInt() has\n                     * some annoying quirks, like stopping at the first non-numeric character.  If the ENTIRE\n                     * string isn't a number, then we don't want to treat ANY part of it as a number.\n                     */\n                    if (s.match(/^[+-]?[0-9.]+$/)) {\n                        value = Number.parseInt(s, 10);\n                    } else if (s == \"true\") {\n                        value = true;\n                    } else if (s == \"false\") {\n                        value = false;\n                    } else {\n                        value = s;\n                        s = '\"' + s + '\"';\n                    }\n                    config[prop] = value;\n                    this.println(\"overriding \" + this.idDevice + \" property '\" + prop + \"' with \" + s);\n                }\n            }\n        }\n    }\n\n    /**\n     * checkVersion(config)\n     *\n     * Verify that device's version matches the machine's version, and also that the config version stored in\n     * the JSON (if any) matches the device's version.\n     *\n     * This is normally performed by the constructor, but the Machine device cannot be fully initialized in the\n     * constructor, so it calls this separately.\n     *\n     * @this {Device}\n     * @param {Config} config\n     */\n    checkVersion(config)\n    {\n        if (this.version) {\n            let sVersion = \"\", version;\n            let machine = this.findDevice(this.idMachine);\n            if (machine.version != this.version) {\n                sVersion = \"Machine\";\n                version = machine.version;\n            }\n            else if (config.version && config.version > this.version) {\n                sVersion = \"Config\";\n                version = config.version;\n            }\n            if (sVersion) {\n                let sError = this.sprintf(\"%s Device version (%3.2f) incompatible with %s version (%3.2f)\", config.class, this.version, sVersion, version);\n                this.alert(\"Error: \" + sError + '\\n\\n' + \"Clearing your browser's cache may resolve the issue.\", Device.Alerts.Version);\n            }\n        }\n    }\n\n    /**\n     * clear()\n     *\n     * @this {Device}\n     */\n    clear()\n    {\n        let element = this.findBinding(Device.BINDING.PRINT, true);\n        if (element) element.value = \"\";\n    }\n\n    /**\n     * doCommand(sText)\n     * \n     * @this {Device}\n     * @param {string} sText\n     */\n    doCommand(sText)\n    {\n        let afnHandlers = this.findHandlers(Device.HANDLER.COMMAND);\n        if (afnHandlers) {\n\n            let i = sText.lastIndexOf('\\n', sText.length - 2);\n            let sCommand = sText.slice(i + 1, -1) || this.sCommandPrev;\n            this.sCommandPrev = \"\";\n            sCommand = sCommand.trim();\n            let aTokens = sCommand.split(' ');\n    \n            switch(aTokens[0]) {\n            case 'c':\n                let c = aTokens[1];\n                if (c) {\n                    this.println(\"set category '\" + c + \"'\");\n                    this.setCategory(c);\n                } else {\n                    c = this.setCategory();\n                    if (c) {\n                        this.println(\"cleared category '\" + c + \"'\");\n                    } else {\n                        this.println(\"no category set\");\n                    }\n                }\n                break;\n            case '?':\n                let sResult = \"\";\n                Device.COMMANDS.forEach(cmd => {sResult += '\\n' + cmd;});\n                if (sResult) this.println(\"default commands:\" + sResult);\n                /* falls through */\n            default:\n                aTokens.unshift(sCommand);\n                for (let i = 0; i < afnHandlers.length; i++) {\n                    if (afnHandlers[i](aTokens, this)) break;\n                }\n                break;\n            }\n        }\n    }\n    \n    /**\n     * findBinding(name, fAll)\n     *\n     * This will search the current device's bindings, and optionally all the device bindings within the\n     * machine.  If the binding is found in another device, that binding is recorded in this device as well.\n     *\n     * @this {Device}\n     * @param {string} name\n     * @param {boolean} [fAll]\n     * @returns {Element|null|undefined}\n     */\n    findBinding(name, fAll = false)\n    {\n        let element = this.bindings[name];\n        if (element === undefined && fAll) {\n            let devices = Device.Machines[this.idMachine];\n            for (let i in devices) {\n                element = devices[i].bindings[name];\n                if (element) break;\n            }\n            if (!element) element = null;\n            this.bindings[name] = element;\n        }\n        return element;\n    }\n\n    /**\n     * findDevice(idDevice)\n     *\n     * @this {Device}\n     * @param {string} idDevice\n     * @returns {Device|undefined}\n     */\n    findDevice(idDevice)\n    {\n        let device;\n        let devices = Device.Machines[this.idMachine];\n        if (devices) {\n            for (let i in devices) {\n                if (devices[i].idDevice == idDevice) {\n                    device = devices[i];\n                    break;\n                }\n            }\n        }\n        return device;\n    }\n\n    /**\n     * findDeviceByClass(idClass)\n     *\n     * @this {Device}\n     * @param {string} idClass\n     * @returns {Device|undefined}\n     */\n    findDeviceByClass(idClass)\n    {\n        let device;\n        let devices = Device.Machines[this.idMachine];\n        if (devices) {\n            for (let i in devices) {\n                if (devices[i].config['class'] == idClass) {\n                    device = devices[i];\n                    break;\n                }\n            }\n        }\n        return device;\n    }\n\n    /**\n     * findHandlers(sType)\n     *\n     * @this {Device}\n     * @param {string} sType\n     * @returns {Array.<function(Array.<string>,Device)>|undefined}\n     */\n    findHandlers(sType)\n    {\n        return Device.Handlers[this.idMachine] && Device.Handlers[this.idMachine][sType];\n    }\n\n    /**\n     * getBindingID(name)\n     * \n     * Since this.bindings contains the actual elements, not their original IDs, we must delve back into\n     * the original this.config['bindings'] to determine the original ID.\n     * \n     * @this {Device}\n     * @param {string} name \n     * @returns {string|undefined}\n     */\n    getBindingID(name)\n    {\n        return this.config['bindings'] && this.config['bindings'][name];\n    }\n    \n    /**\n     * getBindingText(name)\n     *\n     * @this {Device}\n     * @param {string} name\n     * @return {string|undefined}\n     */\n    getBindingText(name)\n    {\n        let sText;\n        let element = this.bindings[name];\n        if (element) sText = element.textContent;\n        return sText;\n    }\n\n    /**\n     * getBounded(n, min, max)\n     *\n     * Restricts n to the bounds defined by min and max.  A side-effect is ensuring that the return\n     * value is ALWAYS a number, even n is not.\n     *\n     * @this {Device}\n     * @param {number} n\n     * @param {number} min\n     * @param {number} max\n     * @returns {number} (updated n)\n     */\n    getBounded(n, min, max)\n    {\n\n        n = +n || 0;\n        if (n < min) n = min;\n        if (n > max) n = max;\n        return n;\n    }\n\n    /**\n     * getDefault(idConfig, defaultValue)\n     *\n     * @this {Device}\n     * @param {string} idConfig\n     * @param {*} defaultValue\n     * @returns {*}\n     */\n    getDefault(idConfig, defaultValue)\n    {\n        let value = this.config[idConfig];\n        if (value === undefined) {\n            value = defaultValue;\n        } else {\n            let type = typeof defaultValue;\n            if (typeof value != type) {\n\n                if (type == \"boolean\") {\n                    value = !!value;\n                } else if (typeof defaultValue == \"number\") {\n                    value = +value;\n                }\n            }\n        }\n        return value;\n    }\n\n    /**\n     * getDefaultBoolean(idConfig, defaultValue)\n     *\n     * @this {Device}\n     * @param {string} idConfig\n     * @param {boolean} defaultValue\n     * @returns {boolean}\n     */\n    getDefaultBoolean(idConfig, defaultValue)\n    {\n        return /** @type {boolean} */ (this.getDefault(idConfig, defaultValue));\n    }\n\n    /**\n     * getDefaultNumber(idConfig, defaultValue)\n     *\n     * @this {Device}\n     * @param {string} idConfig\n     * @param {number} defaultValue\n     * @returns {number}\n     */\n    getDefaultNumber(idConfig, defaultValue)\n    {\n        return /** @type {number} */ (this.getDefault(idConfig, defaultValue));\n    }\n\n    /**\n     * getDefaultString(idConfig, defaultValue)\n     *\n     * @this {Device}\n     * @param {string} idConfig\n     * @param {string} defaultValue\n     * @returns {string}\n     */\n    getDefaultString(idConfig, defaultValue)\n    {\n        return /** @type {string} */ (this.getDefault(idConfig, defaultValue));\n    }\n\n    /**\n     * getHost()\n     *\n     * @this {Device}\n     * @return {string}\n     */\n    getHost()\n    {\n        return (\"http://\" + (window? window.location.host : \"localhost\"));\n    }\n\n    /**\n     * getHostURL()\n     *\n     * @this {Device}\n     * @return {string|null}\n     */\n    getHostURL()\n    {\n        return (window? window.location.href : null);\n    }\n\n    /**\n     * getHostProtocol()\n     *\n     * @this {Device}\n     * @return {string}\n     */\n    getHostProtocol()\n    {\n        return (window? window.location.protocol : \"file:\");\n    }\n\n    /**\n     * getResource(sURL, done)\n     *\n     * Request the specified resource, and once the request is complete, notify done().\n     *\n     * done() is passed four parameters:\n     *\n     *      done(sURL, sResource, readyState, nErrorCode)\n     *\n     * readyState comes from the request's 'readyState' property, and the operation should not be considered complete\n     * until readyState is 4.\n     * \n     * If nErrorCode is zero, sResource should contain the requested data; otherwise, an error occurred.\n     *\n     * @param {string} sURL\n     * @param {function(string,string,number,number)} done\n     */\n    getResource(sURL, done)\n    {\n        let nErrorCode = 0, sResource = null;\n\n        if (DEBUG) {\n            /*\n             * The larger resources we put on archive.pcjs.org should also be available locally.\n             *\n             * NOTE: \"http://archive.pcjs.org\" is now \"https://s3-us-west-2.amazonaws.com/archive.pcjs.org\"\n             */\n            sURL = sURL.replace(/^(http:\\/\\/archive\\.pcjs\\.org|https:\\/\\/s3-us-west-2\\.amazonaws\\.com\\/archive\\.pcjs\\.org)(\\/.*)\\/([^\\/]*)$/, \"$2/archive/$3\");\n        }\n\n        let xmlHTTP = (window.XMLHttpRequest? new window.XMLHttpRequest() : new window.ActiveXObject(\"Microsoft.XMLHTTP\"));\n        xmlHTTP.onreadystatechange = function()\n        {\n            if (xmlHTTP.readyState !== 4) {\n                done(sURL, sResource, xmlHTTP.readyState, nErrorCode);\n                return;\n            }\n            \n            /*\n             * The following line was recommended for WebKit, as a work-around to prevent the handler firing multiple\n             * times when debugging.  Unfortunately, that's not the only XMLHttpRequest problem that occurs when\n             * debugging, so I think the WebKit problem is deeper than that.  When we have multiple XMLHttpRequests\n             * pending, any debugging activity means most of them simply get dropped on floor, so what may actually be\n             * happening are mis-notifications rather than redundant notifications.\n             *\n             *      xmlHTTP.onreadystatechange = undefined;\n             */\n            sResource = xmlHTTP.responseText;\n            \n            /*\n             * The normal \"success\" case is an HTTP status code of 200, but when testing with files loaded\n             * from the local file system (ie, when using the \"file:\" protocol), we have to be a bit more \"flexible\".\n             */\n            if (xmlHTTP.status == 200 || !xmlHTTP.status && sResource.length && this.getHostProtocol() == \"file:\") {\n                // if (MAXDEBUG) Web.log(\"xmlHTTP.onreadystatechange(\" + sURL + \"): returned \" + sResource.length + \" bytes\");\n            }\n            else {\n                nErrorCode = xmlHTTP.status || -1;\n            }\n            done(sURL, sResource, xmlHTTP.readyState, nErrorCode);\n        };\n        \n        xmlHTTP.open(\"GET\", sURL, true);\n        xmlHTTP.send();\n    }\n\n    /**\n     * getURLParms(sParms)\n     *\n     * @param {string} [sParms] containing the parameter portion of a URL (ie, after the '?')\n     * @returns {Object} containing properties for each parameter found\n     */\n    getURLParms(sParms)\n    {\n        let parms = Device.URLParms;\n        if (!parms) {\n            parms = {};\n            if (window) {\n                if (!sParms) {\n                    /*\n                     * Note that window.location.href returns the entire URL, whereas window.location.search\n                     * returns only the parameters, if any (starting with the '?', which we skip over with a substr() call).\n                     */\n                    sParms = window.location.search.substr(1);\n                }\n                let match;\n                let pl = /\\+/g; // RegExp for replacing addition symbol with a space\n                let search = /([^&=]+)=?([^&]*)/g;\n                let decode = function decodeParameter(s) {\n                    return decodeURIComponent(s.replace(pl, \" \")).trim();\n                };\n\n                while ((match = search.exec(sParms))) {\n                    parms[decode(match[1])] = decode(match[2]);\n                }\n            }\n            Device.URLParms = parms;\n        }\n        return parms;\n    }\n\n    /**\n     * hasLocalStorage\n     *\n     * If localStorage support exists, is enabled, and works, return true.\n     *\n     * @this {Device}\n     * @returns {boolean}\n     */\n    hasLocalStorage()\n    {\n        if (Device.LocalStorage.Available === undefined) {\n            let f = false;\n            if (window) {\n                try {\n                    window.localStorage.setItem(Device.LocalStorage.Test, Device.LocalStorage.Test);\n                    f = (window.localStorage.getItem(Device.LocalStorage.Test) == Device.LocalStorage.Test);\n                    window.localStorage.removeItem(Device.LocalStorage.Test);\n                } catch(err) {\n                    this.println(err.message);\n                    f = false;\n                }\n            }\n            Device.LocalStorage.Available = f;\n        }\n        return !!Device.LocalStorage.Available;\n    }\n\n    /**\n     * hex(n)\n     *\n     * This is a helper function intended for use in a debugging console, allowing you to display\n     * numbers as hex by evaluating the expression \"this.hex(n)\".  Technically, this should be a static\n     * method, since there's nothing instance-specific about it, but \"this.hex()\" is easier to type than\n     * \"Device.hex()\".\n     *\n     * @this {Device}\n     * @param {number} n\n     */\n    hex(n)\n    {\n        return this.sprintf(\"%x\", n);\n    }\n\n    /**\n     * isCategory(category)\n     *\n     * Use this function to enable/disable any code (eg, print() calls) based on 1) whether specific\n     * categories are required, and 2) whether the specified category is one of them.\n     *\n     * @this {Device}\n     * @param {string} category\n     */\n    isCategoryOn(category)\n    {\n        return (Device.Category && Device.Category.indexOf(category) >= 0);\n    }\n\n    /**\n     * isUserAgent(s)\n     *\n     * Check the browser's user-agent string for the given substring; \"iOS\" and \"MSIE\" are special values you can\n     * use that will match any iOS or MSIE browser, respectively (even IE11, in the case of \"MSIE\").\n     *\n     * 2013-11-06: In a questionable move, MSFT changed the user-agent reported by IE11 on Windows 8.1, eliminating\n     * the \"MSIE\" string (which MSDN calls a \"version token\"; see http://msdn.microsoft.com/library/ms537503.aspx);\n     * they say \"public websites should rely on feature detection, rather than browser detection, in order to design\n     * their sites for browsers that don't support the features used by the website.\" So, in IE11, we get a user-agent\n     * that tries to fool apps into thinking the browser is more like WebKit or Gecko:\n     *\n     *      Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko\n     *\n     * @this {Device}\n     * @param {string} s is a substring to search for in the user-agent; as noted above, \"iOS\" and \"MSIE\" are special values\n     * @returns {boolean} is true if the string was found, false if not\n     */\n    isUserAgent(s)\n    {\n        if (window) {\n            let userAgent = window.navigator.userAgent;\n            return s == \"iOS\" && !!userAgent.match(/(iPod|iPhone|iPad)/) && !!userAgent.match(/AppleWebKit/) || s == \"MSIE\" && !!userAgent.match(/(MSIE|Trident)/) || (userAgent.indexOf(s) >= 0);\n        }\n        return false;\n    }\n\n    /**\n     * loadLocalStorage()\n     *\n     * @this {Device}\n     * @returns {Array|null}\n     */\n    loadLocalStorage()\n    {\n        let state = null;\n        if (this.hasLocalStorage()) {\n            let sValue;\n            if (window) {\n                try {\n                    sValue = window.localStorage.getItem(this.idMachine);\n                    if (sValue) state = /** @type {Array} */ (JSON.parse(sValue));\n                } catch (err) {\n                    this.println(err.message);\n                }\n            }\n        }\n        return state;\n    }\n\n    /**\n     * print(s)\n     *\n     * @this {Device}\n     * @param {string} s\n     */\n    print(s)\n    {\n        if (this.isCategoryOn(Device.CATEGORY.BUFFER)) {\n            Device.PrintBuffer += s;\n            return;\n        }\n        let element = this.findBinding(Device.BINDING.PRINT, true);\n        if (element) {\n            element.value += s;\n            /*\n             * Prevent the <textarea> from getting too large; otherwise, printing becomes slower and slower.\n             */\n            if (!DEBUG && element.value.length > 8192) {\n                element.value = element.value.substr(element.value.length - 4096);\n            }\n            element.scrollTop = element.scrollHeight;\n        }\n        if (DEBUG || !element) {\n            let i = s.lastIndexOf('\\n');\n            if (i >= 0) {\n                console.log(Device.PrintBuffer + s.substr(0, i));\n                Device.PrintBuffer = \"\";\n                s = s.substr(i + 1);\n            }\n            Device.PrintBuffer += s;\n        }\n    }\n\n    /**\n     * println(s)\n     *\n     * @this {Device}\n     * @param {string} s\n     */\n    println(s)\n    {\n        this.print(s + '\\n');\n    }\n\n    /**\n     * printf(format, ...args)\n     *\n     * @this {Device}\n     * @param {string} format\n     * @param {...} args\n     */\n    printf(format, ...args)\n    {\n        this.print(this.sprintf(format, ...args));\n    }\n\n    /**\n     * removeDevice(idDevice)\n     *\n     * @this {Device}\n     * @param {string} idDevice\n     * @returns {boolean} (true if successfully removed, false if not)\n     */\n    removeDevice(idDevice)\n    {\n        let device;\n        let devices = Device.Machines[this.idMachine];\n        if (devices) {\n            for (let i in devices) {\n                if (devices[i].idDevice == idDevice) {\n                    devices.splice(i, 1);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * saveLocalStorage(state)\n     *\n     * @this {Device}\n     * @param {Array} state\n     * @returns {boolean} true if successful, false if error\n     */\n    saveLocalStorage(state)\n    {\n        if (this.hasLocalStorage()) {\n            let sValue = JSON.stringify(state);\n            try {\n                window.localStorage.setItem(this.idMachine, sValue);\n                return true;\n            } catch(err) {\n                this.println(err.message);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * setBindingText(name, text)\n     *\n     * @this {Device}\n     * @param {string} name\n     * @param {string} text\n     */\n    setBindingText(name, text)\n    {\n        let element = this.bindings[name];\n        if (element) element.textContent = text;\n    }\n\n    /**\n     * setCategory(category)\n     *\n     * Use this function to set/clear categories.  Generally, these are thought of as print categories,\n     * allowing code to use isCategoryOn() to decide whether to print a certain category of messages, but\n     * it can be used to control any functionality related to a given category, not just printing.\n     *\n     * You usually want to use one of the predefined category strings in Device.CATEGORIES, but in reality,\n     * the category string can be anything you want.\n     *\n     * If you want to enable multiple categories, specify them all in a single string (eg, \"time|buffer\",\n     * or Device.CATEGORY.TIME + Device.CATEGORY.BUFFER).\n     *\n     * Device.CATEGORY.BUFFER is special, causing all print calls to be buffered; the print buffer will be\n     * dumped as soon as setCategory() clears Device.CATEGORY.BUFFER.\n     *\n     * @this {Device}\n     * @param {string} [category] (if undefined, clear previous category)\n     * @returns {string}\n     */\n    setCategory(category = \"\")\n    {\n        let cPrev = Device.Category;\n        let fFlush = (!category && this.isCategoryOn(Device.CATEGORY.BUFFER));\n        Device.Category = category;\n        if (fFlush) {\n            let sBuffer = Device.PrintBuffer;\n            Device.PrintBuffer = \"\";\n            this.print(sBuffer);\n        }\n        return cPrev;\n    }\n\n    /**\n     * sprintf(format, ...args)\n     *\n     * Copied from the CCjs project (https://github.com/jeffpar/ccjs/blob/master/lib/stdio.js) and extended.\n     *\n     * Far from complete, let alone sprintf-compatible, but it's adequate for the handful of sprintf-style format\n     * specifiers that I use.\n     *\n     * @this {Device}\n     * @param {string} format\n     * @param {...} args\n     * @returns {string}\n     */\n    sprintf(format, ...args)\n    {\n        let buffer = \"\";\n        let aParts = format.split(/%([-+ 0#]?)([0-9]*)(\\.?)([0-9]*)([hlL]?)([A-Za-z%])/);\n\n        let iArg = 0, iPart;\n        for (iPart = 0; iPart < aParts.length - 7; iPart += 7) {\n\n            buffer += aParts[iPart];\n\n            let arg = args[iArg++];\n            let flags = aParts[iPart+1];\n            let minimum = +aParts[iPart+2] || 0;\n            let precision = +aParts[iPart+4] || 0;\n            let conversion = aParts[iPart+6];\n            let ach = null, s;\n\n            switch(conversion) {\n            case 'd':\n                /*\n                 * We could use \"arg |= 0\", but there may be some value to supporting integers > 32 bits.\n                 */\n                arg = Math.trunc(arg);\n                /* falls through */\n\n            case 'f':\n                s = Math.trunc(arg) + \"\";\n                if (precision) {\n                    minimum -= (precision + 1);\n                }\n                if (s.length < minimum) {\n                    if (flags == '0') {\n                        if (arg < 0) minimum--;\n                        s = (\"0000000000\" + Math.abs(arg)).slice(-minimum);\n                        if (arg < 0) s = '-' + s;\n                    } else {\n                        s = (\"          \" + s).slice(-minimum);\n                    }\n                }\n                if (precision) {\n                    arg = Math.round((arg - Math.trunc(arg)) * Math.pow(10, precision));\n                    s += '.' + (\"0000000000\" + Math.abs(arg)).slice(-precision);\n                }\n                buffer += s;\n                break;\n\n            case 'c':\n                arg = String.fromCharCode(arg);\n                /* falls through */\n\n            case 's':\n                while (arg.length < minimum) {\n                    if (flags == '-') {\n                        arg += ' ';\n                    } else {\n                        arg = ' ' + arg;\n                    }\n                }\n                buffer += arg;\n                break;\n\n            case 'X':\n                ach = Device.HexUpperCase;\n                /* falls through */\n\n            case 'x':\n                if (!ach) ach = Device.HexLowerCase;\n                s = \"\";\n                do {\n                    s = ach[arg & 0xf] + s;\n                    arg >>>= 4;\n                } while (--minimum > 0 || arg);\n                buffer += s;\n                break;\n\n            default:\n                /*\n                 * The supported ANSI C set of conversions: \"dioxXucsfeEgGpn%\"\n                 */\n                buffer += \"(unrecognized printf conversion %\" + conversion + \")\";\n                break;\n            }\n        }\n\n        buffer += aParts[iPart];\n        return buffer;\n    }\n}\n\nDevice.BINDING = {\n    CLEAR:      \"clear\",\n    PRINT:      \"print\"\n};\n\n/*\n * List of standard categories.\n *\n * Device.CATEGORY.BUFFER is special, causing all print calls to be buffered; the print buffer will be\n * dumped as soon as setCategory() clears Device.CATEGORY.BUFFER.\n */\nDevice.CATEGORY = {\n    TIME:       \"time\",\n    BUFFER:     \"buffer\"\n};\n\nDevice.COMMANDS = [\n    \"c\\t\\tset category\"\n];\n\nDevice.HANDLER = {\n    COMMAND:    \"command\"\n};\n\nDevice.Alerts = {\n    list:       [],\n    Version:    \"version\"\n};\n\nDevice.LocalStorage = {\n    Available:  undefined,\n    Test:       \"PCjs.localStorage\"\n};\n\n/**\n * Handlers is a global object whose properties are machine IDs, each of which contains zero or more\n * handler IDs, each of which contains an arrays of functions.\n *\n * @type {Object}\n */\nDevice.Handlers = {};\n\n/**\n * Machines is a global object whose properties are machine IDs and whose values are arrays of Devices.\n *\n * @type {Object}\n */\nDevice.Machines = {};\n\n/**\n * Category is a global string that contains zero or more Device.CATEGORY strings; see setCategory().\n *\n * @type {string}\n */\nDevice.Category = \"\";\n\n/**\n * PrintBuffer is a global string that buffers partial lines for our print services when using console.log().\n *\n * @type {string}\n */\nDevice.PrintBuffer = \"\";\n\n/*\n * Handy global constants\n */\nDevice.HexLowerCase = \"0123456789abcdef\";\nDevice.HexUpperCase = \"0123456789ABCDEF\";\n\n/**\n * @copyright https://www.pcjs.org/modules/devices/input.js (C) Jeff Parsons 2012-2018\n */\n\n/** @typedef {{ class: string, bindings: (Object|undefined), version: (number|undefined), overrides: (Array.<string>|undefined), location: Array.<number>, map: (Array.<Array.<number>>|undefined), drag: (boolean|undefined), scroll: (boolean|undefined), hexagonal: (boolean|undefined), buttonDelay: (number|undefined) }} */\nvar InputConfig;\n\n/**\n * @class {Input}\n * @unrestricted\n * @property {InputConfig} config\n * @property {Array.<number>} location\n * @property {Array.<Array.<number>>} map\n * @property {boolean} fDrag\n * @property {boolean} fScroll\n * @property {boolean} fHexagonal\n * @property {number} buttonDelay\n * @property {{\n *  surface: HTMLImageElement|undefined\n * }} bindings\n */\nclass Input extends Device {\n    /**\n     * Input(idMachine, idDevice, config)\n     *\n     * Sample config:\n     *\n     *      \"input\": {\n     *        \"class\": \"Input\",\n     *        \"location\": [139, 325, 368, 478, 0.34, 0.5, 640, 853],\n     *        \"map\": [\n     *          [\"2nd\",  \"inv\",  \"lnx\",  \"\\\\b\",  \"clr\"],\n     *          [\"lrn\",  \"xchg\", \"sq\",   \"sqrt\", \"rcp\"],\n     *          [\"sst\",  \"sto\",  \"rcl\",  \"sum\",  \"exp\"],\n     *          [\"bst\",  \"ee\",   \"(\",    \")\",    \"/\"],\n     *          [\"gto\",  \"7\",    \"8\",    \"9\",    \"*\"],\n     *          [\"sbr\",  \"4\",    \"5\",    \"6\",    \"-\"],\n     *          [\"rst\",  \"1\",    \"2\",    \"3\",    \"+\"],\n     *          [\"r/s\",  \"0\",    \".\",    \"+/-\",  \"=|\\\\r\"]\n     *        ],\n     *        \"drag\": false,\n     *        \"bindings\": {\n     *          \"surface\": \"imageTI57\",\n     *          \"power\": \"powerTI57\",\n     *          \"reset\": \"resetTI57\"\n     *        }\n     *      }\n     *\n     * A word about the \"power\" button: the page will likely use absolute positioning to overlay the HTML button\n     * onto the image of the physical button, and the temptation might be to use the style \"display:none\" to hide\n     * it, but \"opacity:0\" should be used instead, because otherwise our efforts to use it as focusable element\n     * may fail.\n     *\n     * @this {Input}\n     * @param {string} idMachine\n     * @param {string} idDevice\n     * @param {InputConfig} [config]\n     */\n    constructor(idMachine, idDevice, config)\n    {\n        super(idMachine, idDevice, Input.VERSION, config);\n\n        this.time = /** @type {Time} */ (this.findDeviceByClass(Machine.CLASS.TIME));\n\n        this.onInput = null;\n        this.onPower = null;\n        this.onReset = null;\n        this.onHover = null;\n\n        /*\n         * If 'drag' is true, then the onInput() handler will be called whenever the current col and/or row\n         * changes, even if the mouse hasn't been released since the previous onInput() call.\n         *\n         * The default is false, because in general, allowing drag is a bad idea for calculator buttons.  But\n         * I've made this an option for other input surfaces, like LED arrays, where you might want to turn a\n         * series of LEDs on or off.\n         */\n        this.fDrag = this.getDefaultBoolean('drag', false);\n\n        /*\n         * If 'scroll' is true, then we do NOT call preventDefault() on touch events; this permits the input\n         * surface to be scrolled like any other part of the page.  The default is false, because this has other\n         * side-effects (eg, inadvertent zooms).\n         */\n        this.fScroll = this.getDefaultBoolean('scroll', false);\n\n        /*\n         * This is set on receipt of the first 'touch' event of any kind, and is used by the 'mouse' event\n         * handlers to disregard mouse events if set.\n         */\n        this.fTouch = false;\n\n        let element = this.bindings[Input.BINDING.SURFACE];\n        if (element) {\n            /*\n             * The location array, eg:\n             *\n             *      \"location\": [139, 325, 368, 478, 0.34, 0.5, 640, 853, 180, 418, 75, 36],\n             *\n             * contains the top left corner (xInput, yInput) and dimensions (cxInput, cyInput)\n             * of the input rectangle where the buttons described in the map are located, relative\n             * to the surface image.  It also describes the average amount of horizontal and vertical\n             * space between buttons, as fractions of the average button width and height (hGap, vGap).\n             *\n             * With all that, we can now calculate the center lines for each column and row.  This\n             * obviously assumes that all the buttons are evenly laid out in a perfect grid.  For\n             * devices that don't have such a nice layout, a different location array format will\n             * have to be defined.\n             *\n             * NOTE: While element.naturalWidth and element.naturalHeight should, for all modern\n             * browsers, contain the surface image's dimensions as well, those values still might not\n             * be available if our constructor is called before the page's onload event has fired,\n             * so we allow them to be stored in the next two elements of the location array, too.\n             *\n             * Finally, the position and size of the device's power button may be stored in the array\n             * as well, in case some browsers refuse to generate onClickPower() events (eg, if they\n             * think the button is inaccessible/not visible).\n             */\n            let location = this.config['location'];\n            this.xInput = location[0];\n            this.yInput = location[1];\n            this.cxInput = location[2];\n            this.cyInput = location[3];\n            this.hGap = location[4] || 1.0;\n            this.vGap = location[5] || 1.0;\n            this.cxSurface = location[6] || element.naturalWidth || this.cxInput;\n            this.cySurface = location[7] || element.naturalHeight || this.cyInput;\n            this.xPower = location[8] || 0;\n            this.yPower = location[9] || 0;\n            this.cxPower = location[10] || 0;\n            this.cyPower = location[11] || 0;\n            this.map = this.config['map'];\n            if (this.map) {\n                this.nRows = this.map.length;\n                this.nCols = this.map[0].length;\n            } else {\n                this.nCols = this.hGap;\n                this.nRows = this.vGap;\n                this.hGap = this.vGap = 0;\n            }\n\n            /*\n             * If 'hexagonal' is true, then we treat the input grid as hexagonal, where even rows of the associated\n             * display are offset.\n             */\n            this.fHexagonal = this.getDefaultBoolean('hexagonal', false);\n            \n            /*\n             * The 'buttonDelay' setting is only necessary for devices (ie, old calculator chips) that are either slow\n             * to respond and/or have debouncing logic that would otherwise be defeated.\n             */\n            this.buttonDelay = this.getDefaultNumber('buttonDelay', 0);\n\n            /*\n             * To calculate the average button width (cxButton), we know that the overall width\n             * must equal the sum of all the button widths + the sum of all the button gaps:\n             *\n             *      cxInput = nCols * cxButton + nCols * (cxButton * hGap)\n             *\n             * The number of gaps would normally be (nCols - 1), but we require that cxInput include\n             * only 1/2 the gap at the edges, too.  Solving for cxButton:\n             *\n             *      cxButton = cxInput / (nCols + nCols * hGap)\n             */\n            this.cxButton = (this.cxInput / (this.nCols + this.nCols * this.hGap))|0;\n            this.cyButton = (this.cyInput / (this.nRows + this.nRows * this.vGap))|0;\n            this.cxGap = (this.cxButton * this.hGap)|0;\n            this.cyGap = (this.cyButton * this.vGap)|0;\n\n            /*\n             * xStart and yStart record the last 'touchstart' or 'mousedown' position on the surface\n             * image; they will be reset to -1 when movement has ended (eg, 'touchend' or 'mouseup').\n             */\n            this.xStart = this.yStart = -1;\n\n            this.captureMouse(element);\n            this.captureTouch(element);\n\n            if (this.time) {\n                /*\n                 * We use a timer for the touch/mouse release events, to ensure that the machine had\n                 * enough time to notice the input before releasing it.\n                 */\n                let input = this;\n                if (this.buttonDelay) {\n                    this.timerInputRelease = this.time.addTimer(\"timerInputRelease\", function onInputRelease() {\n                        if (input.xStart < 0 && input.yStart < 0) { // auto-release ONLY if it's REALLY released\n                            input.setPosition(-1, -1);\n                        }\n                    });\n                }\n                if (this.map) {\n                    /*\n                     * This auto-releases the last key reported after an appropriate delay, to ensure that\n                     * the machine had enough time to notice the corresponding button was pressed.\n                     */\n                    if (this.buttonDelay) {\n                        this.timerKeyRelease = this.time.addTimer(\"timerKeyRelease\", function onKeyRelease() {\n                            input.onKeyTimer();\n                        });\n                    }\n                    /*\n                     * I used to maintain a single-key buffer (this.keyPressed) and would immediately release\n                     * that key as soon as another key was pressed, but it appears that the ROM wants a minimum\n                     * delay between release and the next press -- probably for de-bouncing purposes.  So we\n                     * maintain a key state: 0 means no key has gone down or up recently, 1 means a key just went\n                     * down, and 2 means a key just went up.  keysPressed maintains a queue of keys (up to 16)\n                     * received while key state is non-zero.\n                     */\n                    this.keyState = 0;\n                    this.keysPressed = [];\n                    /*\n                     * I'm attaching my 'keypress' handlers to the document object, since image elements are\n                     * not focusable.  I'm disinclined to do what I've done with other machines (ie, create an\n                     * invisible <textarea> overlay), because in this case, I don't really want a soft keyboard\n                     * popping up and obscuring part of the display.\n                     *\n                     * A side-effect, however, is that if the user attempts to explicitly give the image\n                     * focus, we don't have anything for focus to attach to.  We address that in onMouseDown(),\n                     * by redirecting focus to the \"power\" button, if any, not because we want that or any other\n                     * button to have focus, but simply to remove focus from any other input element on the page.\n                     */\n                    this.captureKeys(document);\n                }\n            }\n\n            /*\n             * Finally, the active input state.  If there is no active input, col and row are -1.  After\n             * this point, these variables will be updated by setPosition().\n             */\n            this.col = this.row = -1;\n        }\n    }\n\n    /**\n     * addBinding(binding, element)\n     *\n     * @this {Input}\n     * @param {string} binding\n     * @param {Element} element\n     */\n    addBinding(binding, element)\n    {\n        let input = this;\n\n        switch(binding) {\n\n        case Input.BINDING.POWER:\n            element.onclick = function onClickPower() {\n                if (input.onPower) input.onPower();\n            };\n            break;\n\n        case Input.BINDING.RESET:\n            element.onclick = function onClickReset() {\n                if (input.onReset) input.onReset();\n            };\n            break;\n        }\n        super.addBinding(binding, element);\n    }\n\n    /**\n     * addClick(onPower, onReset)\n     *\n     * Called by the Chip device to set up power and reset notifications.\n     *\n     * @this {Input}\n     * @param {function()} [onPower] (called when the \"power\" button, if any, is clicked)\n     * @param {function()} [onReset] (called when the \"reset\" button, if any, is clicked)\n     */\n    addClick(onPower, onReset)\n    {\n        this.onPower = onPower;\n        this.onReset = onReset;\n    }\n\n    /**\n     * addHover(onHover)\n     *\n     * @this {Input}\n     * @param {function(number, number)} onHover\n     */\n    addHover(onHover)\n    {\n        this.onHover = onHover;\n    }\n\n    /**\n     * addInput(onInput)\n     *\n     * Called by the Chip device to set up input notifications.\n     *\n     * @this {Input}\n     * @param {function(number,number)} onInput\n     */\n    addInput(onInput)\n    {\n        this.onInput = onInput;\n    }\n\n    /**\n     * advanceKeyState()\n     *\n     * @this {Input}\n     */\n    advanceKeyState()\n    {\n        if (!this.buttonDelay) {\n            this.onKeyTimer();\n        } else {\n            this.time.setTimer(this.timerKeyRelease, this.buttonDelay);\n        }\n    }\n\n    /**\n     * captureKeys(element)\n     *\n     * @this {Input}\n     * @param {Document|Element} element\n     */\n    captureKeys(element)\n    {\n        let input = this;\n        element.addEventListener(\n            'keydown',\n            function onKeyDown(event) {\n                event = event || window.event;\n                let activeElement = document.activeElement;\n                if (activeElement == input.bindings[Input.BINDING.POWER]) {\n                    let keyCode = event.which || event.keyCode;\n                    let ch = Input.KEYCODE[keyCode];\n                    if (ch && input.onKeyPress(ch)) event.preventDefault();\n                }\n            }\n        );\n        element.addEventListener(\n            'keypress',\n            function onKeyPress(event) {\n                event = event || window.event;\n                let charCode = event.which || event.charCode;\n                let ch = String.fromCharCode(charCode);\n                if (ch && input.onKeyPress(ch)) event.preventDefault();\n            }\n        );\n    }\n\n    /**\n     * captureMouse(element)\n     *\n     * @this {Input}\n     * @param {HTMLImageElement} element\n     */\n    captureMouse(element)\n    {\n        let input = this;\n\n        element.addEventListener(\n            'mousedown',\n            function onMouseDown(event) {\n                if (input.fTouch) return;\n                /*\n                 * If there are any text input elements on the page that might currently have focus,\n                 * this is a good time to divert focus to a focusable element of our own (eg, a \"power\"\n                 * button).  Otherwise, key presses could be confusingly processed in two places.\n                 *\n                 * Unfortunately, setting focus on an element can cause the browser to scroll the element\n                 * into view, so to avoid that, we use the following scrollTo() work-around.\n                 */\n                let button = input.bindings[Input.BINDING.POWER];\n                if (button) {\n                    let x = window.scrollX, y = window.scrollY;\n                    button.focus();\n                    window.scrollTo(x, y);\n                }\n                if (!event.button) {\n                    input.processEvent(element, Input.ACTION.PRESS, event);\n                }\n            }\n        );\n\n        element.addEventListener(\n            'mousemove',\n            function onMouseMove(event) {\n                if (input.fTouch) return;\n                input.processEvent(element, Input.ACTION.MOVE, event);\n            }\n        );\n\n        element.addEventListener(\n            'mouseup',\n            function onMouseUp(event) {\n                if (input.fTouch) return;\n                if (!event.button) {\n                    input.processEvent(element, Input.ACTION.RELEASE, event);\n                }\n            }\n        );\n\n        element.addEventListener(\n            'mouseout',\n            function onMouseOut(event) {\n                if (input.fTouch) return;\n                if (input.xStart < 0) {\n                    input.processEvent(element, Input.ACTION.MOVE, event);\n                } else {\n                    input.processEvent(element, Input.ACTION.RELEASE, event);\n                }\n            }\n        );\n    }\n\n    /**\n     * captureTouch(element)\n     *\n     * @this {Input}\n     * @param {HTMLImageElement} element\n     */\n    captureTouch(element)\n    {\n        let input = this;\n\n        /*\n         * NOTE: The mouse event handlers below deal only with events where the left button is involved\n         * (ie, left button is pressed, down, or released).\n         */\n        element.addEventListener(\n            'touchstart',\n            function onTouchStart(event) {\n                /*\n                 * Under normal circumstances (ie, when fScroll is false), when any touch events arrive,\n                 * processEvent() calls preventDefault(), which prevents a variety of potentially annoying\n                 * behaviors (ie, zooming, scrolling, fake mouse events, etc).  Under non-normal circumstances,\n                 * (ie, when fScroll is true), we set fTouch on receipt of a 'touchstart' event, which will\n                 * help our mouse event handlers avoid any redundant actions due to fake mouse events.\n                 */\n                if (input.fScroll) input.fTouch = true;\n                input.processEvent(element, Input.ACTION.PRESS, event);\n            }\n        );\n\n        element.addEventListener(\n            'touchmove',\n            function onTouchMove(event) {\n                input.processEvent(element, Input.ACTION.MOVE, event);\n            }\n        );\n\n        element.addEventListener(\n            'touchend',\n            function onTouchEnd(event) {\n                input.processEvent(element, Input.ACTION.RELEASE, event);\n            }\n        );\n    }\n\n    /**\n     * onKeyPress(ch)\n     *\n     * @this {Input}\n     * @param {string} ch\n     * @returns {boolean} (true if processed, false if not)\n     */\n    onKeyPress(ch)\n    {\n        for (let row = 0; row < this.map.length; row++) {\n            let rowMap = this.map[row];\n            for (let col = 0; col < rowMap.length; col++) {\n                let aParts = rowMap[col].split('|');\n                if (aParts.indexOf(ch) >= 0) {\n                    if (this.keyState) {\n                        if (this.keysPressed.length < 16) {\n                            this.keysPressed.push(ch);\n                        }\n                    } else {\n                        this.keyState = 1;\n                        this.setPosition(col, row);\n                        this.advanceKeyState();\n                    }\n                    return true;\n                }\n            }\n        }\n        this.printf(\"unrecognized key '%s' (0x%02x)\\n\", ch, ch.charCodeAt(0));\n        return false;\n    }\n\n    /**\n     * onKeyTimer()\n     *\n     * @this {Input}\n     */\n    onKeyTimer()\n    {\n\n        if (this.keyState == 1) {\n            this.keyState++;\n            this.setPosition(-1, -1);\n            this.advanceKeyState();\n        } else {\n            this.keyState = 0;\n            if (this.keysPressed.length) {\n                this.onKeyPress(this.keysPressed.shift());\n            }\n        }\n    }\n\n    /**\n     * processEvent(element, action, event)\n     *\n     * @this {Input}\n     * @param {HTMLImageElement} element\n     * @param {number} action\n     * @param {Event|MouseEvent|TouchEvent} [event] (eg, the object from a 'touch' or 'mouse' event)\n     */\n    processEvent(element, action, event)\n    {\n        let col = -1, row = -1;\n        let fMultiTouch = false;\n        let x, y, xInput, yInput, fButton, fInput, fPower;\n\n        if (action < Input.ACTION.RELEASE) {\n\n            /**\n             * @name Event\n             * @property {Array} targetTouches\n             */\n            event = event || window.event;\n\n            if (!event.targetTouches || !event.targetTouches.length) {\n                x = event.pageX;\n                y = event.pageY;\n            } else {\n                x = event.targetTouches[0].pageX;\n                y = event.targetTouches[0].pageY;\n                fMultiTouch = (event.targetTouches.length > 1);\n            }\n\n            /*\n             * Touch coordinates (that is, the pageX and pageY properties) are relative to the page, so to make\n             * them relative to the element, we must subtract the element's left and top positions.  This Apple web page:\n             *\n             *      https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/AddingMouseandTouchControlstoCanvas/AddingMouseandTouchControlstoCanvas.html\n             *\n             * makes it sound simple, but it turns out we have to walk the element's entire \"parentage\" of DOM elements\n             * to get the exact offsets.\n             */\n            let xOffset = 0;\n            let yOffset = 0;\n            let elementNext = element;\n            do {\n                if (!isNaN(elementNext.offsetLeft)) {\n                    xOffset += elementNext.offsetLeft;\n                    yOffset += elementNext.offsetTop;\n                }\n            } while ((elementNext = elementNext.offsetParent));\n\n            /*\n             * Due to the responsive nature of our pages, the displayed size of the surface image may be smaller than\n             * the original size, and the coordinates we receive from events are based on the currently displayed size.\n             */\n            x = ((x - xOffset) * (this.cxSurface / element.offsetWidth))|0;\n            y = ((y - yOffset) * (this.cySurface / element.offsetHeight))|0;\n\n            xInput = x - this.xInput;\n            yInput = y - this.yInput;\n\n            /*\n             * fInput is set if the event occurred somewhere within the input region (ie, the calculator keypad),\n             * either on a button or between buttons, whereas fButton is set if the event occurred squarely (rectangularly?)\n             * on a button.  fPower deals separately with the power button; it is set if the event occurred on the\n             * power button.\n             */\n            fInput = fButton = false;\n            fPower = (x >= this.xPower && x < this.xPower + this.cxPower && y >= this.yPower && y < this.yPower + this.cyPower);\n\n            /*\n             * I use the top of the input region, less some gap, to calculate a dividing line, above which\n             * default actions should be allowed, and below which they should not.  Ditto for any event inside\n             * the power button.\n             */\n            if (xInput >= 0 && xInput < this.cxInput && yInput + this.cyGap >= 0 || fPower) {\n                /*\n                 * If we allow touch events to be processed, they will generate mouse events as well, causing\n                 * confusion and delays.  We can sidestep that problem by preventing default actions on any event\n                 * that occurs within the input region.  One downside is that you can no longer scroll or zoom the\n                 * image using touch, but that may be just as well, because you probably don't want sloppy touches\n                 * moving your display around (or worse, a rapid double-tap zooming the display).  I do try to\n                 * make one small concession for two-finger zoom operations (see fMultiTouch), but that's a bit\n                 * fiddly, because it depends on both fingers hitting the surface at the same instant.\n                 */\n                if (!fMultiTouch && !this.fScroll) event.preventDefault();\n\n                if (xInput >= 0 && xInput < this.cxInput && yInput >= 0 && yInput < this.cyInput) {\n                    fInput = true;\n                    /*\n                     * The width and height of each column and row could be determined by computing cxGap + cxButton\n                     * and cyGap + cyButton, respectively, but those gap and button sizes are merely estimates, and should\n                     * only be used to help with the final button coordinate checks farther down.\n                     */\n                    let cxCol = (this.cxInput / this.nCols) | 0;\n                    let cyCol = (this.cyInput / this.nRows) | 0;\n                    let colInput = (xInput / cxCol) | 0;\n                    let rowInput = (yInput / cyCol) | 0;\n\n                    /*\n                     * If the grid is hexagonal (aka \"Lite-Brite\" mode), then the cells of even-numbered rows are\n                     * offset horizontally by 1/2 cell.  In addition, the last cell in those rows is unused, so if\n                     * after compensating by 1/2 cell, the target column is the last cell, we set xInput to -1,\n                     * effectively ignoring input on that cell.\n                     */\n                    if (this.fHexagonal && !(rowInput & 0x1)) {\n                        xInput -= (cxCol >> 1);\n                        colInput = (xInput / cxCol) | 0;\n                        if (colInput == this.nCols - 1) xInput = -1;\n                    }\n\n                    /*\n                     * (xCol,yCol) will be the top left corner of the button closest to the point of input.  However, that's\n                     * based on our gap estimate.  If things seem \"too tight\", shrink the gap estimates, which will automatically\n                     * increase the button size estimates.\n                     */\n                    let xCol = colInput * cxCol + (this.cxGap >> 1);\n                    let yCol = rowInput * cyCol + (this.cyGap >> 1);\n\n                    xInput -= xCol;\n                    yInput -= yCol;\n                    if (xInput >= 0 && xInput < this.cxButton && yInput >= 0 && yInput < this.cyButton) {\n                        col = colInput;\n                        row = rowInput;\n                        fButton = true;\n                    }\n                }\n            }\n        }\n\n        if (fMultiTouch) return;\n\n        if (action == Input.ACTION.PRESS) {\n            /*\n             * Record the position of the event, transitioning xStart and yStart to non-negative values.\n             */\n            this.xStart = x;\n            this.yStart = y;\n            if (fInput) {\n                /*\n                 * The event occurred in the input region, so we call setPosition() regardless of whether\n                 * it hit or missed a button.\n                 */\n                this.setPosition(col, row);\n                /*\n                 * On the other hand, if it DID hit a button, then we arm the auto-release timer, to ensure\n                 * a minimum amount of time (ie, BUTTON_DELAY).\n                 */\n                if (fButton && this.buttonDelay) {\n                    this.time.setTimer(this.timerInputRelease, this.buttonDelay, true);\n                }\n            } else if (fPower && this.onPower) {\n                this.onPower();\n            }\n        }\n        else if (action == Input.ACTION.MOVE) {\n            if (this.xStart >= 0 && this.yStart >= 0 && this.fDrag) {\n                this.setPosition(col, row);\n            }\n            else if (this.onHover) {\n                this.onHover(col, row);\n            }\n        }\n        else if (action == Input.ACTION.RELEASE) {\n            /*\n             * Don't immediately signal the release if the release timer is active (let the timer take care of it).\n             */\n            if (!this.buttonDelay || !this.time.isTimerSet(this.timerInputRelease)) {\n                this.setPosition(-1, -1);\n            }\n            this.xStart = this.yStart = -1;\n        }\n        else {\n            this.println(\"unrecognized action: \" + action);\n        }\n    }\n\n    /**\n     * setPosition(col, row)\n     *\n     * @this {Input}\n     * @param {number} col\n     * @param {number} row\n     */\n    setPosition(col, row)\n    {\n        if (col != this.col || row != this.row) {\n            this.col = col;\n            this.row = row;\n            if (this.onInput) this.onInput(col, row);\n        }\n    }\n}\n\nInput.ACTION = {\n    PRESS:      1,              // eg, an action triggered by a 'mousedown' or 'touchstart' event\n    MOVE:       2,              // eg, an action triggered by a 'mousemove' or 'touchmove' event\n    RELEASE:    3               // eg, an action triggered by a 'mouseup' (or 'mouseout') or 'touchend' event\n};\n\nInput.BINDING = {\n    POWER:      \"power\",\n    RESET:      \"reset\",\n    SURFACE:    \"surface\"\n};\n\nInput.KEYCODE = {               // keyCode from keydown/keyup events\n    0x08:       \"\\b\"            // backspace\n};\n\nInput.BUTTON_DELAY = 50;        // minimum number of milliseconds to ensure between button presses and releases\n\nInput.VERSION = +VERSION || 1.20;\n\n/**\n * @copyright https://www.pcjs.org/modules/devices/led.js (C) Jeff Parsons 2012-2018\n */\n\n/** @typedef {{ class: string, bindings: (Object|undefined), version: (number|undefined), overrides: (Array.<string>|undefined), type: number, width: (number|undefined), height: (number|undefined), cols: (number|undefined), colsExtra: (number|undefined), rows: (number|undefined), rowsExtra: (number|undefined), color: (string|undefined), backgroundColor: (string|undefined), fixed: (boolean|undefined), hexagonal: (boolean|undefined), highlight: (boolean|undefined), persistent: (boolean|undefined) }} */\nvar LEDConfig;\n\n/**\n * The ultimate goal is to provide support for a variety of LED types, such as:\n *\n * 1) LED Light (single light)\n * 2) LED Digit (7-segment digit)\n *\n * The initial goal is to manage a 12-element array of 7-segment LED digits for the TI-57.\n *\n * We create a \"view\" canvas element inside the specified \"container\" element, along with a \"grid\" canvas\n * where all the real drawing occurs; drawView() then renders the \"grid\" canvas onto the \"view\" canvas.\n *\n * Internally, our LED digits have a width and height of 96 and 128.  Those are \"grid\" dimensions which\n * cannot be changed, because our table of drawing coordinates in LED.SEGMENTS are hard-coded for those\n * dimensions.  The cell width and height that are specified as part of the LEDConfig are \"view\" dimensions,\n * which usually match the grid dimensions, but you're welcome to scale them up or down; the browser's\n * drawImage() function takes care of that.\n *\n * There is a low-level function, drawGridSegment(), for drawing specific LED segments of specific digits;\n * generally, you start with clearGrid(), draw all the segments for a given update, and then call drawView()\n * to make them visible.\n *\n * However, our Chip devices operate at a higher level.  They use setLEDState() to modify the state,\n * character, etc, that each of the LED cells should display, which updates our internal LED buffer.  Then\n * at whatever display refresh rate is set (typically 60Hz), drawBuffer() is called to see if the buffer\n * contents have been modified since the last refresh, and if so, it converts the contents of the buffer to\n * a string and calls drawString().\n *\n * This buffering strategy, combined with the buffer \"tickled\" flag (see below), not only makes life\n * simple for the Chip device, but also simulates how the display goes blank for short periods of time while\n * the Chip is busy performing calculations.\n *\n * @class {LED}\n * @unrestricted\n * @property {LEDConfig} config\n * @property {number} type (one of the LED.TYPE values)\n * @property {number} width (default is 96 for LED.TYPE.DIGIT, 32 otherwise; see LED.SIZES)\n * @property {number} height (default is 128 for LED.TYPE.DIGIT, 32 otherwise; see LED.SIZES)\n * @property {number} cols (default is 1)\n * @property {number} rows (default is 1)\n * @property {number} colsView (default is cols)\n * @property {number} rowsView (default is rows)\n * @property {string} color (default is none; ie, transparent foreground)\n * @property {string} colorBackground (default is none; ie, transparent background)\n * @property {boolean} fFixed (default is false, meaning the view may fill the container to its maximum size)\n * @property {boolean} fHexagonal (default is false)\n * @property {boolean} fHighlight (default is true)\n * @property {boolean} fPersistent (default is false for LED.TYPE.DIGIT, meaning the view will be blanked if not refreshed)\n * @property {number} widthView (computed)\n * @property {number} heightView (computed)\n * @property {number} widthGrid (computed)\n * @property {number} heightGrid (computed)\n * @property {HTMLCanvasElement} canvasView\n * @property {CanvasRenderingContext2D} contextView\n * @property {HTMLCanvasElement} canvasGrid\n * @property {CanvasRenderingContext2D} contextGrid\n * @property {{ container: Element|undefined }} bindings\n * @property {Array.<string|number|null>} buffer\n * @property {Array.<string|number>|null} bufferClone\n * @property {boolean} fBufferModified\n * @property {boolean} fBufferTickled\n */\nclass LED extends Device {\n    /**\n     * LED(idMachine, idDevice, config)\n     *\n     * Sample config:\n     *\n     *      \"display\": {\n     *        \"class\": \"LED\",\n     *        \"type\": 3,\n     *        \"cols\": 12,\n     *        \"rows\": 1,\n     *        \"color\": \"red\",\n     *        \"bindings\": {\n     *          \"container\": \"displayTI57\"\n     *        }\n     *      }\n     *\n     * @this {LED}\n     * @param {string} idMachine\n     * @param {string} idDevice\n     * @param {LEDConfig} [config]\n     */\n    constructor(idMachine, idDevice, config)\n    {\n        super(idMachine, idDevice, LED.VERSION, config);\n\n        let container = this.bindings[LED.BINDING.CONTAINER];\n        if (!container) {\n            let sError = \"LED binding for '\" + LED.BINDING.CONTAINER + \"' missing: '\" + this.config.bindings[LED.BINDING.CONTAINER] + \"'\";\n            throw new Error(sError);\n        }\n\n        let canvasView = /** @type {HTMLCanvasElement} */ (document.createElement(\"canvas\"));\n        if (!canvasView || !canvasView.getContext) {\n            let sError = \"LED device requires HTML5 canvas support\";\n            container.innerHTML = sError;\n            throw new Error(sError);\n        }\n\n        this.container = container;\n        this.canvasView = canvasView;\n\n        this.type = this.getBounded(this.getDefaultNumber('type', LED.TYPE.ROUND), LED.TYPE.SMALL, LED.TYPE.DIGIT);\n        this.widthCell = LED.SIZES[this.type][0];\n        this.heightCell = LED.SIZES[this.type][1];\n        this.width = this.getDefaultNumber('width', this.widthCell);\n        this.height = this.getDefaultNumber('height', this.heightCell);\n        this.colsView = this.getDefaultNumber('cols',  1);\n        this.cols = this.colsView + this.getDefaultNumber('colsExtra', 0);\n        this.rowsView = this.getDefaultNumber('rows',  1);\n        this.rows = this.rowsView + this.getDefaultNumber('rowsExtra', 0);\n        this.widthView = this.width * this.colsView;\n        this.heightView = this.height * this.rowsView;\n\n        this.colorTransparent = this.getRGBAColor(\"black\", 0);\n        this.colorOn = this.getRGBColor(this.config['color']) || this.colorTransparent;\n        this.colorOff = this.getRGBAColor(this.colorOn, 1.0, 0.25);\n        this.colorHighlight = this.getRGBAColor(this.colorOn, 1.0, 2.0);\n        this.colorBackground = this.getRGBColor(this.config['backgroundColor']);\n\n        /*\n         * We generally want our view canvas to be \"responsive\", not \"fixed\" (ie, to automatically resize\n         * with changes to the overall window size), so we apply the following style attributes (formerly\n         * applied with the \"pcjs-canvas\" style in /modules/shared/templates/components.css):\n         *\n         *      width: 100%;\n         *      height: auto;\n         *\n         * But, if you really don't want that feature, then set the LED config's \"fixed\" property to true.\n         */\n        this.fFixed = this.getDefaultBoolean('fixed', false);\n        if (!this.fFixed) {\n            canvasView.style.width = \"100%\";\n            canvasView.style.height = \"auto\";\n        }\n\n        /*\n         * Hexagonal (aka \"Lite-Brite\" mode) and highlighting options\n         */\n        this.fHexagonal = this.getDefaultBoolean('hexagonal', false);\n        this.fHighlight = this.getDefaultBoolean('highlight', true);\n\n        /*\n         * Persistent LEDS are the default, except for LED.TYPE.DIGIT, which is used with calculator displays\n         * whose underlying hardware must constantly \"refresh\" the LEDs to prevent them from going dark.\n         */\n        this.fPersistent = this.getDefaultBoolean('persistent', (this.type < LED.TYPE.DIGIT));\n\n        canvasView.setAttribute(\"width\", this.widthView.toString());\n        canvasView.setAttribute(\"height\", this.heightView.toString());\n        canvasView.style.backgroundColor = this.colorTransparent;\n        container.appendChild(canvasView);\n        this.contextView = /** @type {CanvasRenderingContext2D} */ (canvasView.getContext(\"2d\"));\n\n        /*\n         * canvasGrid is where all LED segments are composited; then they're drawn onto canvasView.\n         */\n        this.canvasGrid = /** @type {HTMLCanvasElement} */ (document.createElement(\"canvas\"));\n        if (this.canvasGrid) {\n            this.canvasGrid.width = this.widthGrid = this.widthCell * this.colsView;\n            this.canvasGrid.height = this.heightGrid = this.heightCell * this.rowsView;\n            this.contextGrid = this.canvasGrid.getContext(\"2d\");\n        }\n\n        /*\n         * Time to allocate our internal LED buffer.  Other devices access the buffer through interfaces\n         * like setLEDState() and getLEDState().  The LED buffer contains four per elements per LED cell:\n         *\n         *      [0]:    state (eg, ON or OFF or a digit)\n         *      [1]:    color\n         *      [2]:    count(s) (eg, 0 to 8  4-bit counts)\n         *      [3]:    flags (eg, PERIOD, MODIFIED, etc)\n         *\n         * The LED buffer also contains an extra (scratch) row at the end.  This extra row, along with the\n         * dynamically allocated \"clone\" buffer, is used by the LED Controller for direct buffer manipulation;\n         * see the low-level getBuffer(), getBufferClone(), and swapBuffers() interfaces.\n         */\n        this.nBufferInc = 4;\n        this.nBufferCells = ((this.rows + 1) * this.cols) * this.nBufferInc;\n        this.buffer = new Array(this.nBufferCells);\n        this.bufferClone = null;\n        this.nBufferIncExtra = (this.colsView < this.cols? (this.cols - this.colsView) * 4 : 0);\n\n        /*\n         * fBufferModified is straightforward: set to true by any setLEDState() call that actually\n         * changed something in the LED buffer, set to false after every drawBuffer() call, periodic\n         * or otherwise.\n         *\n         * fBufferTickled is a flag which, under normal (idle) circumstances, will constantly be set\n         * to true by periodic display operations that call setLEDState(); we clear it after every\n         * periodic drawBuffer(), so if the machine fails to execute a setBuffer() in a timely manner,\n         * we will see that fBufferTickled hasn't been \"tickled\", and automatically blank the display.\n         * \n         * fDisplayOn is a global \"on/off\" switch for the entire display.\n         */\n        this.fBufferModified = this.fBufferTickled = false;\n        this.msLastDraw = 0;\n        this.fDisplayOn = true;\n\n        /*\n         * nShiftedLeft is an optimization that tells drawGrid() when it can minimize the number of\n         * individual cells to redraw, by shifting the entire grid image leftward and redrawing only\n         * the rightmost cells.\n         */\n        this.nShiftedLeft = 0;\n\n        /*\n         * This records the location of the most recent LED buffer location updated via setLEDState(),\n         * in case we want to highlight it.\n         */\n        this.iBufferRecent = -1;\n\n        let led = this;\n        this.time = /** @type {Time} */ (this.findDeviceByClass(Machine.CLASS.TIME));\n        if (this.time) {\n            this.time.addAnimator(function ledAnimate(t) {\n                led.drawBuffer(false, t);\n            });\n        }\n    }\n\n    /**\n     * clearBuffer(fDraw)\n     *\n     * @this {LED}\n     * @param {boolean} [fDraw]\n     */\n    clearBuffer(fDraw)\n    {\n        this.initBuffer(this.buffer);\n        this.fBufferModified = this.fBufferTickled = true;\n        if (fDraw) this.drawBuffer(true);\n    }\n\n    /**\n     * clearGrid()\n     *\n     * @this {LED}\n     */\n    clearGrid()\n    {\n        if (this.colorBackground) {\n            this.contextGrid.fillStyle = this.colorBackground;\n            this.contextGrid.fillRect(0, 0, this.widthGrid, this.heightGrid);\n        } else {\n            this.contextGrid.clearRect(0, 0, this.widthGrid, this.heightGrid);\n        }\n    }\n\n    /**\n     * clearGridCell(col, row, xOffset)\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @param {number} xOffset\n     */\n    clearGridCell(col, row, xOffset)\n    {\n        let xDst = col * this.widthCell + xOffset;\n        let yDst = row * this.heightCell;\n        if (this.colorBackground) {\n            this.contextGrid.fillStyle = this.colorBackground;\n            this.contextGrid.fillRect(xDst, yDst, this.widthCell, this.heightCell);\n        } else {\n            this.contextGrid.clearRect(xDst, yDst, this.widthCell, this.heightCell);\n        }\n    }\n\n    /**\n     * drawBuffer(fForced, t)\n     *\n     * This is our periodic (60Hz) redraw function; however, it can also be called synchronously\n     * (eg, see clearBuffer()).  The other important periodic side-effect of this function is clearing\n     * fBufferTickled, so that if no other setLEDState() calls occur between now and the next drawBuffer(),\n     * an automatic clearBuffer() will be triggered.  This simulates the normal blanking of the display\n     * whenever the machine performs lengthy calculations, because for an LED display to remain lit,\n     * the machine must perform a display operation (\"refresh\") at least 30-60 times per second.\n     *\n     * @this {LED}\n     * @param {boolean} [fForced] (if not set, this is a normal refresh call)\n     * @param {number} [t] (time value, if available)\n     */\n    drawBuffer(fForced = false, t)\n    {\n        if (this.fBufferModified || fForced) {\n            if (this.type < LED.TYPE.DIGIT) {\n                this.drawGrid(fForced);\n            } else {\n                let s = \"\";\n                for (let i = 0; i < this.buffer.length; i += this.nBufferInc) {\n                    s += this.buffer[i] || ' ';\n                    if (this.buffer[i+3] & LED.FLAGS.PERIOD) s += '.';\n                }\n                this.drawString(s);\n            }\n            this.fBufferModified = false;\n            this.iBufferRecent = -1;\n        }\n        else if (!this.fPersistent && !this.fBufferTickled) {\n            if (!t || !this.msLastDraw || (t - this.msLastDraw) >= ((1000 / 60)|0)) {\n                this.clearBuffer(true);\n            }\n        }\n        this.fBufferTickled = false;\n        if (t) this.msLastDraw = t;\n    }\n\n    /**\n     * drawGrid(fForced)\n     *\n     * Used by drawBuffer() for LED.TYPE.ROUND, LED.TYPE.SQUARE, etc.\n     * \n     * If the buffer was recently shifted left (ie, nShiftedLeft is set), then we take advantage\n     * of that knowledge to use drawImage() to shift the entire grid image left, and then redrawing\n     * only the rightmost visible column.\n     *\n     * @this {LED}\n     * @param {boolean} [fForced] (if not set, this is a normal refresh call)\n     */\n    drawGrid(fForced)\n    {\n        let colRedraw = 0;\n        if (!this.fPersistent || fForced) {\n            this.clearGrid();\n        } else if (this.nShiftedLeft) {\n            colRedraw = this.colsView - this.nShiftedLeft;\n            let xStart = this.widthCell * this.nShiftedLeft;\n            let cxVisible = this.widthCell * colRedraw;\n            this.contextGrid.drawImage(this.canvasGrid, xStart, 0, cxVisible, this.heightGrid, 0, 0, cxVisible, this.heightGrid);\n            /*\n             * At this point, the only grid drawing we might need to do now is the column at colRedraw,\n             * but we still loop over the entire buffer to ensure all the cell MODIFIED states are in sync.\n             */\n        }\n        let i = 0;\n        for (let row = 0; row < this.rows; row++) {\n            for (let col = 0; col < this.colsView; col++) {\n                let state = this.buffer[i];\n                let color = this.buffer[i+1] || this.colorTransparent;\n                let fLeaveModified = false;\n                let fModified = !!(this.buffer[i+3] & LED.FLAGS.MODIFIED);\n                let fHighlight = (this.fHighlight && i == this.iBufferRecent);\n                if (!this.fDisplayOn && state) {\n                    state = LED.STATE.OFF;\n                    fModified = fLeaveModified = true;\n                }\n                if (fModified || fHighlight || fForced) {\n                    if (col >= colRedraw) {\n                        this.drawGridCell(state, color, col, row, fHighlight);\n                    }\n                    if (fHighlight || fLeaveModified) {\n                        this.buffer[i+3] |= LED.FLAGS.MODIFIED;\n                    } else {\n                        this.buffer[i+3] &= ~LED.FLAGS.MODIFIED;\n                    }\n                }\n                i += this.nBufferInc;\n            }\n            i += this.nBufferIncExtra;\n        }\n        this.nShiftedLeft = 0;\n        this.drawView();\n    }\n\n    /**\n     * drawGridCell(state, color, col, row, fHighlight)\n     *\n     * Used by drawGrid() for LED.TYPE.ROUND, LED.TYPE.SQUARE, etc.\n     *\n     * @this {LED}\n     * @param {string} state (eg, LED.STATE.ON or LED.STATE.OFF)\n     * @param {string} [color]\n     * @param {number} [col] (default is zero)\n     * @param {number} [row] (default is zero)\n     * @param {boolean} [fHighlight] (true if the cell should be highlighted; default is false)\n     */\n    drawGridCell(state, color, col = 0, row = 0, fHighlight = false)\n    {\n        let xOffset = 0;\n        if (this.fHexagonal) {\n            if (!(row & 0x1)) {\n                xOffset = (this.widthCell >> 1);\n                if (col == this.colsView - 1) return;\n            }\n        }\n\n        let colorOn, colorOff;\n        if (!color || color == this.colorOn) {\n            colorOn = fHighlight? this.colorHighlight : this.colorOn;\n            colorOff = this.colorOff;\n        } else {\n            colorOn = fHighlight? this.getRGBAColor(color, 1.0, 2.0) : color;\n            colorOff = this.getRGBAColor(color, 1.0, 0.25);\n        }\n\n        let fTransparent = false;\n        let colorCell = (state? colorOn : colorOff);\n        if (colorOn == this.colorTransparent) {\n            colorCell = this.colorBackground;\n            fTransparent = true;\n        }\n\n        let xDst = col * this.widthCell + xOffset;\n        let yDst = row * this.heightCell;\n\n        /*\n         * If this is NOT a persistent LED display, then drawGrid() will have done a preliminary clearGrid(),\n         * eliminating the need to clear individual cells.  Whereas if this IS a persistent LED display, then\n         * we need to clear cells on an as-drawn basis.  If we don't, there could be residual \"bleed over\"\n         * around the edges of the shape we drew here previously.\n         */\n        if (this.fPersistent) {\n            this.clearGridCell(col, row, xOffset);\n        }\n\n        this.contextGrid.fillStyle = colorCell;\n\n        let coords = LED.SHAPES[this.type];\n        if (coords.length == 3) {\n            this.contextGrid.beginPath();\n            this.contextGrid.arc(xDst + coords[0], yDst + coords[1], coords[2], 0, Math.PI * 2);\n            if (fTransparent) {\n                /*\n                 * The following code works as well:\n                 *\n                 *      this.contextGrid.save();\n                 *      this.contextGrid.clip();\n                 *      this.contextGrid.clearRect(xDst, yDst, this.widthCell, this.heightCell);\n                 *      this.contextGrid.restore();\n                 *\n                 * but I assume it's not as efficient.\n                 */\n                this.contextGrid.globalCompositeOperation = \"destination-out\";\n                this.contextGrid.fill();\n                this.contextGrid.globalCompositeOperation = \"source-over\";\n            } else {\n                this.contextGrid.fill();\n            }\n        } else {\n            this.contextGrid.fillRect(xDst + coords[0], yDst + coords[1], coords[2], coords[3]);\n        }\n    }\n\n    /**\n     * drawGridSegment(seg, col, row)\n     *\n     * Used by drawSymbol() for LED.TYPE.DIGIT.\n     *\n     * @this {LED}\n     * @param {string} seg (eg, \"A\")\n     * @param {number} [col] (default is zero)\n     * @param {number} [row] (default is zero)\n     */\n    drawGridSegment(seg, col = 0, row = 0)\n    {\n        let coords = LED.SEGMENTS[seg];\n        if (coords) {\n            let xDst = col * this.widthCell;\n            let yDst = row * this.heightCell;\n            this.contextGrid.fillStyle = this.colorOn;\n            this.contextGrid.beginPath();\n            if (coords.length == 3) {\n                this.contextGrid.arc(xDst + coords[0], yDst + coords[1], coords[2], 0, Math.PI * 2);\n            } else {\n                for (let i = 0; i < coords.length; i += 2) {\n                    if (!i) {\n                        this.contextGrid.moveTo(xDst + coords[i], yDst + coords[i+1]);\n                    } else {\n                        this.contextGrid.lineTo(xDst + coords[i], yDst + coords[i+1]);\n                    }\n                }\n            }\n            this.contextGrid.closePath();\n            this.contextGrid.fill();\n        }\n    }\n\n    /**\n     * drawString(s)\n     *\n     * Used by drawBuffer() for LED.TYPE.DIGIT.\n     *\n     * @this {LED}\n     * @param {string} s\n     */\n    drawString(s)\n    {\n        this.clearGrid();\n        for (let i = 0, col = 0, row = 0; i < s.length; i++) {\n            let ch = s[i];\n            if (ch == '.') {\n                if (col) col--;\n            }\n            this.drawSymbol(ch, col, row);\n            if (++col == this.colsView) {\n                col = 0;\n                if (++row == this.rows) {\n                    break;\n                }\n            }\n        }\n        this.drawView();\n    }\n\n    /**\n     * drawSymbol(symbol, col, row)\n     *\n     * Used by drawString() for LED.TYPE.DIGIT.\n     *\n     * If the symbol does not exist in LED.SYMBOL_SEGMENTS, then nothing is drawn.\n     *\n     * @this {LED}\n     * @param {string} symbol\n     * @param {number} [col] (default is zero)\n     * @param {number} [row] (default is zero)\n     */\n    drawSymbol(symbol, col = 0, row = 0)\n    {\n        let segments = LED.SYMBOL_SEGMENTS[symbol];\n        if (segments) {\n            for (let i = 0; i < segments.length; i++) {\n                this.drawGridSegment(segments[i], col, row)\n            }\n        }\n    }\n\n    /**\n     * drawView()\n     *\n     * @this {LED}\n     */\n    drawView()\n    {\n        /*\n         * Setting the 'globalCompositeOperation' property of a 2D context is something you rarely need to do,\n         * because the default draw behavior (\"source-over\") is fine for most cases.  One case where it is NOT\n         * fine is when we're using a transparent background color, because it doesn't copy over any transparent\n         * pixels, effectively making it impossible to \"turn off\" any previously drawn LED segments.  To force\n         * that behavior, we must select the \"copy\" behavior.\n         *\n         * Refer to: https://www.w3.org/TR/2dcontext/#dom-context-2d-globalcompositeoperation\n         */\n        this.contextView.globalCompositeOperation = (this.colorBackground && this.colorOn != this.colorTransparent)? \"source-over\" : \"copy\";\n        this.contextView.drawImage(this.canvasGrid, 0, 0, this.widthGrid, this.heightGrid, 0, 0, this.widthView, this.heightView);\n    }\n\n    /**\n     * enableDisplay(on)\n     * \n     * @this {LED}\n     * @param {boolean} [on]\n     */\n    enableDisplay(on = true)\n    {\n        if (this.fDisplayOn != on) {\n            this.fDisplayOn = on;\n            this.fBufferModified = true;\n        }\n    }\n    \n    /**\n     * getBuffer()\n     *\n     * @this {LED}\n     * @returns {Array}\n     */\n    getBuffer()\n    {\n        return this.buffer;\n    }\n\n    /**\n     * getBufferClone()\n     *\n     * @this {LED}\n     * @returns {Array}\n     */\n    getBufferClone()\n    {\n        if (!this.bufferClone) {\n            this.bufferClone = new Array(this.nBufferCells);\n            this.initBuffer(this.bufferClone);\n        }\n        return this.bufferClone;\n    }\n\n    /**\n     * getLEDColor(col, row)\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @returns {string}\n     */\n    getLEDColor(col, row)\n    {\n        let i = (row * this.cols + col) * this.nBufferInc;\n        return this.buffer[i+1] || this.colorTransparent;\n    }\n\n    /**\n     * getLEDColorValues(col, row, rgb)\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @param {Array.<number>} rgb\n     * @returns {boolean}\n     */\n    getLEDColorValues(col, row, rgb)\n    {\n        let i = (row * this.cols + col) * this.nBufferInc;\n        return this.parseRGBValues(this.buffer[i+1] || this.colorTransparent, rgb);\n    }\n\n    /**\n     * getLEDCounts(col, row, counts)\n     *\n     * This function returns success (true) ONLY for cells that are not transparent.\n     *\n     * For a typical \"Lite-Brite\" grid, transparent cells are considered \"empty\", so we want to\n     * ignore them.\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @param {Array.<number>} counts\n     * @returns {boolean}\n     */\n    getLEDCounts(col, row, counts)\n    {\n        let fSuccess = false;\n        let i = (row * this.cols + col) * this.nBufferInc;\n        if (i <= this.buffer.length - this.nBufferInc && this.buffer[i+1]) {\n            fSuccess = true;\n            let bits = this.buffer[i+2];\n            for (let c = counts.length - 1; c >= 0; c--) {\n                counts[c] = bits & 0xf;\n                bits >>>= 4;\n            }\n        }\n        return fSuccess;\n    }\n\n    /**\n     * getLEDCountsPacked(col, row)\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @returns {number}\n     */\n    getLEDCountsPacked(col, row)\n    {\n        let i = (row * this.cols + col) * this.nBufferInc;\n        return (i <= this.buffer.length - this.nBufferInc)? this.buffer[i+2] : 0;\n    }\n\n    /**\n     * getLEDState(col, row)\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @returns {number|undefined}\n     */\n    getLEDState(col, row)\n    {\n        let state;\n        let i = (row * this.cols + col) * this.nBufferInc;\n        if (i <= this.buffer.length - this.nBufferInc) {\n            state = this.buffer[i];\n        }\n        return state;\n    }\n\n    /**\n     * getDefaultColor()\n     *\n     * @this {LED}\n     * @returns {string}\n     */\n    getDefaultColor()\n    {\n        return this.colorOn;\n    }\n\n    /**\n     * getRGBColor(color, colorDefault)\n     *\n     * Returns a color string in the \"hex\" format that fillStyle recognizes (eg, \"#rrggbb\").\n     *\n     * The default is optional, allowing an undefined color to remain undefined if we want to use\n     * that to signal transparency (as in the case of colorBackground).\n     *\n     * @this {LED}\n     * @param {string|undefined} color\n     * @param {string} [colorDefault]\n     * @returns {string|undefined}\n     */\n    getRGBColor(color, colorDefault)\n    {\n        color = color || colorDefault;\n        return color && LED.COLORS[color] || color;\n    }\n\n    /**\n     * getRGBColorString(rgb)\n     *\n     * Returns a color string fillStyle recognizes (ie, \"#rrggbb\", or \"rgba(r,g,b,a)\" if an alpha value\n     * less than 1 is set).\n     *\n     * TODO: Cache frequently requested colors.\n     * \n     * @this {LED}\n     * @param {Array.<number>} rgb\n     * @returns {string}\n     */\n    getRGBColorString(rgb)\n    {\n        let s;\n        if (rgb.length < 4 || rgb[3] == 1) {\n            s = this.sprintf(\"#%02x%02x%02x\", rgb[0], rgb[1], rgb[2]);\n        } else {\n            s = this.sprintf(\"rgba(%d,%d,%d,%d)\", rgb[0], rgb[1], rgb[2], rgb[3]);\n        }\n        return s;\n    }\n\n    /**\n     * getRGBAColor(color, alpha, brightness)\n     *\n     * Returns a color string in the \"rgba\" format that fillStyle recognizes (eg, \"rgba(255, 255, 255, 0)\").\n     *\n     * I used to use \"alpha\" to adjust the brightness, but it's safer to use the \"brightness\" parameter,\n     * which simply scales all the RGB values.  That's because if any shapes are redrawn using a fillStyle\n     * with alpha < 1.0, the target alpha values will be added instead of replaced, resulting in progressively\n     * brighter shapes; probably not what you want.\n     *\n     * @this {LED}\n     * @param {string} color\n     * @param {number} [alpha]\n     * @param {number} [brightness]\n     * @returns {string}\n     */\n    getRGBAColor(color, alpha = 1.0, brightness = 1.0)\n    {\n        if (color) {\n            let rgb = [];\n            color = LED.COLORS[color] || color;\n            if (this.parseRGBValues(color, rgb)) {\n                color = \"rgba(\";\n                let i;\n                for (i = 0; i < 3; i++) {\n                    let n = Math.round(rgb[i] * brightness);\n                    n = (n < 0? 0 : (n > 255? 255 : n));\n                    color += n + \",\";\n                }\n                color += (i < rgb.length? rgb[i] : alpha) + \")\";\n            }\n        }\n        return color;\n    }\n\n    /**\n     * initBuffer(buffer)\n     *\n     * @this {LED}\n     * @param {Array.<number|string|null>} buffer\n     */\n    initBuffer(buffer)\n    {\n        for (let i = 0; i < buffer.length; i += this.nBufferInc) {\n            this.initCell(buffer, i);\n        }\n    }\n\n    /**\n     * initCell(buffer, iCell)\n     *\n     * @this {LED}\n     * @param {Array.<number|string|null>} buffer\n     * @param {number} iCell\n     */\n    initCell(buffer, iCell)\n    {\n        if (this.type < LED.TYPE.DIGIT) {\n            buffer[iCell] = LED.STATE.OFF;\n        } else {\n            buffer[iCell] = ' ';\n        }\n        buffer[iCell+1] = (this.colorOn == this.colorTransparent? null : this.colorOn);\n        buffer[iCell+2] = 0;\n        buffer[iCell+3] = LED.FLAGS.MODIFIED;\n    }\n\n    /**\n     * loadState(state)\n     *\n     * If any saved values don't match (possibly overridden), abandon the given state and return false.\n     *\n     * @this {LED}\n     * @param {Array} state\n     * @returns {boolean}\n     */\n    loadState(state)\n    {\n        let colorOn = state.shift();\n        let colorBackground = state.shift();\n        let buffer = state.shift();\n        if (colorOn == this.colorOn && colorBackground == this.colorBackground && buffer && buffer.length == this.buffer.length) {\n            this.buffer = buffer;\n            /*\n             * Loop over all the buffer colors to fix a legacy problem (ie, before we started storing null for colorTransparent)\n             */\n            for (let i = 0; i <= this.buffer.length - this.nBufferInc; i += this.nBufferInc) {\n                if (this.buffer[i+1] == this.colorTransparent) this.buffer[i+1] = null;\n            }\n            this.drawBuffer(true);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * parseRGBValues(color, rgb)\n     *\n     * @this {LED}\n     * @param {string} color\n     * @param {Array.<number>} rgb\n     * @returns {boolean}\n     */\n    parseRGBValues(color, rgb)\n    {\n        let base = 16;\n        let match = color.match(/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i);\n        if (!match) {\n            base = 10;\n            match = color.match(/^rgba?\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,?\\s*(\\d+|)\\)$/i);\n        }\n        if (match) {\n            let i;\n            for (i = 1; i < match.length; i++) {\n                rgb[i-1] = Number.parseInt(match[i], base);\n            }\n            rgb.length = i-1;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * saveState(state)\n     *\n     * @this {LED}\n     * @param {Array} state\n     */\n    saveState(state)\n    {\n        if (this.buffer) {\n            state.push(this.colorOn);\n            state.push(this.colorBackground);\n            state.push(this.buffer);\n        }\n    }\n\n    /**\n     * setContainerStyle(sAttr, sValue)\n     * \n     * @this {LED}\n     * @param {string} sAttr \n     * @param {string} sValue \n     */\n    setContainerStyle(sAttr, sValue)\n    {\n        if (this.container) this.container.style[sAttr] = sValue;\n    }\n\n    /**\n     * setLEDColor(col, row, color)\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @param {string} [color]\n     * @returns {boolean|null} (true if this call modified the LED color, false if not, null if error)\n     */\n    setLEDColor(col, row, color)\n    {\n        let fModified = null;\n        if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {\n            fModified = false;\n            let colorNew = color || this.colorOn;\n            if (colorNew == this.colorTransparent) colorNew = null;\n            let i = (row * this.cols + col) * this.nBufferInc;\n            if (this.buffer[i+1] !== colorNew) {\n                this.buffer[i+1] = colorNew;\n                if (!colorNew) this.buffer[i] = LED.STATE.OFF;  // transparent LEDs are automatically turned off\n                this.buffer[i+3] |= LED.FLAGS.MODIFIED;\n                this.fBufferModified = fModified = true;\n            }\n            this.iBufferRecent = i;\n            this.fBufferTickled = true;\n        }\n        return fModified;\n    }\n\n    /**\n     * setLEDCounts(col, row, counts)\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @param {Array.<number>} counts\n     * @returns {boolean|null} (true if this call modified the LED color, false if not, null if error)\n     */\n    setLEDCounts(col, row, counts)\n    {\n        let fModified = null;\n        if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {\n            fModified = false;\n            let i = (row * this.cols + col) * this.nBufferInc;\n            let bits = 0;\n            if (this.buffer[i+1]) {                             // only non-transparent LEDs are allowed to set counters\n                for (let c = 0; c < counts.length; c++) {\n                    bits = (bits << 4) | (counts[c] & 0xf);\n                }\n            }\n            if (this.buffer[i+2] !== bits) {\n                this.buffer[i+2] = bits;\n                this.buffer[i+3] |= LED.FLAGS.MODIFIED;\n                this.fBufferModified = fModified = true;\n            }\n            this.iBufferRecent = i;\n            this.fBufferTickled = true;\n        }\n        return fModified;\n    }\n\n    /**\n     * setLEDCountsPacked(col, row, counts)\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @param {number} counts\n     * @returns {boolean|null} (true if this call modified the LED state, false if not, null if error)\n     */\n    setLEDCountsPacked(col, row, counts)\n    {\n        let i = (row * this.cols + col) * this.nBufferInc;\n        if (i <= this.buffer.length - this.nBufferInc) {\n            if (this.buffer[i+2] != counts) {\n                this.buffer[i+2] = counts;\n                return true;\n            }\n            return false;\n        }\n        return null;\n    }\n\n    /**\n     * setLEDState(col, row, state, flags)\n     *\n     * For LED.TYPE.ROUND or LED.TYPE.SQUARE, the state parameter should be LED.STATE.OFF or LED.STATE.ON.\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @param {string|number} state (new state for the specified cell)\n     * @param {number} [flags]\n     * @returns {boolean} (true if this call modified the LED state, false if not)\n     */\n    setLEDState(col, row, state, flags = 0)\n    {\n        let fModified = false;\n        let flagsSet = flags & LED.FLAGS.SET;\n        let i = (row * this.cols + col) * this.nBufferInc;\n        if (i <= this.buffer.length - this.nBufferInc) {\n            if (this.buffer[i] !== state || (this.buffer[i+3] & LED.FLAGS.SET) !== flagsSet) {\n                this.buffer[i] = state;\n                this.buffer[i+3] = (this.buffer[i+3] & ~LED.FLAGS.SET) | flagsSet | LED.FLAGS.MODIFIED;\n                this.fBufferModified = fModified = true;\n            }\n            this.iBufferRecent = i;\n            this.fBufferTickled = true;\n            this.nShiftedLeft = 0;\n        }\n        return fModified;\n    }\n\n    /**\n     * swapBuffers()\n     *\n     * @this {LED}\n     */\n    swapBuffers()\n    {\n        let buffer = this.buffer;\n        this.buffer = this.bufferClone;\n        this.bufferClone = buffer;\n        this.fBufferModified = true;\n    }\n}\n\nLED.TYPE = {\n    SMALL:      0,      // a smaller, more efficient (round) LED for large grids\n    ROUND:      1,      // a single (round) LED\n    SQUARE:     2,      // a single (square) LED\n    DIGIT:      3       // a 7-segment (digit) LED, with optional period as an 8th segment\n};\n\nLED.BINDING = {\n    CONTAINER:  \"container\"\n};\n\nLED.COLORS = {\n    \"aliceblue\":            \"#f0f8ff\",\n    \"antiquewhite\":         \"#faebd7\",\n    \"aqua\":                 \"#00ffff\",\n    \"aquamarine\":           \"#7fffd4\",\n    \"azure\":                \"#f0ffff\",\n    \"beige\":                \"#f5f5dc\",\n    \"bisque\":               \"#ffe4c4\",\n    \"black\":                \"#000000\",\n    \"blanchedalmond\":       \"#ffebcd\",\n    \"blue\":                 \"#0000ff\",\n    \"blueviolet\":           \"#8a2be2\",\n    \"brown\":                \"#a52a2a\",\n    \"burlywood\":            \"#deb887\",\n    \"cadetblue\":            \"#5f9ea0\",\n    \"chartreuse\":           \"#7fff00\",\n    \"chocolate\":            \"#d2691e\",\n    \"coral\":                \"#ff7f50\",\n    \"cornflowerblue\":       \"#6495ed\",\n    \"cornsilk\":             \"#fff8dc\",\n    \"crimson\":              \"#dc143c\",\n    \"cyan\":                 \"#00ffff\",\n    \"darkblue\":             \"#00008b\",\n    \"darkcyan\":             \"#008b8b\",\n    \"darkgoldenrod\":        \"#b8860b\",\n    \"darkgray\":             \"#a9a9a9\",\n    \"darkgreen\":            \"#006400\",\n    \"darkkhaki\":            \"#bdb76b\",\n    \"darkmagenta\":          \"#8b008b\",\n    \"darkolivegreen\":       \"#556b2f\",\n    \"darkorange\":           \"#ff8c00\",\n    \"darkorchid\":           \"#9932cc\",\n    \"darkred\":              \"#8b0000\",\n    \"darksalmon\":           \"#e9967a\",\n    \"darkseagreen\":         \"#8fbc8f\",\n    \"darkslateblue\":        \"#483d8b\",\n    \"darkslategray\":        \"#2f4f4f\",\n    \"darkturquoise\":        \"#00ced1\",\n    \"darkviolet\":           \"#9400d3\",\n    \"deeppink\":             \"#ff1493\",\n    \"deepskyblue\":          \"#00bfff\",\n    \"dimgray\":              \"#696969\",\n    \"dodgerblue\":           \"#1e90ff\",\n    \"firebrick\":            \"#b22222\",\n    \"floralwhite\":          \"#fffaf0\",\n    \"forestgreen\":          \"#228b22\",\n    \"fuchsia\":              \"#ff00ff\",\n    \"gainsboro\":            \"#dcdcdc\",\n    \"ghostwhite\":           \"#f8f8ff\",\n    \"gold\":                 \"#ffd700\",\n    \"goldenrod\":            \"#daa520\",\n    \"gray\":                 \"#808080\",\n    \"green\":                \"#008000\",\n    \"greenyellow\":          \"#adff2f\",\n    \"honeydew\":             \"#f0fff0\",\n    \"hotpink\":              \"#ff69b4\",\n    \"indianred \":           \"#cd5c5c\",\n    \"indigo\":               \"#4b0082\",\n    \"ivory\":                \"#fffff0\",\n    \"khaki\":                \"#f0e68c\",\n    \"lavender\":             \"#e6e6fa\",\n    \"lavenderblush\":        \"#fff0f5\",\n    \"lawngreen\":            \"#7cfc00\",\n    \"lemonchiffon\":         \"#fffacd\",\n    \"lightblue\":            \"#add8e6\",\n    \"lightcoral\":           \"#f08080\",\n    \"lightcyan\":            \"#e0ffff\",\n    \"lightgoldenrodyellow\": \"#fafad2\",\n    \"lightgrey\":            \"#d3d3d3\",\n    \"lightgreen\":           \"#90ee90\",\n    \"lightpink\":            \"#ffb6c1\",\n    \"lightsalmon\":          \"#ffa07a\",\n    \"lightseagreen\":        \"#20b2aa\",\n    \"lightskyblue\":         \"#87cefa\",\n    \"lightslategray\":       \"#778899\",\n    \"lightsteelblue\":       \"#b0c4de\",\n    \"lightyellow\":          \"#ffffe0\",\n    \"lime\":                 \"#00ff00\",\n    \"limegreen\":            \"#32cd32\",\n    \"linen\":                \"#faf0e6\",\n    \"magenta\":              \"#ff00ff\",\n    \"maroon\":               \"#800000\",\n    \"mediumaquamarine\":     \"#66cdaa\",\n    \"mediumblue\":           \"#0000cd\",\n    \"mediumorchid\":         \"#ba55d3\",\n    \"mediumpurple\":         \"#9370d8\",\n    \"mediumseagreen\":       \"#3cb371\",\n    \"mediumslateblue\":      \"#7b68ee\",\n    \"mediumspringgreen\":    \"#00fa9a\",\n    \"mediumturquoise\":      \"#48d1cc\",\n    \"mediumvioletred\":      \"#c71585\",\n    \"midnightblue\":         \"#191970\",\n    \"mintcream\":            \"#f5fffa\",\n    \"mistyrose\":            \"#ffe4e1\",\n    \"moccasin\":             \"#ffe4b5\",\n    \"navajowhite\":          \"#ffdead\",\n    \"navy\":                 \"#000080\",\n    \"oldlace\":              \"#fdf5e6\",\n    \"olive\":                \"#808000\",\n    \"olivedrab\":            \"#6b8e23\",\n    \"orange\":               \"#ffa500\",\n    \"orangered\":            \"#ff4500\",\n    \"orchid\":               \"#da70d6\",\n    \"palegoldenrod\":        \"#eee8aa\",\n    \"palegreen\":            \"#98fb98\",\n    \"paleturquoise\":        \"#afeeee\",\n    \"palevioletred\":        \"#d87093\",\n    \"papayawhip\":           \"#ffefd5\",\n    \"peachpuff\":            \"#ffdab9\",\n    \"peru\":                 \"#cd853f\",\n    \"pink\":                 \"#ffc0cb\",\n    \"plum\":                 \"#dda0dd\",\n    \"powderblue\":           \"#b0e0e6\",\n    \"purple\":               \"#800080\",\n    \"rebeccapurple\":        \"#663399\",\n    \"red\":                  \"#ff0000\",\n    \"rosybrown\":            \"#bc8f8f\",\n    \"royalblue\":            \"#4169e1\",\n    \"saddlebrown\":          \"#8b4513\",\n    \"salmon\":               \"#fa8072\",\n    \"sandybrown\":           \"#f4a460\",\n    \"seagreen\":             \"#2e8b57\",\n    \"seashell\":             \"#fff5ee\",\n    \"sienna\":               \"#a0522d\",\n    \"silver\":               \"#c0c0c0\",\n    \"skyblue\":              \"#87ceeb\",\n    \"slateblue\":            \"#6a5acd\",\n    \"slategray\":            \"#708090\",\n    \"snow\":                 \"#fffafa\",\n    \"springgreen\":          \"#00ff7f\",\n    \"steelblue\":            \"#4682b4\",\n    \"tan\":                  \"#d2b48c\",\n    \"teal\":                 \"#008080\",\n    \"thistle\":              \"#d8bfd8\",\n    \"tomato\":               \"#ff6347\",\n    \"turquoise\":            \"#40e0d0\",\n    \"violet\":               \"#ee82ee\",\n    \"wheat\":                \"#f5deb3\",\n    \"white\":                \"#ffffff\",\n    \"whitesmoke\":           \"#f5f5f5\",\n    \"yellow\":               \"#ffff00\",\n    \"yellowgreen\":          \"#9acd32\"\n};\n\nLED.STATE = {\n    OFF:        0,\n    ON:         1\n};\n\n/*\n * NOTE: Although technically the MODIFIED flag is an internal flag, it may be set explicitly as well;\n * the ROM device uses the setLEDState() flags parameter to set it, in order to trigger highlighting of\n * the most recently active LED.\n */\nLED.FLAGS = {\n    NONE:       0x00,\n    SET:        0x81,   // bits that may be set using the flags parameter of setLEDState()\n    PERIOD:     0x01,   // used with DIGIT-type LED to indicate that the period \"segment\" should be on, too\n    MODIFIED:   0x80,   // cell has been modified since the last time it was drawn\n};\n\nLED.SHAPES = {\n    [LED.TYPE.SMALL]:   [4, 4, 4],\n    [LED.TYPE.ROUND]:   [16, 16, 14],\n    [LED.TYPE.SQUARE]:  [2, 2, 28, 28]\n};\n\nLED.SIZES = [\n    [8,   8],           // LED.TYPE.SMALL\n    [32,  32],          // LED.TYPE.ROUND\n    [32,  32],          // LED.TYPE.SQUARE\n    [96, 128]           // LED.TYPE.DIGIT\n];\n\n/*\n * The segments are arranged roughly as follows, in a 96x128 grid:\n *\n *      AAAA\n *     F    B\n *     F    B\n *      GGGG\n *     E    C\n *     E    C\n *      DDDD P\n *\n * The following arrays specify pairs of moveTo()/lineTo() coordinates, used by drawGridSegment().  They all\n * assume the hard-coded width and height in LED.SIZES[LED.TYPE.DIGIT] specified above.  If there is a triplet\n * instead of one or more pairs (eg, the 'P' or period segment), then the coordinates are treated as arc()\n * parameters.\n */\nLED.SEGMENTS = {\n    'A':        [30,   8,  79,   8,  67,  19,  37,  19],\n    'B':        [83,  10,  77,  52,  67,  46,  70,  22],\n    'C':        [77,  59,  71, 100,  61,  89,  64,  64],\n    'D':        [28,  91,  58,  91,  69, 104,  15, 104],\n    'E':        [18,  59,  28,  64,  25,  88,  12, 100],\n    'F':        [24,  10,  34,  21,  31,  47,  18,  52],\n    'G':        [24,  56,  34,  50,  60,  50,  71,  56,  61,  61,  33,  61],\n    'P':        [80, 102,  8]\n};\n\n/*\n * Segmented symbols are formed with the following segments.\n */\nLED.SYMBOL_SEGMENTS = {\n    ' ':        [],\n    '0':        ['A','B','C','D','E','F'],\n    '1':        ['B','C'],\n    '2':        ['A','B','D','E','G'],\n    '3':        ['A','B','C','D','G'],\n    '4':        ['B','C','F','G'],\n    '5':        ['A','C','D','F','G'],\n    '6':        ['A','C','D','E','F','G'],\n    '7':        ['A','B','C'],\n    '8':        ['A','B','C','D','E','F','G'],\n    '9':        ['A','B','C','D','F','G'],\n    '-':        ['G'],\n    'E':        ['A','D','E','F','G'],\n    '.':        ['P']\n};\n\nLED.VERSION = +VERSION || 1.20;\n\n/**\n * @copyright https://www.pcjs.org/modules/devices/rom.js (C) Jeff Parsons 2012-2018\n */\n\n/** @typedef {{ class: string, bindings: (Object|undefined), version: (number|undefined), overrides: (Array.<string>|undefined), wordSize: number, valueSize: number, valueTotal: number, littleEndian: boolean, file: string, reference: string, chipID: string, revision: (number|undefined), colorROM: (string|undefined), backgroundColorROM: (string|undefined), values: Array.<number> }} */\nvar ROMConfig;\n\n/**\n * @class {ROM}\n * @unrestricted\n * @property {ROMConfig} config\n * @property {Array.<number>} data\n * @property {number} addrMask\n */\nclass ROM extends Device {\n    /**\n     * ROM(idMachine, idDevice, config)\n     *\n     * Sample config:\n     *\n     *      \"rom\": {\n     *        \"class\": \"ROM\",\n     *        \"wordSize\": 13,\n     *        \"valueSize\": 16,\n     *        \"valueTotal\": 2048,\n     *        \"littleEndian\": true,\n     *        \"file\": \"ti57le.bin\",\n     *        \"reference\": \"\",\n     *        \"chipID\": \"TMC1501NC DI 7741\",\n     *        \"revision\": \"0\",\n     *        \"bindings\": {\n     *          \"array\": \"romArrayTI57\",\n     *          \"cellDesc\": \"romCellTI57\"\n     *        },\n     *        \"overrides\": [\"colorROM\",\"backgroundColorROM\"],\n     *        \"values\": [\n     *          ...\n     *        ]\n     *      }\n     *\n     * @this {ROM}\n     * @param {string} idMachine\n     * @param {string} idDevice\n     * @param {ROMConfig} [config]\n     */\n    constructor(idMachine, idDevice, config)\n    {\n        super(idMachine, idDevice, ROM.VERSION, config);\n\n        this.data = config['values'];\n\n        /*\n         * This addrMask calculation assumes that the data array length is a power-of-two (which we assert).\n         */\n        this.addrMask = this.data.length - 1;\n\n\n        /*\n         * If an \"array\" binding has been supplied, then create an LED array sufficiently large to represent the\n         * entire ROM.  If the power-of-two is odd, then we will favor a slightly wider array over a taller one,\n         * by virtue of using Math.ceil() for cols and Math.floor() for rows.\n         */\n        if (this.bindings[ROM.BINDING.ARRAY]) {\n            let rom = this;\n            let addrLines = Math.log2(this.data.length) / 2;\n            this.cols = Math.pow(2, Math.ceil(addrLines));\n            this.rows = Math.pow(2, Math.floor(addrLines));\n            let configLEDs = {\n                \"class\":            \"LED\",\n                \"bindings\":         {\"container\": this.getBindingID(ROM.BINDING.ARRAY)},\n                \"type\":             LED.TYPE.ROUND,\n                \"cols\":             this.cols,\n                \"rows\":             this.rows,\n                \"color\":            this.getDefaultString('colorROM', \"green\"),\n                \"backgroundColor\":  this.getDefaultString('backgroundColorROM', \"black\"),\n                \"persistent\":       true\n            };\n            this.ledArray = new LED(idMachine, idDevice + \"LEDs\", configLEDs);\n            this.clearArray();\n            let configInput = {\n                \"class\":        \"Input\",\n                \"location\":     [0, 0, this.ledArray.widthView, this.ledArray.heightView, this.cols, this.rows],\n                \"bindings\":     {\"surface\": this.getBindingID(ROM.BINDING.ARRAY)}\n            };\n            this.ledInput = new Input(idMachine, idDevice + \"Input\", configInput);\n            this.sCellDesc = this.getBindingText(ROM.BINDING.CELLDESC);\n            this.ledInput.addHover(function onROMHover(col, row) {\n                if (rom.chip) {\n                    let sDesc = rom.sCellDesc;\n                    if (col >= 0 && row >= 0) {\n                        let addr = row * rom.cols + col;\n\n                        let opCode = rom.data[addr];\n                        sDesc = rom.chip.disassemble(opCode, addr);\n                    }\n                    rom.setBindingText(ROM.BINDING.CELLDESC, sDesc);\n                }\n            });\n        }\n    }\n\n    /**\n     * clearArray()\n     *\n     * clearBuffer(true) performs a combination of clearBuffer() and drawBuffer().\n     *\n     * @this {ROM}\n     */\n    clearArray()\n    {\n        if (this.ledArray) this.ledArray.clearBuffer(true);\n    }\n\n    /**\n     * drawArray()\n     *\n     * This performs a simple drawBuffer(); intended for synchronous updates (eg, step operations);\n     * otherwise, you should allow the LED object's async animation handler take care of drawing updates.\n     *\n     * @this {ROM}\n     */\n    drawArray()\n    {\n        if (this.ledArray) this.ledArray.drawBuffer();\n    }\n\n    /**\n     * getData(addr, fInternal)\n     *\n     * Set fInternal to true if an internal caller (eg, the disassembler) is accessing the ROM, to avoid touching\n     * the ledArray.\n     *\n     * @this {ROM}\n     * @param {number} addr\n     * @param {boolean} [fInternal]\n     * @returns {number|undefined}\n     */\n    getData(addr, fInternal)\n    {\n        if (this.ledArray && !fInternal) {\n            this.ledArray.setLEDState(addr % this.cols, (addr / this.cols)|0, LED.STATE.ON, LED.FLAGS.MODIFIED);\n        }\n        return this.data[addr];\n    }\n\n    /**\n     * loadState(state)\n     *\n     * If any saved values don't match (presumably overridden), abandon the given state and return false.\n     * \n     * @this {ROM}\n     * @param {Array} state\n     * @returns {boolean}\n     */\n    loadState(state)\n    {\n        let buffer = state.shift();\n        if (buffer && this.ledArray) {\n\n            if (this.ledArray.buffer.length == buffer.length) {\n                this.ledArray.buffer = buffer;\n                this.ledArray.drawBuffer(true);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * saveState(state)\n     *\n     * @this {ROM}\n     * @param {Array} state\n     */\n    saveState(state)\n    {\n        if (this.ledArray) {\n            state.push(this.ledArray.buffer);\n        }\n    }\n\n    /**\n     * setChip()\n     *\n     * @this {ROM}\n     * @param {Chip} chip\n     */\n    setChip(chip)\n    {\n        this.chip = chip;\n    }\n}\n\nROM.BINDING = {\n    ARRAY:      \"array\",\n    CELLDESC:   \"cellDesc\"\n};\n\nROM.VERSION = +VERSION || 1.20;\n\n/**\n * @copyright https://www.pcjs.org/modules/devices/time.js (C) Jeff Parsons 2012-2018\n */\n\n/** @typedef {{ id: string, callBack: function(), msAuto: number, nCyclesLeft: number }} */\nvar Timer;\n\n/** @typedef {{ class: string, bindings: (Object|undefined), version: (number|undefined), overrides: (Array.<string>|undefined), cyclesMinimum: (number|undefined), cyclesMaximum: (number|undefined), cyclesPerSecond: (number|undefined), yieldsPerSecond: (number|undefined), yieldsPerUpdate: (number|undefined), requestAnimationFrame: (boolean|undefined), clockByFrame: (boolean|undefined) }} */\nvar TimeConfig;\n\n/**\n * @class {Time}\n * @unrestricted\n * @property {TimeConfig} config\n * @property {number} nCyclesMinimum\n * @property {number} nCyclesMaximum\n * @property {number} nCyclesPerSecond\n * @property {number} nYieldsPerSecond\n * @property {number} nYieldsPerUpdate\n * @property {boolean} fClockByFrame\n */\nclass Time extends Device {\n    /**\n     * Time(idMachine, idDevice, config)\n     *\n     * Sample config:\n     *\n     *      \"clock\": {\n     *        \"class\": \"Time\",\n     *        \"cyclesPerSecond\": 650000,\n     *        \"clockByFrame\": true,\n     *        \"bindings\": {\n     *          \"run\": \"runTI57\",\n     *          \"speed\": \"speedTI57\",\n     *          \"step\": \"stepTI57\"\n     *        },\n     *        \"overrides\": [\"cyclesPerSecond\",\"yieldsPerSecond\",\"yieldsPerUpdate\"]\n     *      }\n     *\n     * @this {Time}\n     * @param {string} idMachine\n     * @param {string} idDevice\n     * @param {TimeConfig} [config]\n     */\n    constructor(idMachine, idDevice, config)\n    {\n        super(idMachine, idDevice, Time.VERSION, config);\n\n        /*\n         * NOTE: The default speed of 650,000Hz (0.65Mhz) was a crude approximation based on real world TI-57\n         * device timings.  I had originally assumed the speed as 1,600,000Hz (1.6Mhz), based on timing information\n         * in TI's patents, but in hindsight, that speed seems rather high for a mid-1970's device, and reality\n         * suggests it was much lower.  The TMS-1500 does burn through a lot of cycles (minimum of 128) per instruction,\n         * but either that cycle burn was much higher, or the underlying clock speed was much lower.  I assume the latter.\n         */\n        this.nCyclesMinimum = this.getDefaultNumber('cyclesMinimum', 100000);\n        this.nCyclesMaximum = this.getDefaultNumber('cyclesMaximum', 3000000);\n        this.nCyclesPerSecond = this.getBounded(this.getDefaultNumber('cyclesPerSecond', 650000), this.nCyclesMinimum, this.nCyclesMaximum);\n        this.nYieldsPerSecond = this.getBounded(this.getDefaultNumber('yieldsPerSecond', Time.YIELDS_PER_SECOND), 30, 120);\n        this.nYieldsPerUpdate = this.getBounded(this.getDefaultNumber('yieldsPerUpdate', Time.YIELDS_PER_UPDATE), 1, this.nYieldsPerSecond);\n        this.fClockByFrame = this.getDefaultBoolean('clockByFrame', this.nCyclesPerSecond <= 120);\n        this.fRequestAnimationFrame = this.fClockByFrame || this.getDefaultBoolean('requestAnimationFrame', true);\n\n        this.nBaseMultiplier = this.nCurrentMultiplier = this.nTargetMultiplier = 1;\n        this.mhzBase = (this.nCyclesPerSecond / 10000) / 100;\n        this.mhzCurrent = this.mhzTarget = this.mhzBase * this.nTargetMultiplier;\n        this.nYields = 0;\n        this.msYield = Math.round(1000 / this.nYieldsPerSecond);\n        this.aAnimators = [];\n        this.aClockers = [];\n        this.aTimers = [];\n        this.aUpdaters = [];\n        this.fRunning = this.fYield = this.fThrottling = false;\n        this.nStepping = 0;\n        this.idRunTimeout = this.idStepTimeout = 0;\n        this.onRunTimeout = this.run.bind(this);\n        this.onAnimationFrame = this.animate.bind(this);\n        this.requestAnimationFrame = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.setTimeout).bind(window);\n\n        /*\n         * When fClockByFrame is true, we rely exclusively on requestAnimationFrame() instead of setTimeout()\n         * to drive the clock, which means we automatically yield after every frame, so no yield timer is required.\n         */\n        if (!this.fClockByFrame) {\n            let time = this;\n            this.timerYield = this.addTimer(\"timerYield\", function onYield() {\n                time.onYield();\n            }, this.msYield);\n        }\n        else {\n            /*\n             * When clocking exclusively by animation frames, setSpeed() calculates how many cycles\n             * each animation frame should \"deposit\" in our cycle bank:\n             * \n             *      this.nCyclesDepositPerFrame = (nCyclesPerSecond / 60) + 0.00000001;\n             *\n             * After that amount is added to our \"balance\" (this.nCyclesDeposited), we make a \"withdrawal\"\n             * whenever the balance is >= 1.0 and call all our clocking functions with the maximum number\n             * of cycles we were able to withdraw.\n             *\n             * setSpeed() also adds a tiny amount of \"interest\" to each \"deposit\" (0.00000001); otherwise\n             * you can end up in situations where the deposit amount is, say, 0.2499999 instead of 0.25,\n             * and four such deposits would still fall short of the 1-cycle threshold.\n             */\n            this.nCyclesDeposited = this.nCyclesDepositPerFrame = 0;\n        }\n        this.resetSpeed();\n    }\n\n    /**\n     * addAnimator(callBack)\n     *\n     * Animators are functions that used to be called with YIELDS_PER_SECOND frequency, when animate()\n     * was called on every onYield() call, but now we rely on requestAnimationFrame(), so the frequency\n     * is browser-dependent (but presumably at least 60Hz).\n     *\n     * @this {Time}\n     * @param {function(number)} callBack\n     */\n    addAnimator(callBack)\n    {\n        this.aAnimators.push(callBack);\n    }\n\n    /**\n     * addBinding(binding, element)\n     *\n     * @this {Time}\n     * @param {string} binding\n     * @param {Element} element\n     */\n    addBinding(binding, element)\n    {\n        let time = this;\n\n        switch(binding) {\n\n        case Time.BINDING.RUN:\n            element.onclick = function onClickRun() {\n                time.onRun();\n            };\n            break;\n\n        case Time.BINDING.STEP:\n            element.onclick = function onClickStep() {\n                time.onStep();\n            };\n            break;\n\n        case Time.BINDING.THROTTLE:\n            let elementInput = /** @type {HTMLInputElement} */ (element);\n            elementInput.addEventListener(\"mousedown\", function onThrottleStart() {\n                time.fThrottling = true;\n            });\n            elementInput.addEventListener(\"mouseup\", function onThrottleStop() {\n                time.setSpeedThrottle();\n                time.fThrottling = false;\n            });\n            elementInput.addEventListener(\"mousemove\", function onThrottleChange() {\n                if (time.fThrottling) {\n                    time.setSpeedThrottle();\n                }\n            });\n            elementInput.addEventListener(\"change\", function onThrottleChange() {\n                time.fThrottling = true;\n                time.setSpeedThrottle();\n                time.fThrottling = false;\n            });\n            break;\n        }\n        super.addBinding(binding, element);\n    }\n\n    /**\n     * addClocker(callBack)\n     *\n     * Adds a clocker function that's called from doBurst() to process a specified number of cycles.\n     *\n     * @this {Time}\n     * @param {function(number)} callBack\n     */\n    addClocker(callBack)\n    {\n        this.aClockers.push(callBack);\n    }\n\n    /**\n     * addTimer(id, callBack, msAuto)\n     *\n     * Devices that want to have timers that fire after some number of milliseconds call addTimer() to create\n     * the timer, and then setTimer() when they want to arm it.  Alternatively, they can specify an automatic\n     * timeout value (in milliseconds) to have the timer fire automatically at regular intervals.  There is\n     * currently no removeTimer() because these are generally used for the entire lifetime of a device.\n     *\n     * A timer is initially dormant; dormant timers have a cycle count of -1 (although any negative number will\n     * suffice) and active timers have a non-negative cycle count.\n     *\n     * @this {Time}\n     * @param {string} id\n     * @param {function()} callBack\n     * @param {number} [msAuto] (if set, enables automatic setTimer calls)\n     * @returns {number} timer index (1-based)\n     */\n    addTimer(id, callBack, msAuto = -1)\n    {\n        let nCyclesLeft = -1;\n        let iTimer = this.aTimers.length + 1;\n        this.aTimers.push({id, callBack, msAuto, nCyclesLeft});\n        if (msAuto >= 0) this.setTimer(iTimer, msAuto);\n        return iTimer;\n    }\n\n    /**\n     * addUpdater(callBack)\n     *\n     * Adds a status update function that's called from updateStatus(), either as the result\n     * of periodic status updates from onYield(), single-step updates from step(), or transitional\n     * updates from start() and stop().\n     *\n     * @this {Time}\n     * @param {function(boolean)} callBack\n     */\n    addUpdater(callBack)\n    {\n        this.aUpdaters.push(callBack);\n    }\n\n    /**\n     * animate(t)\n     *\n     * This is the callback function we supply to requestAnimationFrame().  The callback has a single\n     * (DOMHighResTimeStamp) argument, which indicates the current time (returned from performance.now())\n     * for when requestAnimationFrame() starts to fire callbacks.\n     *\n     * See: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame\n     *\n     * @this {Time}\n     * @param {number} [t]\n     */\n    animate(t)\n    {\n        if (this.fClockByFrame) {\n            /*\n             * Mimic the logic in run()\n             */\n            if (!this.fRunning) return;\n            this.snapStart();\n            try {\n                this.fYield = false;\n                do {\n                    /*\n                     * Execute the burst and then update all timers.\n                     */\n                    this.updateTimers(this.endBurst(this.doBurst(this.getCyclesPerFrame())));\n                } while (this.fRunning && !this.fYield);\n            }\n            catch (err) {\n                this.println(err.message);\n                this.stop();\n                return;\n            }\n            this.snapStop();\n        }\n        for (let i = 0; i < this.aAnimators.length; i++) {\n            this.aAnimators[i](t);\n        }\n        if (this.fRunning && this.fRequestAnimationFrame) this.requestAnimationFrame(this.onAnimationFrame);\n    }\n\n    /**\n     * calcCycles()\n     *\n     * Calculate the maximum number of cycles we should attempt to process before the next yield.\n     *\n     * @this {Time}\n     */\n    calcCycles()\n    {\n        let nMultiplier = this.mhzCurrent / this.mhzBase;\n        if (!nMultiplier || nMultiplier > this.nTargetMultiplier) {\n            nMultiplier = this.nTargetMultiplier;\n        }\n        /*\n         * nCyclesPerYield is now allowed to be a fractional number, so that for machines configured\n         * to run at an extremely slow speed (eg, less than 60Hz), a fractional value here will signal\n         * to snapStop() that it should increase msYield to a proportionally higher value.\n         */\n        this.nCyclesPerYield = (this.nCyclesPerSecond / this.nYieldsPerSecond * nMultiplier);\n        this.nCurrentMultiplier = nMultiplier;\n    }\n\n    /**\n     * calcSpeed(nCycles, msElapsed)\n     *\n     * @this {Time}\n     * @param {number} nCycles\n     * @param {number} msElapsed\n     */\n    calcSpeed(nCycles, msElapsed)\n    {\n        if (msElapsed) {\n            this.mhzCurrent = (nCycles / (msElapsed * 10)) / 100;\n        }\n    }\n\n    /**\n     * doBurst(nCycles)\n     *\n     * @this {Time}\n     * @param {number} nCycles\n     * @returns {number} (number of cycles actually executed)\n     */\n    doBurst(nCycles)\n    {\n        this.nCyclesBurst = this.nCyclesRemain = nCycles;\n        if (!this.aClockers.length) {\n            this.nCyclesRemain = 0;\n            return this.nCyclesBurst;\n        }\n        let iClocker = 0;\n        while (this.nCyclesRemain > 0) {\n            if (iClocker < this.aClockers.length) {\n                nCycles = this.aClockers[iClocker++](nCycles) || 1;\n            } else {\n                iClocker = nCycles = 0;\n            }\n            this.nCyclesRemain -= nCycles;\n        }\n        return this.nCyclesBurst - this.nCyclesRemain;\n    }\n\n    /**\n     * doOutside(fn)\n     *\n     * Use this function to perform any work outside of normal time (eg, DOM updates),\n     * to prevent that work from disrupting our speed calculations.\n     *\n     * @this {Time}\n     * @param {function()} fn (should return true only if the function actually performed any work)\n     * @returns {boolean}\n     */\n    doOutside(fn)\n    {\n        let msStart = Date.now();\n        if (fn()) {\n            let msStop = Date.now();\n            this.msOutsideThisRun += msStop - msStart;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * endBurst(nCycles)\n     *\n     * @this {Time}\n     * @param {number} [nCycles]\n     * @returns {number} (number of cycles executed in burst)\n     */\n    endBurst(nCycles = this.nCyclesBurst - this.nCyclesRemain)\n    {\n        if (this.fClockByFrame) {\n            this.nCyclesDeposited -= nCycles;\n            if (this.nCyclesDeposited < 1) {\n                this.fYield = true;\n            }\n        }\n        this.nCyclesBurst = this.nCyclesRemain = 0;\n        this.nCyclesThisRun += nCycles;\n        this.nCyclesRun += nCycles;\n        if (!this.fRunning) this.nCyclesRun = 0;\n        return nCycles;\n    }\n\n    /**\n     * getCycles(ms)\n     *\n     * If no time period is specified, this returns the current number of cycles per second.\n     *\n     * @this {Time}\n     * @param {number} ms (default is 1000)\n     * @returns {number} number of corresponding cycles\n     */\n    getCycles(ms = 1000)\n    {\n        return Math.ceil((this.nCyclesPerSecond * this.nCurrentMultiplier) / 1000 * ms);\n    }\n\n    /**\n     * getCyclesPerBurst()\n     *\n     * This tells us how many cycles to execute as a burst.\n     *\n     * @this {Time}\n     * @returns {number} (the maximum number of cycles we should execute in the next burst)\n     */\n    getCyclesPerBurst()\n    {\n        let nCycles = this.getCycles(this.msYield);\n        for (let iTimer = this.aTimers.length; iTimer > 0; iTimer--) {\n            let timer = this.aTimers[iTimer-1];\n\n            if (timer.nCyclesLeft < 0) continue;\n            if (nCycles > timer.nCyclesLeft) {\n                nCycles = timer.nCyclesLeft;\n            }\n        }\n        return nCycles;\n    }\n\n    /**\n     * getCyclesPerFrame()\n     *\n     * This tells us how many cycles to execute per frame (assuming fClockByFrame).\n     *\n     * @this {Time}\n     * @returns {number} (the maximum number of cycles we should execute in the next burst)\n     */\n    getCyclesPerFrame()\n    {\n        let nCycles = (this.nCyclesDeposited += this.nCyclesDepositPerFrame);\n        if (nCycles < 1) {\n            nCycles = 0;\n        } else {\n            nCycles |= 0;\n            for (let iTimer = this.aTimers.length; iTimer > 0; iTimer--) {\n                let timer = this.aTimers[iTimer-1];\n\n                if (timer.nCyclesLeft < 0) continue;\n                if (nCycles > timer.nCyclesLeft) {\n                    nCycles = timer.nCyclesLeft;\n                }\n            }\n        }\n        return nCycles;\n    }\n\n    /**\n     * getSpeed(mhz)\n     *\n     * @this {Time}\n     * @param {number} mhz\n     * @returns {string} the given speed, as a formatted string\n     */\n    getSpeed(mhz)\n    {\n        let s;\n        if (mhz >= 1) {\n            s = mhz.toFixed(2) + \"Mhz\";\n        } else {\n            let hz = Math.round(mhz * 1000000);\n            if (hz <= 999) {\n                s = hz + \"Hz\";\n            } else {\n                s = Math.ceil(hz / 1000) + \"Khz\";\n            }\n        }\n        return s;\n    }\n\n    /**\n     * getSpeedCurrent()\n     *\n     * @this {Time}\n     * @returns {string} the current speed, as a formatted string\n     */\n    getSpeedCurrent()\n    {\n        return (this.fRunning && this.mhzCurrent)? this.getSpeed(this.mhzCurrent) : \"Stopped\";\n    }\n\n    /**\n     * getSpeedTarget()\n     *\n     * @this {Time}\n     * @returns {string} the target speed, as a formatted string\n     */\n    getSpeedTarget()\n    {\n        return this.getSpeed(this.mhzTarget);\n    }\n\n    /**\n     * isRunning()\n     *\n     * @this {Time}\n     * @returns {boolean}\n     */\n    isRunning()\n    {\n        return this.fRunning;\n    }\n\n    /**\n     * isTimerSet(iTimer)\n     *\n     * NOTE: Even if the timer is armed, we return false if the clock is currently stopped;\n     * in that sense, perhaps this function should be named isTimerArmedAndWillItFireOnTime().\n     *\n     * @this {Time}\n     * @param {number} iTimer\n     * @returns {boolean}\n     */\n    isTimerSet(iTimer)\n    {\n        if (this.fRunning) {\n            if (iTimer > 0 && iTimer <= this.aTimers.length) {\n                let timer = this.aTimers[iTimer - 1];\n                return (timer.nCyclesLeft >= 0);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * onRun()\n     *\n     * This handles the \"run\" button, if any, attached to the Time device.\n     *\n     * Note that this serves a different purpose than the \"power\" button that's managed by the Input device,\n     * because toggling power also requires resetting the program counter prior to start() OR clearing the display\n     * after stop().  See the Chip's onPower() function for details.\n     *\n     * @this {Time}\n     */\n    onRun()\n    {\n        if (this.fRunning) {\n            this.stop();\n        } else {\n            this.start();\n        }\n    }\n\n    /**\n     * onStep(nRepeat)\n     *\n     * This handles the \"step\" button, if any, attached to the Time device.\n     *\n     * @this {Time}\n     * @param {number} [nRepeat]\n     */\n    onStep(nRepeat)\n    {\n        if (!this.fRunning) {\n            if (this.nStepping) {\n                this.stop();\n            } else {\n                this.step(nRepeat);\n            }\n        } else {\n            this.println(\"already running\");\n        }\n    }\n\n    /**\n     * onYield()\n     *\n     * @this {Time}\n     */\n    onYield()\n    {\n        this.fYield = true;\n        let nYields = this.nYields;\n        let nCyclesPerSecond = this.getCycles();\n        if (nCyclesPerSecond >= this.nYieldsPerSecond) {\n            this.nYields++;\n        } else {\n            /*\n             * Let's imagine that nCyclesPerSecond has dropped to 4, whereas the usual nYieldsPerSecond is 60;\n             * that's means we're yielding at 1/15th the usual rate, so to compensate, we want to bump nYields\n             * by 15 instead of 1.\n             */\n            this.nYields += Math.ceil(this.nYieldsPerSecond / nCyclesPerSecond);\n        }\n        if (this.nYields >= this.nYieldsPerUpdate && nYields < this.nYieldsPerUpdate) {\n            this.updateStatus();\n        }\n        if (this.nYields >= this.nYieldsPerSecond) {\n            this.nYields = 0;\n        }\n    }\n\n    /**\n     * resetSpeed()\n     *\n     * Resets speed and cycle information as part of any reset() or restore(); this typically occurs during powerUp().\n     * It's important that this be called BEFORE the actual restore() call, because restore() may want to call setSpeed(),\n     * which in turn assumes that all the cycle counts have been initialized to sensible values.\n     *\n     * @this {Time}\n     */\n    resetSpeed()\n    {\n        this.nCyclesRun = this.nCyclesBurst = this.nCyclesRemain = 0;\n        if (!this.setSpeedThrottle()) this.setSpeed(this.nBaseMultiplier);\n    }\n\n    /**\n     * resetTimers()\n     *\n     * When the target speed multiplier is altered, it's a good idea to run through all the timers that\n     * have a fixed millisecond period and re-arm them, because the timers are using cycle counts that were based\n     * on a previous multiplier.\n     *\n     * @this {Time}\n     */\n    resetTimers()\n    {\n        for (let iTimer = this.aTimers.length; iTimer > 0; iTimer--) {\n            let timer = this.aTimers[iTimer-1];\n            if (timer.msAuto >= 0) this.setTimer(iTimer, timer.msAuto, true);\n        }\n    }\n\n    /**\n     * run()\n     *\n     * @this {Time}\n     */\n    run()\n    {\n        this.idRunTimeout = 0;\n        if (!this.fRunning) return;\n        this.snapStart();\n        try {\n            this.fYield = false;\n            do {\n                /*\n                 * Execute the burst and then update all timers.\n                 */\n                this.updateTimers(this.endBurst(this.doBurst(this.getCyclesPerBurst())));\n\n            } while (this.fRunning && !this.fYield);\n        }\n        catch(err) {\n            this.println(err.message);\n            this.stop();\n            return;\n        }\n        if (this.fRunning) {\n\n            this.idRunTimeout = setTimeout(this.onRunTimeout, this.snapStop());\n            if (!this.fRequestAnimationFrame) this.animate();\n        }\n    }\n\n    /**\n     * setSpeedThrottle()\n     *\n     * This handles speed adjustments requested by the throttling slider.\n     *\n     * @this {Time}\n     * @returns {boolean} (true if a throttle exists, false if not)\n     */\n    setSpeedThrottle()\n    {\n        /*\n         * We're not going to assume any direct relationship between the slider's min/max/value\n         * and our own nCyclesMinimum/nCyclesMaximum/nCyclesPerSecond.  We're just going to calculate\n         * a new target nCyclesPerSecond that is proportional, and then convert that to a speed multiplier.\n         */\n        let elementInput = this.bindings[Time.BINDING.THROTTLE];\n        if (elementInput) {\n            let ratio = (elementInput.value - elementInput.min) / (elementInput.max - elementInput.min);\n            let nCycles = Math.floor((this.nCyclesMaximum - this.nCyclesMinimum) * ratio + this.nCyclesMinimum);\n            let nMultiplier = nCycles / this.nCyclesPerSecond;\n\n            this.setSpeed(nMultiplier);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * setSpeed(nMultiplier)\n     *\n     * @this {Time}\n     * @param {number} [nMultiplier] is the new proposed multiplier (reverts to default if target was too high)\n     * @returns {boolean} true if successful, false if not\n     *\n     * @desc Whenever the speed is changed, the running cycle count and corresponding start time must be reset,\n     * so that the next effective speed calculation obtains sensible results.  In fact, when run() initially calls\n     * setSpeed() with no parameters, that's all this function does (it doesn't change the current speed setting).\n     */\n    setSpeed(nMultiplier)\n    {\n        let fSuccess = true;\n        if (nMultiplier !== undefined) {\n            /*\n             * If we haven't reached 90% (0.9) of the current target speed, revert to the default multiplier.\n             */\n            if (!this.fThrottling && this.mhzCurrent > 0 && this.mhzCurrent < this.mhzTarget * 0.9) {\n                nMultiplier = this.nBaseMultiplier;\n                fSuccess = false;\n            }\n            this.nTargetMultiplier = nMultiplier;\n            let mhzTarget = this.mhzBase * this.nTargetMultiplier;\n            if (this.mhzTarget != mhzTarget) {\n                this.mhzTarget = mhzTarget;\n                this.setBindingText(Time.BINDING.SPEED, this.getSpeedTarget());\n            }\n            /*\n             * After every yield, calcSpeed() will update mhzCurrent, but we also need to be optimistic\n             * and set it to the mhzTarget now, so that the next calcCycles() call will make a reasonable\n             * initial estimate.\n             */\n            this.mhzCurrent = this.mhzTarget;\n        }\n        if (this.fClockByFrame) {\n            let nCyclesPerSecond = this.mhzCurrent * 1000000;\n            this.nCyclesDepositPerFrame = (nCyclesPerSecond / 60) + 0.00000001;\n            this.nCyclesDeposited = 0;\n        }\n        this.nCyclesRun = 0;\n        this.msStartRun = this.msEndRun = 0;\n        this.calcCycles();      // calculate a new value for the current cycle multiplier\n        this.resetTimers();     // and then update all the fixed-period timers using the new cycle multiplier\n        return fSuccess;\n    }\n\n    /**\n     * setTimer(iTimer, ms, fReset)\n     *\n     * Using the timer index from a previous addTimer() call, this sets that timer to fire after the\n     * specified number of milliseconds.\n     *\n     * @this {Time}\n     * @param {number} iTimer\n     * @param {number} ms (converted into a cycle countdown internally)\n     * @param {boolean} [fReset] (true if the timer should be reset even if already armed)\n     * @returns {number} (number of cycles used to arm timer, or -1 if error)\n     */\n    setTimer(iTimer, ms, fReset)\n    {\n        let nCycles = -1;\n        if (iTimer > 0 && iTimer <= this.aTimers.length) {\n            let timer = this.aTimers[iTimer-1];\n            if (fReset || timer.nCyclesLeft < 0) {\n                nCycles = this.getCycles(ms);\n                /*\n                 * If we're currently executing a burst of cycles, the number of cycles it has executed in\n                 * that burst so far must NOT be charged against the cycle timeout we're about to set.  The simplest\n                 * way to resolve that is to immediately call endBurst() and bias the cycle timeout by the number\n                 * of cycles that the burst executed.\n                 */\n                if (this.fRunning) {\n                    nCycles += this.endBurst();\n                }\n                timer.nCyclesLeft = nCycles;\n            }\n        }\n        return nCycles;\n    }\n\n    /**\n     * snapStart()\n     *\n     * @this {Time}\n     */\n    snapStart()\n    {\n        this.calcCycles();\n\n        this.nCyclesThisRun = 0;\n        this.msOutsideThisRun = 0;\n        this.msStartThisRun = Date.now();\n        if (!this.msStartRun) this.msStartRun = this.msStartThisRun;\n\n        /*\n         * Try to detect situations where the browser may have throttled us, such as when the user switches\n         * to a different tab; in those situations, Chrome and Safari may restrict setTimeout() callbacks\n         * to roughly one per second.\n         *\n         * Another scenario: the user resizes the browser window.  setTimeout() callbacks are not throttled,\n         * but there can still be enough of a lag between the callbacks that speed will be noticeably\n         * erratic if we don't compensate for it here.\n         *\n         * We can detect throttling/lagging by verifying that msEndRun (which was set at the end of the\n         * previous run and includes any requested sleep time) is comparable to the current msStartThisRun;\n         * if the delta is significant, we compensate by bumping msStartRun forward by that delta.\n         *\n         * This shouldn't be triggered when the Debugger stops time, because setSpeed() -- which is called\n         * whenever the time starts again -- zeroes msEndRun.\n         */\n        let msDelta = 0;\n        if (this.msEndRun) {\n            msDelta = this.msStartThisRun - this.msEndRun;\n            if (msDelta > this.msYield) {\n                this.msStartRun += msDelta;\n                /*\n                 * Bumping msStartRun forward should NEVER cause it to exceed msStartThisRun; however, just\n                 * in case, I make absolutely sure it cannot happen, since doing so could result in negative\n                 * speed calculations.\n                 */\n\n                if (this.msStartRun > this.msStartThisRun) {\n                    this.msStartRun = this.msStartThisRun;\n                }\n            }\n        }\n    }\n\n    /**\n     * snapStop()\n     *\n     * @this {Time}\n     * @returns {number}\n     */\n    snapStop()\n    {\n        this.msEndRun = Date.now();\n\n        if (this.msOutsideThisRun) {\n            this.msStartRun += this.msOutsideThisRun;\n            this.msStartThisRun += this.msOutsideThisRun;\n        }\n\n        let msYield = this.msYield;\n        if (this.nCyclesThisRun) {\n            /*\n             * Normally, we assume we executed a full quota of work over msYield.  If nCyclesThisRun is correct,\n             * then the ratio of nCyclesThisRun/nCyclesPerYield should represent the percentage of work we performed,\n             * and so applying that percentage to msYield should give us a better estimate of work vs. time.\n             */\n            msYield = Math.round(msYield * this.nCyclesThisRun / this.nCyclesPerYield);\n        }\n\n        let msElapsedThisRun = this.msEndRun - this.msStartThisRun;\n        let msRemainsThisRun = msYield - msElapsedThisRun;\n\n        let nCycles = this.nCyclesRun;\n        let msElapsed = this.msEndRun - this.msStartRun;\n\n        if (DEBUG && msRemainsThisRun < 0 && this.nTargetMultiplier > 1) {\n            this.println(\"warning: updates @\" + msElapsedThisRun + \"ms (prefer \" + Math.round(msYield) + \"ms)\");\n        }\n\n        this.calcSpeed(nCycles, msElapsed);\n\n        if (msRemainsThisRun < 0) {\n            /*\n             * Try \"throwing out\" the effects of large anomalies, by moving the overall run start time up;\n             * ordinarily, this should only happen when the someone is using an external Debugger or some other\n             * tool or feature that is interfering with our overall execution.\n             */\n            if (msRemainsThisRun < -1000) {\n                this.msStartRun -= msRemainsThisRun;\n            }\n            /*\n             * If the last burst took MORE time than we allotted (ie, it's taking more than 1 second to simulate\n             * nCyclesPerSecond), all we can do is yield for as little time as possible (ie, 0ms) and hope that the\n             * simulation is at least usable.\n             */\n            msRemainsThisRun = 0;\n        }\n        else if (this.mhzCurrent < this.mhzTarget) {\n            msRemainsThisRun = 0;\n        }\n\n        this.msEndRun += msRemainsThisRun;\n\n        if (this.isCategoryOn(Device.CATEGORY.TIME)) {\n            this.printf(\"after running %d cycles, resting for %dms\\n\", this.nCyclesThisRun, msRemainsThisRun);\n        }\n\n        return msRemainsThisRun;\n    }\n\n    /**\n     * start()\n     *\n     * @this {Time}\n     * @returns {boolean}\n     */\n    start()\n    {\n        if (this.fRunning || this.nStepping) {\n            return false;\n        }\n\n        if (this.idRunTimeout) {\n            clearTimeout(this.idRunTimeout);\n            this.idRunTimeout = 0;\n        }\n\n        this.fRunning = true;\n        this.msStartRun = this.msEndRun = 0;\n        this.updateStatus(true);\n\n        /*\n         * Kickstart both the clockers and requestAnimationFrame; it's a little premature to start\n         * animation here, because the first run() should take place before the first animate(), but\n         * since clock speed is now decoupled from animation speed, this isn't something we should\n         * worry about.\n         */\n        if (!this.fClockByFrame) {\n\n            this.idRunTimeout = setTimeout(this.onRunTimeout, 0);\n        }\n        if (this.fRequestAnimationFrame) this.requestAnimationFrame(this.onAnimationFrame);\n        return true;\n    }\n\n    /**\n     * step(nRepeat)\n     *\n     * @this {Time}\n     * @param {number} [nRepeat]\n     * @returns {boolean} true if successful, false if already running\n     */\n    step(nRepeat = 1)\n    {\n        if (!this.fRunning) {\n            if (nRepeat && !this.nStepping) {\n                this.nStepping = nRepeat;\n            }\n            if (this.nStepping) {\n                /*\n                 * Execute a minimum-cycle burst and then update all timers.\n                 */\n                let nCycles = (this.fClockByFrame? (this.getCyclesPerFrame() || 1) : 1);\n                this.nStepping--;\n                this.updateTimers(this.endBurst(this.doBurst(nCycles)));\n                this.updateStatus();\n                if (this.nStepping) {\n                    let time = this;\n                    this.idStepTimeout = setTimeout(function onStepTimeout() {\n                        time.step(0);\n                    }, 0);\n                    return true;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * stop()\n     *\n     * @this {Time}\n     * @returns {boolean} true if successful, false if already stopped\n     */\n    stop()\n    {\n        if (this.nStepping) {\n            this.nStepping = 0;\n            this.updateStatus(true);\n            return true;\n        }\n        if (this.fRunning) {\n            this.fRunning = false;\n            this.endBurst();\n            this.updateStatus(true);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * updateStatus(fTransition)\n     *\n     * Used for periodic status updates from onYield(), single-step updates from step(), and transitional\n     * updates from start() and stop().\n     *\n     * @this {Time}\n     * @param {boolean} [fTransition]\n     */\n    updateStatus(fTransition)\n    {\n        if (fTransition) {\n            if (this.fRunning) {\n                this.println(\"starting (\" + this.getSpeedTarget() + \" target by \" + (this.fClockByFrame? \"frame\" : \"timer\") + \")\");\n                fTransition = false;\n            } else {\n                this.println(\"stopping\");\n            }\n        }\n\n        this.setBindingText(Time.BINDING.RUN, this.fRunning? \"Halt\" : \"Run\");\n        this.setBindingText(Time.BINDING.STEP, this.nStepping? \"Stop\" : \"Step\");\n        if (!this.fThrottling) {\n            this.setBindingText(Time.BINDING.SPEED, this.getSpeedCurrent());\n        }\n\n        for (let i = 0; i < this.aUpdaters.length; i++) {\n            this.aUpdaters[i](fTransition);\n        }\n    }\n\n    /**\n     * updateTimers(nCycles)\n     *\n     * Used by run() to reduce all active timer countdown values by the number of cycles just executed;\n     * this is the function that actually \"fires\" any timer(s) whose countdown has reached (or dropped below)\n     * zero, invoking their callback function.\n     *\n     * @this {Time}\n     * @param {number} nCycles (number of cycles actually executed)\n     */\n    updateTimers(nCycles)\n    {\n        if (nCycles >= 1) {\n            for (let iTimer = this.aTimers.length; iTimer > 0; iTimer--) {\n                let timer = this.aTimers[iTimer-1];\n\n                if (timer.nCyclesLeft < 0) continue;\n                timer.nCyclesLeft -= nCycles;\n                if (timer.nCyclesLeft <= 0) {\n                    timer.nCyclesLeft = -1; // zero is technically an \"active\" value, so ensure the timer is dormant now\n                    timer.callBack();       // safe to invoke the callback function now\n                    if (timer.msAuto >= 0) {\n                        this.setTimer(iTimer, timer.msAuto);\n                    }\n                }\n            }\n        }\n    }\n}\n\nTime.BINDING = {\n    RUN:        \"run\",\n    SPEED:      \"speed\",\n    STEP:       \"step\",\n    THROTTLE:   \"throttle\"\n};\n\n/*\n * We yield more often now (120 times per second instead of 60), to help ensure that requestAnimationFrame()\n * callbacks can be called as timely as possible.  And we still only want to perform DOM-related status updates\n * no more than twice per second, so the required number of yields before each update has been increased as well.\n */\nTime.YIELDS_PER_SECOND = 120;\nTime.YIELDS_PER_UPDATE = 60;\n\nTime.VERSION = +VERSION || 1.20;\n\n/**\n * @copyright https://www.pcjs.org/modules/devices/tms1500.js (C) Jeff Parsons 2012-2018\n */\n\n/**\n * 64-bit Register\n *\n * @class {Reg64}\n * @unrestricted\n * @property {Chip} chip\n * @property {Array.<number>} digits\n */\nclass Reg64 extends Device {\n    /**\n     * Reg64(chip, id, fInternal)\n     *\n     * @this {Reg64}\n     * @param {Chip} chip\n     * @param {string} id\n     * @param {boolean} [fInternal]\n     */\n    constructor(chip, id, fInternal)\n    {\n        super(chip.idMachine, id, chip.version);\n        this.chip = chip;\n        this.name = id;\n\n        /*\n         * Each Reg64 register contains 16 BCD/Hex digits, which we store as 16 independent 4-bit numbers,\n         * where [0] is D0, aka DIGIT 0, and [15] is D15, aka DIGIT 15.\n         */\n        this.digits = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\n\n        /*\n         * Automatically add direct bindings for this new register and all its digits to the caller's bindings.\n         */\n        if (!fInternal) {\n            let bindings = [];\n            let name = \"reg\" + this.name;\n            bindings.push(name);\n            chip.regMap[name] = [this, -1];\n            for (let d = 0; d < this.digits.length; d++) {\n                name = this.sprintf(\"reg%s-%02d\", this.name, d);\n                bindings.push(name);\n                chip.regMap[name] = [this, d];\n            }\n            chip.addBindings(bindings);\n        }\n    }\n\n    /**\n     * add(reg, regSrc, range, base)\n     *\n     * @this {Reg64}\n     * @param {Reg64} reg\n     * @param {Reg64} regSrc\n     * @param {Array.<number>} range\n     * @param {number} base\n     */\n    add(reg, regSrc, range, base)\n    {\n        let carry = 0;\n        for (let i = range[0], j = range[1]; i <= j; i++) {\n            this.digits[i] = reg.digits[i] + regSrc.digits[i] + carry;\n            carry = 0;\n            if (this.digits[i] >= base) {\n                this.digits[i] -= base;\n                carry = 1;\n            }\n        }\n        if (carry) this.chip.fCOND = true;\n        this.updateR5(range);\n    }\n\n    /**\n     * get()\n     *\n     * @this {Reg64}\n     * @returns {Array}\n     */\n    get()\n    {\n        return this.digits;\n    }\n\n    /**\n     * init(value, range)\n     *\n     * @this {Reg64}\n     * @param {number} value\n     * @param {Array.<number>} range\n     * @returns {Reg64}\n     */\n    init(value, range = [0,15])\n    {\n        for (let i = 0; i < this.digits.length; i++) {\n            this.digits[i] = 0;\n        }\n        for (let i = range[0], j = range[1]; i <= j; i++) {\n            this.digits[i] = value & 0xf;\n            value >>>= 4;\n        }\n        return this;\n    }\n\n    /**\n     * move(regSrc, range)\n     *\n     * @this {Reg64}\n     * @param {Reg64} regSrc\n     * @param {Array.<number>} range\n     */\n    move(regSrc, range)\n    {\n        for (let i = range[0], j = range[1]; i <= j; i++) {\n            this.digits[i] = regSrc.digits[i];\n        }\n        regSrc.updateR5(range);\n    }\n\n    /**\n     * set(digits)\n     *\n     * @this {Reg64}\n     * @param {Array} digits\n     */\n    set(digits)\n    {\n        if (!digits || digits.length != this.digits.length) return;\n        for (let i = 0; i < this.digits.length; i++) this.digits[i] = digits[i];\n    }\n\n    /**\n     * shl(reg, range)\n     *\n     * @this {Reg64}\n     * @param {Reg64} reg\n     * @param {Array.<number>} range\n     */\n    shl(reg, range)\n    {\n        let i, j;\n        for (i = range[1], j = range[0]; i > j; i--) {\n            this.digits[i] = reg.digits[i-1];\n        }\n        this.digits[i] = 0;\n        this.updateR5(range);\n    }\n\n    /**\n     * shr(reg, range)\n     *\n     * @this {Reg64}\n     * @param {Reg64} reg\n     * @param {Array.<number>} range\n     */\n    shr(reg, range)\n    {\n        let i, j;\n        for (i = range[0], j = range[1]; i < j; i++) {\n            this.digits[i] = reg.digits[i+1];\n        }\n        this.digits[i] = 0;\n        this.updateR5(range);\n    }\n\n    /**\n     * store(reg)\n     *\n     * STORE is similar to MOVE, but all digits are stored (ie, no mask is involved), and R5 is not affected.\n     *\n     * @this {Reg64}\n     * @param {Reg64} reg\n     */\n    store(reg)\n    {\n        for (let i = 0, j = this.digits.length; i < j; i++) {\n            this.digits[i] = reg.digits[i];\n        }\n    }\n\n    /**\n     * sub(reg, regSrc, range, base)\n     *\n     * @this {Reg64}\n     * @param {Reg64} reg\n     * @param {Reg64} regSrc\n     * @param {Array.<number>} range\n     * @param {number} base\n     */\n    sub(reg, regSrc, range, base)\n    {\n        let carry = 0;\n        for (let i = range[0], j = range[1]; i <= j; i++) {\n            this.digits[i] = reg.digits[i] - regSrc.digits[i] - carry;\n            carry = 0;\n            if (this.digits[i] < 0) {\n                this.digits[i] += base;\n                carry = 1;\n            }\n        }\n        if (carry) this.chip.fCOND = true;\n        this.updateR5(range);\n    }\n\n    /**\n     * toString(fSpaces)\n     *\n     * @this {Reg64}\n     * @param {boolean} [fSpaces]\n     * @returns {string}\n     */\n    toString(fSpaces = false)\n    {\n        let s = this.idDevice + '=';\n        if (fSpaces && s.length < 3) s += ' ';\n        for (let i = this.digits.length - 1; i >= 0; i--) {\n            if (fSpaces) {\n                s += Device.HexUpperCase[this.digits[i]];\n            } else {\n                s += Device.HexLowerCase[this.digits[i]] + ((i % 4)? '' : ' ');\n            }\n        }\n        return s;\n    }\n\n    /**\n     * updateR5(range)\n     *\n     * @this {Reg64}\n     */\n    updateR5(range)\n    {\n        this.chip.regR5 = this.digits[range[0]];\n\n        if (range[0] < range[1]) {\n            this.chip.regR5 |= this.digits[range[0]+1] << 4;\n\n        }\n    }\n\n    /**\n     * xchg(regSrc, range)\n     *\n     * @this {Reg64}\n     * @param {Reg64} regSrc\n     * @param {Array.<number>} range\n     */\n    xchg(regSrc, range)\n    {\n        for (let i = range[0], j = range[1]; i <= j; i++) {\n            let d = this.digits[i];\n            this.digits[i] = regSrc.digits[i];\n            regSrc.digits[i] = d;\n        }\n        regSrc.updateR5(range);\n    }\n}\n\n/**\n * TMS-150x Calculator Chip\n *\n * Emulates various TMS (\"Texas Mos Standard\") and TMC (\"Texas Mos Custom\") chips.  The 'type' property of\n * the config object should contain one of the following strings:\n *\n *      TI-57: \"TMS-1501\" or \"TMC-1501\" (or simply \"1501\")\n *      TI-55: \"TMS-1503\" or \"TMC-1503\" (or simply \"1503\")\n *\n * This chip contains lots of small discrete devices, most of which will be emulated either within this\n * class or within another small container class in the same file, because most of them are either very simple\n * or have unique quirks, so it's not clear there's much reusability.\n *\n * One exception is the ROM, since ROMs are a very common device with very similar characteristics.  Since\n * the Machine class guarantees that the Chip class is initialized after the ROM class, we can look it up in\n * the constructor.\n *\n * @class {Chip}\n * @unrestricted\n * @property {Array.<Reg64>} regsO (operational registers A-D)\n * @property {Reg64} regA (alias for regsO[0])\n * @property {Reg64} regB (alias for regsO[1])\n * @property {Reg64} regC (alias for regsO[2])\n * @property {Reg64} regD (alias for regsO[3])\n * @property {Array.<Reg64>} regsX (storage registers X0-X7)\n * @property {Array.<Reg64>} regsY (storage registers Y0-Y7)\n * @property {Reg64} regSupp (alternate register used when the destination must be suppressed)\n * @property {Reg64} regTemp (temporary register used to supply constants or other internal values)\n * @property {number} base (10 or 16)\n * @property {boolean} fCOND (true when a carry has been detected)\n * @property {number} regRAB\n * @property {number} regR5 (least significant masked digit(s) from last arithmetic result)\n * @property {number} regPC (program counter: address of next instruction to decode)\n * @property {number} regKey (current key status, propagated to regR5 at appropriate intervals)\n * @property {Array.<number>} stack (3-level address stack; managed by push() and pop())\n * @property {number} nCyclesClocked\n * @property {Input} input\n * @property {LED} led\n * @property {ROM} rom\n * @property {Time} time\n * @property {number} addrPrev\n * @property {number} addrStop\n * @property {Object} breakConditions\n * @property {number} nStringFormat\n * @property {number} type (one of the Chip.TYPE values)\n */\nclass Chip extends Device {\n    /**\n     * Chip(idMachine, idDevice, config)\n     *\n     * Defines the basic elements of the TMS-150x chip, as illustrated by U.S. Patent No. 4,125,901, Fig. 3 (p. 4)\n     *\n     * @this {Chip}\n     * @param {string} idMachine\n     * @param {string} idDevice\n     * @param {Config} [config]\n     */\n    constructor(idMachine, idDevice, config)\n    {\n        super(idMachine, idDevice, Chip.VERSION, config);\n\n        let sType = this.getDefaultString('type', \"1501\");\n        this.type = Number.parseInt(sType.slice(-4), 10);\n\n        this.regMap = {};\n\n        /*\n         * Four (4) Operational Registers (A-D)\n         */\n        this.regsO = new Array(4);\n        for (let i = 0; i < 4; i++) {\n            this.regsO[i] = new Reg64(this, String.fromCharCode(0x41+i));\n        }\n\n        /*\n         * Aliases for each of the Operational Registers, since some instructions use hard-coded registers,\n         * rather than calculating a register index (0-3).\n         */\n        this.regA = this.regsO[0];\n        this.regB = this.regsO[1];\n        this.regC = this.regsO[2];\n        this.regD = this.regsO[3];\n\n        /*\n         * Eight (8) Storage Registers (X0-X7)\n         */\n        this.regsX = new Array(8);\n        for (let i = 0; i < 8; i++) {\n            this.regsX[i] = new Reg64(this, \"X\" + i);\n        }\n\n        /*\n         * Eight (8) Storage Registers (Y0-Y7)\n         */\n        this.regsY = new Array(8);\n        for (let i = 0; i < 8; i++) {\n            this.regsY[i] = new Reg64(this, \"Y\" + i);\n        }\n\n        this.regSupp = new Reg64(this, \"Supp\", true);\n        this.regTemp = new Reg64(this, \"Temp\", true);\n\n        this.base = 10;\n        this.fCOND = false;\n\n        /*\n         * RAB (Register Address Buffer) is a 3-bit register \"selectively loadable by the I4-I6 bits of an\n         * instruction word\" and \"also selectively loadable from the three least significant bits of the number\n         * stored in R5 register\".\n         */\n        this.regRAB = 0;\n\n        /*\n         * R5 is \"an eight bit shift register which may be selectively loaded from either the serial output from\n         * arithmetic unit\" or \"may be loaded on lines KR1-3 and KR5-7 via gates from keyboard logic (at which\n         * times the MSB of each digit in Register R5 is loaded with a zero via gates according to the keyboard code\n         * code indicated in Table II)\".\n         */\n        this.regR5 = 0;\n\n        /*\n         * The \"Output Register\" is twelve bit register, one bit for each digit of the display.  This essentially\n         * provides column information for the LED display, while the next register (regScanGen) provides row\n         * information.\n         *\n         * However, this is only necessary if we decide to simulate the internal operation of the Display Decoder\n         * and Keyboard Scanner.\n         *\n         * Refer to patent Fig. 11c (p. 28)\n         */\n        // this.regOut = 0;\n\n        /*\n         * The \"Scan Generator Counter\" is a 3-bit register.  It is updated once each instruction cycle.\n         * It \"does not count sequentially, but during eight instruction cycle provides the three bit binary\n         * representations of zero through seven.\"  Here's the sequence from \"Reference A\" of Fig. 11e:\n         *\n         *                 DECODE    DISP     KBD\n         *      W   V   U     SEG     SEG    SCAN    HOLD\n         *      ---------  ------    ----    ----    ----\n         *      1   1   1       D       -       -       1\n         *      1   1   0       A       D     KS6       1\n         *      1   0   1       B       A     KS5       1\n         *      0   1   0       C       B     KS2       1\n         *      1   0   0       E       C     KS4       1\n         *      0   0   0       F       E     KS0       1\n         *      0   0   1       G       F     KS1       1\n         *      0   1   1       P       G     KS3       0\n         *      ---------  ------    ----    ----    ----\n         *      1   1   1       D       P     KS7       1\n         *      1   1   0       A       D     KS6       1\n         *      ...\n         *\n         * However, this is only necessary if we decide to simulate the internal operation of the Display Decoder\n         * and Keyboard Scanner.\n         *\n         * Refer to patent Fig. 11e (p. 30)\n         */\n        // this.regScanGen = 0;\n\n        /*\n         * The \"Segment/Keyboard Scan\" is an 8-bit register \"arranged as a ring counter for shifting a logical zero\n         * to a different stage during each instruction cycle....  [It is] further interconnected with the RESET signal\n         * for inserting a logical one into all stages of the counter.\"  The outputs from the stages are connected to\n         * SEG D, followed by SEG A, SEG B, SEG C, SEG E, SEG F, SEG G, and SEG P.\n         *\n         * However, this is only necessary if we decide to simulate the internal operation of the Display Decoder\n         * and Keyboard Scanner.\n         *\n         * Refer to patent Fig. 11b (p. 27)\n         */\n        // this.regSegKbdScan = 0xff;\n\n        /*\n         * The \"State Time Generator\" is represented by a 5-bit register that contains values 00000b through 11111b\n         * for each of the 32 state times that occur during a single instruction cycle.  And since each \"state time\"\n         * consists of four clock pulses, designated Φ1, P1, Φ2, and P2, we keep track of which pulse we're on, too.\n         *\n         * However, these are only necessary if we decide to simulate the internal operation of the Display Decoder\n         * and Keyboard Scanner.\n         *\n         * Refer to patent Fig. 11f (p. 31)\n         */\n        // this.regStateTime = 0;\n        // this.regPulseTime = 0;\n\n        /*\n         * The \"Program Counter\" (regPC) is an 11-bit register that automatically increments unless a HOLD signal\n         * is applied, effectively locking execution on a single instruction.\n         */\n        this.regPC = 0;\n\n        /*\n         * If non-zero, a key is being pressed.  Bits 0-3 are the row (0-based) and bits 4-7 are the col (1-based).\n         */\n        this.regKey = 0;\n\n        /*\n         * The \"Subroutine Stack\".  \"When an unconditional branch instruction is decoded by branch logic 32b, the\n         * CALL signal goes to zero permitting the present ROM address plus one to be loaded into subroutine stack\n         * register 33a....  Addresses previously loaded into subroutine stack/registers 33a and 33b are shifted\n         * to registers 33b and 33c.\"\n         *\n         * We initialize it with \"guard values\" (-1) to help detect the presence of invalid data, and to catch stack\n         * overflow/underflow errors.\n         *\n         * Refer to patent Fig. 7a (p. 9)\n         */\n        this.stack = [-1, -1, -1];\n\n        /*\n         * This internal cycle count is initialized on every clocker() invocation, enabling opcode functions that\n         * need to consume a few extra cycles to bump this count upward as needed.\n         */\n        this.nCyclesClocked = 0;\n\n        /*\n         * Get access to the Input device, so we can add our click functions.\n         */\n        this.input = /** @type {Input} */ (this.findDevice(this.config['input']));\n        this.input.addInput(this.onInput.bind(this));\n        this.input.addClick(this.onPower.bind(this), this.onReset.bind(this));\n\n        /*\n         * Get access to the LED device, so we can update its display.\n         */\n        this.led = /** @type {LED} */ (this.findDevice(this.config['output']));\n\n        /*\n         * Get access to the ROM device, so we can give it access to functions like disassemble().\n         */\n        this.rom = /** @type {ROM} */ (this.findDeviceByClass(Machine.CLASS.ROM));\n        if (this.rom) this.rom.setChip(this);\n\n        /*\n         * Get access to the Time device, so we can give it our clocker() function.\n         */\n        this.time = /** @type {Time} */ (this.findDeviceByClass(Machine.CLASS.TIME));\n        if (this.time && this.rom) {\n            this.time.addClocker(this.clocker.bind(this));\n            this.time.addUpdater(this.updateStatus.bind(this));\n        }\n\n        /*\n         * To add support for indicators like \"2nd\" and \"INV\", I use a set of flags to reflect\n         * the state of the external indicator.  They are initially undefined and will be updated\n         * by updateIndicators() whenever the internal and external states differ.\n         */\n        this.f2nd = this.fINV = this.angleMode = undefined;\n\n        /*\n         * The following set of properties are all debugger-related; see onCommand().\n         */\n        this.addrPrev = -1;\n        this.addrStop = -1;\n        this.breakConditions = {};\n        this.nStringFormat = Chip.SFORMAT.DEFAULT;\n        this.addHandler(Device.HANDLER.COMMAND, this.onCommand.bind(this));\n    }\n\n    /**\n     * checkBreakCondition(c)\n     *\n     * @this {Chip}\n     * @param {string} c\n     * @returns {boolean}\n     */\n    checkBreakCondition(c)\n    {\n        if (this.breakConditions[c]) {\n            this.breakConditions[c] = false;\n            this.println(\"break on \" + Chip.BREAK[c]);\n            this.time.stop();\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * clearDisplays()\n     *\n     * There are certain events (eg, power off, reset) where it is wise to clear all associated displays,\n     * such as the LED display, the ROM activity array (if any), and assorted calculator indicators.\n     *\n     * @this {Chip}\n     */\n    clearDisplays()\n    {\n        if (this.led) this.led.clearBuffer(true);\n        if (this.rom) this.rom.clearArray();\n        this.updateIndicators(false);\n    }\n\n    /**\n     * clocker(nCyclesTarget)\n     *\n     * NOTE: TI patents imply that the TI-57 would have a standard cycle time of 0.625us, which translates to\n     * 1,600,000 cycles per second.  However, my crude tests with a real device suggest that the TI-57 actually\n     * ran at around 40% of that speed, which is why you'll see all my configuration files specifying 650,000\n     * cycles per second instead.  But, for purposes of the following discussion, we'll continue to assume a cycle\n     * time of 0.625us.\n     *\n     * Every set of four cycles is designated a \"state time\".  Within a single state time (2.5us), the four cycles\n     * are designated Φ1, P1, Φ2, and P2.  Moreover, one state time is required to transfer 2 bits from a data word\n     * register.  Since a data word consists of 16 BCD digits (ie, 64 bits), 32 state times (80us) are required to\n     * \"clock\" all the bits from one register to another.  This total time is referred to as an instruction cycle.\n     *\n     * Note that some instructions (ie, the DISP instruction) slow the delivery of cycles, such that one state time\n     * is 10us instead of 2.5us, and therefore the entire instruction cycle will take 320us instead of 80us.\n     *\n     * We're currently simulating a full 32 \"state times\" (128 cycles aka Chip.OP_CYCLES) per instruction, since\n     * we don't perform discrete simulation of the Display Decoder/Keyboard Scanner circuitry.  See opDISP() for\n     * an example of an operation that imposes additional cycle overhead.\n     *\n     * @this {Chip}\n     * @param {number} nCyclesTarget (0 to single-step)\n     * @returns {number} (number of cycles actually \"clocked\")\n     */\n    clocker(nCyclesTarget = 0)\n    {\n        /*\n         * NOTE: We can assume that the rom exists here, because we don't call addClocker() it if doesn't.\n         */\n        this.nCyclesClocked = 0;\n        while (this.nCyclesClocked <= nCyclesTarget) {\n            if (this.addrStop == this.regPC) {\n                this.addrStop = -1;\n                this.println(\"break\");\n                this.time.stop();\n                break;\n            }\n            let opCode = this.rom.getData(this.regPC);\n            let addr = this.regPC;\n            this.regPC = (addr + 1) & this.rom.addrMask;\n            if (opCode == undefined || !this.decode(opCode, addr)) {\n                this.regPC = addr;\n                this.println(\"unimplemented opcode\");\n                this.time.stop();\n                break;\n            }\n            this.nCyclesClocked += Chip.OP_CYCLES;\n        }\n        if (nCyclesTarget <= 0) {\n            let chip = this;\n            this.time.doOutside(function clockerOutside() {\n                chip.rom.drawArray();\n                chip.println(chip.toString());\n            });\n        }\n        return this.nCyclesClocked;\n    }\n\n    /**\n     * decode(opCode, addr)\n     *\n     * Most operations are performed inline, since this isn't a super complex instruction set, but\n     * a few are separated into their own handlers (eg, opDISP).\n     *\n     * @this {Chip}\n     * @param {number} opCode (opcode)\n     * @param {number} addr (of the opcode)\n     * @returns {boolean} (true if opcode successfully decoded, false if unrecognized or unsupported)\n     */\n    decode(opCode, addr)\n    {\n        if (opCode & 0x1000) {\n            if (opCode & 0x0800) {  // BRC/BRNC\n                if (!!(opCode & 0x0400) == this.fCOND) {\n                    /*\n                     * TODO: Determine whether to use bit 10 from the original PC (addr) or the incremented PC (regPC)\n                     */\n                    this.regPC = (addr & 0x0400) | (opCode & 0x03FF);\n                }\n            } else {                // CALL\n                this.push(this.regPC);\n                this.regPC = opCode & 0x07FF;\n            }\n            this.fCOND = false;\n            return true;\n        }\n\n        let range, regSrc, regResult, iOp, base;\n        let j, k, l, n, d, b, mask = opCode & Chip.IW_MF.MASK;\n\n        switch(mask) {\n        case Chip.IW_MF.MMSD:   // 0x0000: Mantissa Most Significant Digit (D12)\n        case Chip.IW_MF.ALL:    // 0x0100: (D0-D15)\n        case Chip.IW_MF.MANT:   // 0x0200: Mantissa (D2-D12)\n        case Chip.IW_MF.MAEX:   // 0x0300: Mantissa and Exponent (D0-D12)\n        case Chip.IW_MF.LLSD:   // 0x0400: Mantissa Least Significant Digit (D2)\n        case Chip.IW_MF.EXP:    // 0x0500: Exponent (D0-D1)\n        case Chip.IW_MF.FMAEX:  // 0x0700: Flag and Mantissa and Exponent (D0-D13)\n        case Chip.IW_MF.D14:    // 0x0800: (D14)\n        case Chip.IW_MF.FLAG:   // 0x0900: (D13-D15)\n        case Chip.IW_MF.DIGIT:  // 0x0a00: (D14-D15)\n        case Chip.IW_MF.D13:    // 0x0d00: (D13)\n        case Chip.IW_MF.D15:    // 0x0f00: (D15)\n            range = Chip.RANGE[mask];\n\n\n            j = (opCode & Chip.IW_MF.J_MASK) >> Chip.IW_MF.J_SHIFT;\n            k = (opCode & Chip.IW_MF.K_MASK) >> Chip.IW_MF.K_SHIFT;\n            l = (opCode & Chip.IW_MF.L_MASK) >> Chip.IW_MF.L_SHIFT;\n            n = (opCode & Chip.IW_MF.N_MASK);\n            iOp = (n? Chip.OP.SUB : Chip.OP.ADD);\n\n            switch(k) {\n            case 0:\n            case 1:\n            case 2:\n            case 3:\n                regSrc = this.regsO[k];\n                break;\n            case 4:\n                regSrc = this.regTemp.init(1, range);\n                break;\n            case 5:\n                iOp = (n? Chip.OP.SHR : Chip.OP.SHL);\n                break;\n            case 6:\n                regSrc = this.regTemp.init(this.regR5 & 0xf, range);\n                break;\n            case 7:\n                regSrc = this.regTemp.init(this.regR5 & 0xff, range);\n                break;\n            }\n\n            switch(l) {\n            case 0:\n                regResult = this.regsO[j];\n                break;\n            case 1:\n                regResult = (k < 4? this.regsO[k] : undefined);\n                break;\n            case 2:\n                regResult = (k < 5? this.regSupp : (k == 5? this.regsO[j] : undefined));\n                break;\n            case 3:\n                if (!n) {\n\n                    this.regA.xchg(regSrc, range);\n                } else {\n\n                    this.regsO[j].move(regSrc, range);\n                }\n                return true;\n            }\n\n            if (!regResult) break;\n\n            base = (opCode >= Chip.IW_MF.D14? 16 : this.base);\n\n            switch(iOp) {\n            case Chip.OP.ADD:\n                regResult.add(this.regsO[j], regSrc, range, base);\n                break;\n            case Chip.OP.SUB:\n                regResult.sub(this.regsO[j], regSrc, range, base);\n                break;\n            case Chip.OP.SHL:\n                regResult.shl(this.regsO[j], range);\n                break;\n            case Chip.OP.SHR:\n                regResult.shr(this.regsO[j], range);\n                break;\n            }\n            return true;\n\n        case Chip.IW_MF.FF:     // 0x0c00: (used for flag operations)\n            j = (opCode & Chip.IW_FF.J_MASK) >> Chip.IW_FF.J_SHIFT;\n            d = (opCode & Chip.IW_FF.D_MASK) >> Chip.IW_FF.D_SHIFT;\n            b = 1 << ((opCode & Chip.IW_FF.B_MASK) >> Chip.IW_FF.B_SHIFT);\n            if (!d) break;\n            d += 12;\n            /*\n             * For the following bit operations (SET, RESET, TEST, and TOGGLE, displayed by disassemble()\n             * as \"SET\", \"CLR\", \"TST\", and \"NOT\") are rather trivial, so I didn't bother adding Reg64 methods\n             * for them (eg, setBit, resetBit, testBit, toggleBit).\n             */\n            switch(opCode & Chip.IW_FF.MASK) {\n            case Chip.IW_FF.SET:\n                this.regsO[j].digits[d] |= b;\n                break;\n            case Chip.IW_FF.RESET:\n                this.regsO[j].digits[d] &= ~b;\n                break;\n            case Chip.IW_FF.TEST:\n                if (this.regsO[j].digits[d] & b) this.fCOND = true;\n                break;\n            case Chip.IW_FF.TOGGLE:\n                this.regsO[j].digits[d] ^= b;\n                break;\n            }\n            return true;\n\n        case Chip.IW_MF.PF:     // 0x0e00: (used for misc operations)\n            switch(opCode & Chip.IW_PF.MASK) {\n            case Chip.IW_PF.STYA:       // 0x0000: Contents of storage register Y defined by RAB loaded into operational register A (Yn -> A)\n                this.regA.store(this.regsY[this.regRAB]);\n                break;\n            case Chip.IW_PF.RABI:       // 0x0001: Bits 4-6 of instruction are stored in RAB\n                this.regRAB = (opCode >> 4) & 0x7;\n                break;\n            case Chip.IW_PF.BRR5:       // 0x0002: Branch to R5\n                /*\n                 * TODO: Determine whether this type of BRANCH should set fCOND to false like other branches do\n                 */\n                this.regPC = this.regR5;\n                break;\n            case Chip.IW_PF.RET:        // 0x0003: Return\n                this.fCOND = false;\n                this.regPC = this.pop();\n                break;\n            case Chip.IW_PF.STAX:       // 0x0004: Contents of operational register A loaded into storage register X defined by RAB (A -> Xn)\n                this.regsX[this.regRAB].store(this.regA);\n                break;\n            case Chip.IW_PF.STXA:       // 0x0005: Contents of storage register X defined by RAB loaded into operational register A (Xn -> A)\n                this.regA.store(this.regsX[this.regRAB]);\n                break;\n            case Chip.IW_PF.STAY:       // 0x0006: Contents of operational register A loaded into storage register Y defined by RAB (A -> Yn)\n                this.regsY[this.regRAB].store(this.regA);\n                break;\n            case Chip.IW_PF.DISP:       // 0x0007: registers A and B are output to the Display Decoder and the Keyboard is scanned\n                return this.opDISP();\n            case Chip.IW_PF.BCDS:       // 0x0008: BCD set: enables BCD corrector in arithmetic unit\n                this.base = 10;\n                break;\n            case Chip.IW_PF.BCDR:       // 0x0009: BCD reset: disables BCD corrector in arithmetic unit (which then functions as hexadecimal)\n                this.base = 16;\n                break;\n            case Chip.IW_PF.RABR5:      // 0x000A: LSD of R5 (3 bits) is stored in RAB\n                this.regRAB = this.regR5 & 0x7;\n                break;\n            default:\n                return false;\n            }\n            return true;\n\n        case Chip.IW_MF.RES1:   // 0x0600: (reserved)\n        case Chip.IW_MF.RES2:   // 0x0b00: (reserved)\n        default:\n            break;\n        }\n        return false;\n    }\n\n    /**\n     * disassemble(opCode, addr, fCompact)\n     *\n     * Returns a string representation of the selected instruction.\n     *\n     * The TI-57 patents suggest mnemonics for some of the instructions, but not all, so I've taken\n     * some liberties in the interests of clarity and familiarity.  Special-purpose instructions like\n     * \"BCDS\" and \"BCDR\" are displayed as-is, but for more general-purpose instructions, I've adopted\n     * the following format:\n     *\n     *      operation   destination,input(s)[,mask]\n     *\n     * Instructions that the patent refers to as \"STYA\", \"STAY\", \"STXA\", and \"STAX\" are all displayed\n     * as \"STORE\" instructions; eg, instead of \"STAX\", I use:\n     *\n     *      STORE       X[RAB],A\n     *\n     * Instructions that use masks are displayed as either \"LOAD\", \"MOVE\", or \"XCHG\".  If the result\n     * of the operation is suppressed, the destination will be displayed as \"NUL\" instead of a register.\n     * And if the inputs are being added, subtracted, shifted left, or shifted right, they will be\n     * displayed with \"+\", \"-\", \"<<\", or \">>\", respectively.  Finally, the 16-digit mask is displayed,\n     * as a series of hex digits rather than the unmemorable names used in the patents (eg, MMSD, FMAEX,\n     * etc).  I do use the patent nomenclature internally, just not for display purposes.\n     *\n     * @this {Chip}\n     * @param {number|undefined} opCode\n     * @param {number} addr\n     * @param {boolean} [fCompact]\n     * @returns {string}\n     */\n    disassemble(opCode, addr, fCompact = false)\n    {\n        let sOp = \"???\", sOperands = \"\";\n\n        if (opCode & 0x1000) {\n            let v;\n            if (opCode & 0x0800) {\n                sOp = \"BR\";\n                if (opCode & 0x0400) {\n                    sOp += \"C\";\n                } else {\n                    sOp += \"NC\";\n                }\n                v = (addr & 0x0400) | (opCode & 0x03FF);\n            } else {\n                sOp = \"CALL\";\n                v = opCode & 0x07FF;\n            }\n            sOperands = this.sprintf(\"0x%04x\", v);\n        }\n        else if (opCode >= 0) {\n            let mask = opCode & Chip.IW_MF.MASK;\n\n            switch(mask) {\n            case Chip.IW_MF.MMSD:   // 0x0000: Mantissa Most Significant Digit (D12)\n            case Chip.IW_MF.ALL:    // 0x0100: (D0-D15)\n            case Chip.IW_MF.MANT:   // 0x0200: Mantissa (D2-D12)\n            case Chip.IW_MF.MAEX:   // 0x0300: Mantissa and Exponent (D0-D12)\n            case Chip.IW_MF.LLSD:   // 0x0400: Mantissa Least Significant Digit (D2)\n            case Chip.IW_MF.EXP:    // 0x0500: Exponent (D0-D1)\n            case Chip.IW_MF.FMAEX:  // 0x0700: Flag and Mantissa and Exponent (D0-D13)\n            case Chip.IW_MF.D14:    // 0x0800: (D14)\n            case Chip.IW_MF.FLAG:   // 0x0900: (D13-D15)\n            case Chip.IW_MF.DIGIT:  // 0x0a00: (D14-D15)\n            case Chip.IW_MF.D13:    // 0x0d00: (D13)\n            case Chip.IW_MF.D15:    // 0x0f00: (D15)\n                let sMask = this.toStringMask(mask);\n                let j = (opCode & Chip.IW_MF.J_MASK) >> Chip.IW_MF.J_SHIFT;\n                let k = (opCode & Chip.IW_MF.K_MASK) >> Chip.IW_MF.K_SHIFT;\n                let l = (opCode & Chip.IW_MF.L_MASK) >> Chip.IW_MF.L_SHIFT;\n                let n = (opCode & Chip.IW_MF.N_MASK);\n\n                sOp = \"LOAD\";\n                let sOperator = \"\";\n                let sDst = \"?\", sSrc = \"?\";\n\n                if (!n) {\n                    sOperator = (k == 5? \"<<\" : \"+\");\n                } else {\n                    sOperator = (k == 5? \">>\" : \"-\");\n                }\n\n                switch(l) {\n                case 0:\n                    sDst = Chip.OP_INPUTS[j];\n                    break;\n                case 1:\n                    if (k < 4) sDst = Chip.OP_INPUTS[k];\n                    break;\n                case 2:\n                    if (k < 6) sDst = \"NUL\";    // \"suppressed\" operation\n                    break;\n                case 3:\n                    if (!n) {\n                        sOp = \"XCHG\";\n                        if (!j) sDst = \"A\";     // j != 0 or k >= 4 is invalid\n                        if (k < 4) sSrc = Chip.OP_INPUTS[k];\n                    } else {\n                        sOp = \"MOVE\";\n                        sDst = Chip.OP_INPUTS[j];\n                        sSrc = Chip.OP_INPUTS[k]; // k == 5 is invalid\n                    }\n                    k = -1;\n                    break;\n                }\n\n                switch(k) {\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                    sSrc = Chip.OP_INPUTS[j] + sOperator + Chip.OP_INPUTS[k];\n                    break;\n                case 4:\n                case 5:\n                    sSrc = Chip.OP_INPUTS[j] + sOperator + \"1\";\n                    break;\n                case 6:\n                    sSrc = Chip.OP_INPUTS[j] + sOperator + \"R5L\";\n                    break;\n                case 7:\n                    sSrc = Chip.OP_INPUTS[j] + sOperator + \"R5\";\n                    break;\n                }\n                sOperands = sDst + \",\" + sSrc + \",\" + sMask;\n                break;\n\n            case Chip.IW_MF.FF:     // 0x0c00: (used for flag operations)\n                switch(opCode & Chip.IW_FF.MASK) {\n                case Chip.IW_FF.SET:\n                    sOp = \"SET\";\n                    break;\n                case Chip.IW_FF.RESET:\n                    sOp = \"CLR\";\n                    break;\n                case Chip.IW_FF.TEST:\n                    sOp = \"TST\";\n                    break;\n                case Chip.IW_FF.TOGGLE:\n                    sOp = \"NOT\";\n                    break;\n                }\n                sOperands = this.regsO[(opCode & Chip.IW_FF.J_MASK) >> Chip.IW_FF.J_SHIFT].name;\n                let d = ((opCode & Chip.IW_FF.D_MASK) >> Chip.IW_FF.D_SHIFT);\n                sOperands += '[' + (d? (d + 12) : '?') + ':' + ((opCode & Chip.IW_FF.B_MASK) >> Chip.IW_FF.B_SHIFT) + ']';\n                break;\n\n            case Chip.IW_MF.PF:     // 0x0e00: (used for misc operations)\n                let sStore = \"STORE\";\n                switch(opCode & Chip.IW_PF.MASK) {\n                case Chip.IW_PF.STYA:   // 0x0000: Contents of storage register Y defined by RAB loaded into operational register A (Yn -> A)\n                    sOp = sStore;\n                    sOperands = \"A,Y[RAB]\";\n                    break;\n                case Chip.IW_PF.RABI:   // 0x0001: Bits 4-6 of instruction are stored in RAB\n                    sOp = sStore;\n                    sOperands = \"RAB,\" + ((opCode & 0x70) >> 4);\n                    break;\n                case Chip.IW_PF.BRR5:   // 0x0002: Branch to R5\n                    sOp = \"BR\";\n                    sOperands = \"R5\";\n                    break;\n                case Chip.IW_PF.RET:    // 0x0003: Return\n                    sOp = \"RET\";\n                    break;\n                case Chip.IW_PF.STAX:   // 0x0004: Contents of operational register A loaded into storage register X defined by RAB (A -> Xn)\n                    sOp = sStore;\n                    sOperands = \"X[RAB],A\";\n                    break;\n                case Chip.IW_PF.STXA:   // 0x0005: Contents of storage register X defined by RAB loaded into operational register A (Xn -> A)\n                    sOp = sStore;\n                    sOperands = \"A,X[RAB]\";\n                    break;\n                case Chip.IW_PF.STAY:   // 0x0006: Contents of operational register A loaded into storage register Y defined by RAB (A -> Yn)\n                    sOp = sStore;\n                    sOperands = \"Y[RAB],A\";\n                    break;\n                case Chip.IW_PF.DISP:   // 0x0007: registers A and B are output to the Display Decoder and the Keyboard is scanned\n                    sOp = \"DISP\";\n                    break;\n                case Chip.IW_PF.BCDS:   // 0x0008: BCD set: enables BCD corrector in arithmetic unit\n                    sOp = \"BCDS\";\n                    break;\n                case Chip.IW_PF.BCDR:   // 0x0009: BCD reset: disables BCD corrector in arithmetic unit (which then functions as hexadecimal)\n                    sOp = \"BCDR\";\n                    break;\n                case Chip.IW_PF.RABR5:  // 0x000A: LSD of R5 (3 bits) is stored in RAB\n                    sOp = sStore;\n                    sOperands = \"RAB,R5L\";\n                    break;\n                default:\n                    break;\n                }\n                break;\n\n            case Chip.IW_MF.RES1:   // 0x0600: (reserved)\n            case Chip.IW_MF.RES2:   // 0x0b00: (reserved)\n            default:\n                break;\n            }\n        }\n        return this.sprintf(fCompact? \"%03X %04X\\n\" : \"0x%04x: 0x%04x  %-8s%s\\n\", addr, opCode, sOp, sOperands);\n    }\n\n    /**\n     * loadState(state)\n     *\n     * If any saved values don't match (possibly overridden), abandon the given state and return false.\n     * \n     * @this {Chip}\n     * @param {Object|Array|null} state\n     * @returns {boolean}\n     */\n    loadState(state)\n    {\n        if (state) {\n            let stateChip = state['stateChip'] || state[0];\n            if (!stateChip || !stateChip.length) {\n                this.println(\"Invalid saved state\");\n                return false;\n            }\n            let version = stateChip.shift();\n            if ((version|0) !== (Chip.VERSION|0)) {\n                this.printf(\"Saved state version mismatch: %3.2f\\n\", version);\n                return false;\n            }\n            try {\n                this.regsO.forEach(reg => reg.set(stateChip.shift()));\n                this.regsX.forEach(reg => reg.set(stateChip.shift()));\n                this.regsY.forEach(reg => reg.set(stateChip.shift()));\n                this.regSupp.set(stateChip.shift());\n                this.regTemp.set(stateChip.shift());\n                this.base = stateChip.shift();\n                this.fCOND = stateChip.shift();\n                this.regRAB = stateChip.shift();\n                this.regR5 = stateChip.shift();\n                this.regPC = stateChip.shift();\n                this.stack = stateChip.shift();\n                this.regKey = stateChip.shift();\n            } catch(err) {\n                this.println(\"Chip state error: \" + err.message);\n                return false;\n            }\n            let stateROM = state['stateROM'] || state[1];\n            if (stateROM && this.rom) {\n                if (!this.rom.loadState(stateROM)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * onCommand(aTokens, machine)\n     *\n     * Processes commands for our \"mini-debugger\".\n     *\n     * @this {Chip}\n     * @param {Array.<string>} aTokens\n     * @param {Device} [machine]\n     * @returns {boolean} (true if processed, false if not)\n     */\n    onCommand(aTokens, machine)\n    {\n        let sResult = \"\";\n        let s = aTokens[1];\n        let addr = Number.parseInt(aTokens[2], 16);\n        if (isNaN(addr)) addr = -1;\n        let nWords = Number.parseInt(aTokens[3], 10) || 8;\n\n        this.nStringFormat = Chip.SFORMAT.DEFAULT;\n        \n        switch(s[0]) {\n        case 'b':\n            let c = s.substr(1);\n            let condition;\n            if (c == 'l') {\n                for (c in Chip.BREAK) {\n                    condition = Chip.BREAK[c];\n                    sResult += \"break on \" + condition + \" (b\" + c + \"): \" + (this.breakConditions[c] || false) + '\\n';\n                }\n                break;\n            }\n            condition = Chip.BREAK[c];\n            if (condition) {\n                this.breakConditions[c] = !this.breakConditions[c];\n                sResult = \"break on \" + condition + \" (b\" + c + \"): \" + this.breakConditions[c];\n            } else {\n                if (c) sResult = \"unrecognized break option '\" + c + \"'\";\n            }\n            break;\n\n        case 'g':\n            if (this.time.start()) {\n                this.addrStop = addr;\n            } else {\n                sResult = \"already started\";\n            }\n            break;\n\n        case 'h':\n            if (!this.time.stop()) sResult = \"already stopped\";\n            break;\n\n        case 't':\n            if (s[1] == 'c') this.nStringFormat = Chip.SFORMAT.COMPACT;\n            nWords = Number.parseInt(aTokens[2], 10) || 1;\n            this.time.onStep(nWords);\n            if (machine) machine.sCommandPrev = aTokens[0];\n            break;\n\n        case 'r':\n            if (s[1] == 'c') this.nStringFormat = Chip.SFORMAT.COMPACT;\n            this.setRegister(s.substr(1), addr);\n            sResult += this.toString(s[1]);\n            if (machine) machine.sCommandPrev = aTokens[0];\n            break;\n\n        case 'u':\n            addr = (addr >= 0? addr : (this.addrPrev >= 0? this.addrPrev : this.regPC));\n            while (nWords--) {\n                let opCode = this.rom && this.rom.getData(addr, true);\n                if (opCode == undefined) break;\n                sResult += this.disassemble(opCode, addr++);\n            }\n            this.addrPrev = addr;\n            if (machine) machine.sCommandPrev = aTokens[0];\n            break;\n\n        case '?':\n            sResult = \"additional commands:\";\n            Chip.COMMANDS.forEach(cmd => {sResult += '\\n' + cmd;});\n            break;\n\n        default:\n            if (aTokens[0]) {\n                sResult = \"unrecognized command '\" + aTokens[0] + \"' (try '?')\";\n            }\n            break;\n        }\n        if (sResult) this.println(sResult.trim());\n        return true;\n    }\n\n    /**\n     * onInput(col, row)\n     *\n     * Called by the Input device to provide notification of key presses and releases.\n     *\n     * Converts a logical (col,row), where the top left keyboard position is (0,0), into an 8-bit physical\n     * location value, where bits 0-3 are the row (0-based) and bits 4-7 are the col (1-based).  Moreover,\n     * if either col or row is negative, then all bits are cleared.\n     *\n     * @this {Chip}\n     * @param {number} col\n     * @param {number} row\n     */\n    onInput(col, row)\n    {\n        let b = 0;\n        if (col >= 0 && row >= 0) {\n\n            b = row | ((col + 1) << 4);\n        }\n        this.regKey = b;\n    }\n\n    /**\n     * onLoad()\n     *\n     * Automatically called by the Machine device after all other devices have been powered up (eg, during\n     * a page load event) AND the machine's 'autoRestore' property is true.  It is called BEFORE onPower().\n     *\n     * @this {Chip}\n     */\n    onLoad()\n    {\n        this.loadState(this.loadLocalStorage());\n    }\n\n    /**\n     * onPower(fOn)\n     *\n     * Automatically called by the Machine device after all other devices have been powered up (eg, during\n     * a page load event) AND the machine's 'autoStart' property is true, with fOn set to true.  It is also\n     * called before all devices are powered down (eg, during a page unload event), with fOn set to false.\n     *\n     * May subsequently be called by the Input device to provide notification of a user-initiated power event\n     * (eg, toggling a power button); in this case, fOn should NOT be set, so that no state is loaded or saved.\n     *\n     * @this {Chip}\n     * @param {boolean} [fOn] (true to power on, false to power off; otherwise, toggle it)\n     */\n    onPower(fOn)\n    {\n        if (fOn == undefined) {\n            fOn = !this.time.isRunning();\n            if (fOn) this.regPC = 0;\n        }\n        if (fOn) {\n            this.time.start();\n        } else {\n            this.time.stop();\n            this.clearDisplays();\n        }\n    }\n\n    /**\n     * onReset()\n     *\n     * Called by the Input device to provide notification of a reset event.\n     *\n     * @this {Chip}\n     */\n    onReset()\n    {\n        this.println(\"reset\");\n        this.regPC = 0;\n        this.clearDisplays();\n        if (!this.time.isRunning()) {\n            this.status();\n        }\n    }\n\n    /**\n     * onSave()\n     *\n     * Automatically called by the Machine device before all other devices have been powered down (eg, during\n     * a page unload event).\n     *\n     * @this {Chip}\n     */\n    onSave()\n    {\n        this.saveLocalStorage(this.saveState());\n    }\n\n    /**\n     * opDISP()\n     *\n     * Handles the DISP opcode.  The following details/tables are from the TI patents:\n     *\n     *      Register A and Register B are outputted to the display decoder and the keyboard is scanned.\n     *      A closed keyboard switch loads K5 and sets condition latch.\n     *\n     *      Display decoder receives a data representing numerals to be displayed from operational register A.\n     *\n     *      Display decoder is also responsive to the data from operational register B, which indicates where\n     *      the decimal point is to be displayed among the numerals, whether minus signs are to be provided,\n     *      and which digits are to be blanked, according to the codes listed in Table III.\n     *\n     *      TABLE II\n     *\n     *          Register R5\n     *          --------------------------------\n     *             7   6   5   4   3   2   1   0\n     *           KR8 KR7 KR6 KR5 KR4 KR3 KR2 KR1\n     *\n     *            K             KS (Keyboard Line Actuated)\n     *          -------------------------------------------\n     *           001            K1\n     *           010            K2\n     *           011            K3\n     *           100            K4\n     *           101            K5\n     *\n     *            K             KS (Segment Scan Line Actuated)\n     *          -----------------------------------------------\n     *           000            KS0     (SEG E)\n     *           001            KS1     (SEG F)\n     *           010            KS2     (SEG B)\n     *           011            KS3     (SEG G)\n     *           100            KS4     (SEG C)\n     *           101            KS5     (SEG A)\n     *           110            KS6     (SEG D/D12)\n     *\n     *      TABLE III\n     *\n     *          Register B\n     *          Control Code    Function\n     *          ------------    ------------------------------------------------------------\n     *           1XXX           Display digit is blanked in the corresponding digit position\n     *           0XX1           Turns on minus sign (Segment G) in corresponding digit position\n     *           XX1X           Turns on decimal point and digit specified by register A in corresponding digit position\n     *           0XX0           Turns on digit specified by Register A in corresponding digit position\n     *\n     * @this {Chip}\n     * @returns {boolean} (true to indicate the opcode was successfully decoded)\n     */\n    opDISP()\n    {\n        this.checkBreakCondition('o');\n\n        if (this.led) {\n            for (let col = 0, iDigit = 11; iDigit >= 0; col++, iDigit--) {\n                let ch;\n                if (this.regB.digits[iDigit] & 0x8) {\n                    ch = ' ';\n                }\n                else if (this.regB.digits[iDigit] & 0x1) {\n                    ch = '-';\n                }\n                else {\n                    ch = Device.HexUpperCase[this.regA.digits[iDigit]];\n                }\n                if (this.led.setLEDState(col, 0, ch, (this.regB.digits[iDigit] & 0x2)? LED.FLAGS.PERIOD : 0)) {\n                    this.checkBreakCondition('om');\n                }\n            }\n            this.updateIndicators();\n        }\n\n        /*\n         * The TI patents indicate that DISP operations slow the clock by a factor of 4, and on top of\n         * that, the display scan generator uses a HOLD signal to prevent the Program Counter from being\n         * incremented while it cycles through all 8 possible segments for all digits, so the total delay\n         * imposed by DISP is a factor of 32.  Since every instruction already accounts for OP_CYCLES once,\n         * I need to account for it here 31 more times.\n         */\n        this.nCyclesClocked += Chip.OP_CYCLES * 31;\n\n        if (this.regKey) {\n            this.regR5 = this.regKey;\n            this.fCOND = true;\n            this.checkBreakCondition('i');\n        }\n\n        return true;\n    }\n\n    /**\n     * pop()\n     *\n     * @this {Chip}\n     * @returns {number}\n     */\n    pop()\n    {\n        /*\n         * Normally, you would simply decrement a stack pointer, but that's not how this stack was implemented.\n         */\n        let addr = this.stack[0];\n        let i = 0, j = this.stack.length - 1;\n        while (i < j) this.stack[i] = this.stack[++i];\n        this.stack[i] = -1;\n\n        return addr;\n    }\n\n    /**\n     * push(addr)\n     *\n     * @this {Chip}\n     * @param {number} addr\n     */\n    push(addr)\n    {\n        /*\n         * Normally, you would simply increment a stack pointer, but that's not how this stack was implemented.\n         */\n        let i = this.stack.length - 1;\n        /*\n         * Apparently, legitimate values are allowed to fall off the end of the stack, so we can't assert overflow.\n         *\n         *\n         */\n        while (i > 0) this.stack[i] = this.stack[--i];\n        this.stack[0] = addr;\n    }\n\n    /**\n     * saveState()\n     *\n     * @this {Chip}\n     * @returns {Array}\n     */\n    saveState()\n    {\n        let state = [[],[]];\n        let stateChip = state[0];\n        let stateROM = state[1];\n        stateChip.push(Chip.VERSION);\n        this.regsO.forEach(reg => stateChip.push(reg.get()));\n        this.regsX.forEach(reg => stateChip.push(reg.get()));\n        this.regsY.forEach(reg => stateChip.push(reg.get()));\n        stateChip.push(this.regSupp.get());\n        stateChip.push(this.regTemp.get());\n        stateChip.push(this.base);\n        stateChip.push(this.fCOND);\n        stateChip.push(this.regRAB);\n        stateChip.push(this.regR5);\n        stateChip.push(this.regPC);\n        stateChip.push(this.stack);\n        stateChip.push(this.regKey);\n        if (this.rom) this.rom.saveState(stateROM);\n        return state;\n    }\n\n    /**\n     * setRegister(name, value)\n     *\n     * @this {Chip}\n     * @param {string} name\n     * @param {number} value\n     */\n    setRegister(name, value)\n    {\n        if (!name || value < 0) return;\n\n        switch(name) {\n        case \"pc\":\n            this.regPC = value;\n            break;\n        default:\n            this.println(\"unrecognized register: \" + name);\n            break;\n        }\n    }\n    /**\n     * status()\n     *\n     * This is called by the Machine after all the individual devices have been initialized.\n     *\n     * @this {Chip}\n     */\n    status()\n    {\n        this.println(this.toString());\n    }\n\n    /**\n     * toString(options, regs)\n     *\n     * @this {Chip}\n     * @param {string} [options]\n     * @param {Array.<Reg64>} [regs]\n     * @returns {string}\n     */\n    toString(options = \"\", regs = null)\n    {\n        let s = \"\";\n        if (this.nStringFormat) {\n            if (this.rom) {\n                s += this.disassemble(this.rom.getData(this.regPC, true), this.regPC, true);\n            }\n            s += \"  \";\n            for (let i = 0, n = this.regsO.length; i < n; i++) {\n                s += this.regsO[i].toString() + ' ';\n            }\n            s += \"\\n \";\n            s += \" COND=\" + (this.fCOND? 1 : 0);\n            s += \" BASE=\" + this.base;\n            s += \" R5=\" + this.sprintf(\"%02X\", this.regR5);\n            s += \" RAB=\" + this.regRAB + \" ST=\";\n            this.stack.forEach((addr, i) => {s += this.sprintf(\"%03X \", (addr < 0? 0 : (addr & 0xfff)));});\n            return s.trim();\n        }\n        if (regs) {\n            for (let i = 0, n = regs.length >> 1; i < n; i++) {\n                s += regs[i].toString(true) + '  ' + regs[i+n].toString(true) + '\\n';\n            }\n            return s;\n        }\n        s += this.toString(options, this.regsO);\n        if (options.indexOf('a') >= 0) {\n            s += this.toString(options, this.regsX);\n            s += this.toString(options, this.regsY);\n        }\n        s += \"COND=\" + (this.fCOND? 1 : 0);\n        s += \" BASE=\" + this.base;\n        s += \" R5=\" + this.sprintf(\"0x%02x\", this.regR5);\n        s += \" RAB=\" + this.regRAB + ' ';\n        this.stack.forEach((addr, i) => {s += this.sprintf(\"ST%d=0x%04x \", i, addr & 0xffff);});\n        if (this.rom) {\n            s += '\\n' + this.disassemble(this.rom.getData(this.regPC, true), this.regPC);\n        }\n        this.addrPrev = this.regPC;\n        return s.trim();\n    }\n\n    /**\n     * toStringMask(mask)\n     *\n     * @this {Chip}\n     * @param {number} mask\n     * @returns {string}\n     */\n    toStringMask(mask)\n    {\n        let s = \"\";\n        let range = Chip.RANGE[mask];\n        for (let i = 0; i < 16; i++) {\n            if (!(i % 4)) s = ' ' + s;\n            s = (range? (i >= range[0] && i <= range[1]? 'F' : '0') : '?') + s;\n        }\n        return s;\n    }\n\n    /**\n     * updateIndicators(on)\n     *\n     * I made the following observations while running the TI-57's 1501 ROM:\n     *\n     *      \"2nd\"   C[14] bit 3 set\n     *      \"INV\"   B[15] bit 2 set\n     *      \"Deg\"   X4[15] == 0x0\n     *      \"Rad\"   X4[15] == 0x4\n     *      \"Grad\"  X4[15] == 0xC\n     *\n     * Similarly, for the TI-55's 1503 ROM:\n     *\n     *      \"2nd\"   B[15] bit 2 set\n     *      \"INV\"   D[15] bit 3 set\n     *      \"Deg\"   C[15] == 0x0\n     *      \"Rad\"   C[15] == 0x1\n     *      \"Grad\"  C[15] == 0x2\n     *\n     * If this is the first time any of the indicator properties (ie, f2nd, fINV, or angleMode) have been initialized,\n     * we will also propagate the LED display color (this.led.color) to the indicator's color, so that the colors of all\n     * the elements overlaid on the display match.\n     *\n     * NOTE: These indicators are specific to locations chosen by the ROM, not by the chip's hardware, but since the\n     * ROMs are closely tied to their respective chips, I'm going to cheat and just check the chip type.\n     *\n     * @this {Chip}\n     * @param {boolean} [on] (default is true, to display all active indicators; set to false to force all indicators off)\n     */\n    updateIndicators(on = true)\n    {\n        let element;\n        let f2nd = on && (this.type == Chip.TYPE.TMS1501? !!(this.regC.digits[14] & 0x8) : !!(this.regB.digits[15] & 0x4));\n        if (this.f2nd !== f2nd) {\n            if (element = this.bindings['2nd']) {\n                element.style.opacity = f2nd? \"1\" : \"0\";\n                if (this.f2nd === undefined && this.led) element.style.color = this.led.color;\n            }\n            this.f2nd = f2nd;\n        }\n        let fINV = on && (this.type == Chip.TYPE.TMS1501? !!(this.regB.digits[15] & 0x4) : !!(this.regD.digits[15] & 0x8));\n        if (this.fINV !== fINV) {\n            if (element = this.bindings['INV']) {\n                element.style.opacity = fINV? \"1\" : \"0\";\n                if (this.fINV === undefined && this.led) element.style.color = this.led.color;\n            }\n            this.fINV = fINV;\n        }\n        let angleBits = (this.type == Chip.TYPE.TMS1501? (this.regsX[4].digits[15] >> 2) : this.regC.digits[15]);\n        let angleMode = on? ((!angleBits)? Chip.ANGLEMODE.DEGREES : (angleBits == 1)? Chip.ANGLEMODE.RADIANS : Chip.ANGLEMODE.GRADIENTS) : Chip.ANGLEMODE.OFF;\n        if (this.angleMode !== angleMode) {\n            if (element = this.bindings['Deg']) {\n                element.style.opacity = (angleMode == Chip.ANGLEMODE.DEGREES)? \"1\" : \"0\";\n                if (this.angleMode === undefined && this.led) element.style.color = this.led.color;\n            }\n            if (element = this.bindings['Rad']) {\n                element.style.opacity = (angleMode == Chip.ANGLEMODE.RADIANS)? \"1\" : \"0\";\n                if (this.angleMode === undefined && this.led) element.style.color = this.led.color;\n            }\n            if (element = this.bindings['Grad']) {\n                element.style.opacity = (angleMode == Chip.ANGLEMODE.GRADIENTS)? \"1\" : \"0\";\n                if (this.angleMode === undefined && this.led) element.style.color = this.led.color;\n            }\n            this.angleMode = angleMode;\n        }\n    }\n\n    /**\n     * updateStatus(fTransition)\n     *\n     * Enumerate all bindings and update their values.\n     *\n     * Called by Time's updateStatus() function whenever 1) its YIELDS_PER_UPDATE threshold is reached\n     * (default is twice per second), 2) a step() operation has just finished (ie, the device is being\n     * single-stepped), and 3) a start() or stop() transition has occurred.\n     *\n     * @this {Chip}\n     * @param {boolean} [fTransition]\n     */\n    updateStatus(fTransition)\n    {\n        for (let binding in this.bindings) {\n            let regMap = this.regMap[binding];\n            if (regMap) {\n                let sValue;\n                let reg = regMap[0];\n                let digit = regMap[1];\n                if (digit < 0) {\n                    sValue = reg.toString();\n                } else {\n                    sValue = Device.HexUpperCase[reg.digits[digit]];\n                }\n                this.setBindingText(binding, sValue);\n            }\n        }\n        if (fTransition || !this.time.isRunning()) {\n            this.rom.drawArray();\n            this.println(this.toString());\n        }\n    }\n}\n\nChip.IW_MF = {          // Instruction Word Mask Field\n    MASK:   0x0F00,\n    MMSD:   0x0000,     // Mantissa Most Significant Digit (D12)\n    ALL:    0x0100,     // (D0-D15)\n    MANT:   0x0200,     // Mantissa (D2-D12)\n    MAEX:   0x0300,     // Mantissa and Exponent (D0-D12)\n    LLSD:   0x0400,     // Mantissa Least Significant Digit (D2)\n    EXP:    0x0500,     // Exponent (D0-D1)\n    RES1:   0x0600,     // (reserved)\n    FMAEX:  0x0700,     // Flag and Mantissa and Exponent (D0-D13)\n    D14:    0x0800,     // (D14)\n    FLAG:   0x0900,     // (D13-D15)\n    DIGIT:  0x0A00,     // (D14-D15)\n    RES2:   0x0B00,     // (reserved)\n    FF:     0x0C00,     // FF used for additional instruction decoding\n    D13:    0x0D00,     // (D13)\n    PF:     0x0E00,     // PF used for additional instruction decoding\n    D15:    0x0F00,     // (D15)\n    J_MASK: 0x00C0,\n    J_SHIFT:     6,\n    K_MASK: 0x0038,\n    K_SHIFT:     3,\n    L_MASK: 0x0006,\n    L_SHIFT:     1,\n    N_MASK: 0x0001\n};\n\nChip.IW_FF = {          // Instruction Word Flag Field (used when the Mask Field is FF)\n    MASK:   0x0003,\n    SET:    0x0000,\n    RESET:  0x0001,\n    TEST:   0x0002,\n    TOGGLE: 0x0003,\n    J_MASK: 0x00C0,\n    J_SHIFT:     6,\n    D_MASK: 0x0030,\n    D_SHIFT:     4,\n    B_MASK: 0x000C,\n    B_SHIFT:     2,\n};\n\nChip.IW_PF = {          // Instruction Word Misc Field (used when the Mask Field is PF)\n    MASK:   0x000F,\n    STYA:   0x0000,     // Contents of storage register Y defined by RAB loaded into operational register A (Yn -> A)\n    RABI:   0x0001,     // Bits 4-6 of instruction are stored in RAB\n    BRR5:   0x0002,     // Branch to R5\n    RET:    0x0003,     // Return\n    STAX:   0x0004,     // Contents of operational register A loaded into storage register X defined by RAB (A -> Xn)\n    STXA:   0x0005,     // Contents of storage register X defined by RAB loaded into operational register A (Xn -> A)\n    STAY:   0x0006,     // Contents of operational register A loaded into storage register Y defined by RAB (A -> Yn)\n    DISP:   0x0007,     // registers A and B are output to the Display Decoder and the Keyboard is scanned\n    BCDS:   0x0008,     // BCD set: enables BCD corrector in arithmetic unit\n    BCDR:   0x0009,     // BCD reset: disables BCD corrector in arithmetic unit (which then functions as hexadecimal)\n    RABR5:  0x000A,     // LSD of R5 (3 bits) is stored in RAB\n    RES1:   0x000B,     // (reserved)\n    RES2:   0x000C,     // (reserved)\n    RES3:   0x000D,     // (reserved)\n    RES4:   0x000E,     // (reserved)\n    RES5:   0x000F      // (reserved)\n};\n\nChip.RANGE = {\n    [Chip.IW_MF.MMSD]:  [12,12],        // 0x0000: Mantissa Most Significant Digit (D12)\n    [Chip.IW_MF.ALL]:   [0,15],         // 0x0100: (D0-D15)\n    [Chip.IW_MF.MANT]:  [2,12],         // 0x0200: Mantissa (D2-D12)\n    [Chip.IW_MF.MAEX]:  [0,12],         // 0x0300: Mantissa and Exponent (D0-D12)\n    [Chip.IW_MF.LLSD]:  [2,2],          // 0x0400: Mantissa Least Significant Digit (D2)\n    [Chip.IW_MF.EXP]:   [0,1],          // 0x0500: Exponent (D0-D1)\n    [Chip.IW_MF.FMAEX]: [0,13],         // 0x0700: Flag and Mantissa and Exponent (D0-D13)\n    [Chip.IW_MF.D14]:   [14,14],        // 0x0800: (D14)\n    [Chip.IW_MF.FLAG]:  [13,15],        // 0x0900: (D13-D15)\n    [Chip.IW_MF.DIGIT]: [14,15],        // 0x0a00: (D14-D15)\n    [Chip.IW_MF.D13]:   [13,13],        // 0x0d00: (D13)\n    [Chip.IW_MF.D15]:   [15,15],        // 0x0f00: (D15)\n};\n\nChip.OP_CYCLES = 128;                   // default number of cycles per instruction\n\n/*\n * Table of operations used by the disassembler for \"masked\" operations\n */\nChip.OP = {\n    ADD:    0,\n    SUB:    1,\n    SHL:    2,\n    SHR:    3,\n    XCHG:   4,\n    MOVE:   5\n};\n\nChip.TYPE = {\n    TMS1501:    1501,       // aka TI-57\n    TMS1502:    1502,       // aka TI-42 (\"MBA\")\n    TMS1503:    1503        // aka TI-55\n};\n\nChip.ANGLEMODE = {\n    OFF:        0,\n    DEGREES:    1,\n    RADIANS:    2,\n    GRADIENTS:  3\n};\n\nChip.BREAK = {\n    'i':    \"input\",\n    'o':    \"output\",\n    'om':   \"output modification\"\n};\n\nChip.SFORMAT = {\n    DEFAULT:    0,\n    COMPACT:    1\n};\n\n/*\n * Table of operational inputs used by the disassembler for \"masked\" operations\n */\nChip.OP_INPUTS = [\"A\",\"B\",\"C\",\"D\",\"1\",\"?\",\"R5L\",\"R5\"];\n\nChip.COMMANDS = [\n    \"b[c]\\t\\tbreak on condition c\",\n    \"bl\\t\\tlist break conditions\",\n    \"g [addr]\\trun (to addr)\",\n    \"h\\t\\thalt\",\n    \"r[a]\\t\\tdump (all) registers\",\n    \"t [n]\\t\\tstep (n instructions)\",\n    \"u [addr] [n]\\tdisassemble (at addr)\"\n];\n\nChip.VERSION = +VERSION || 1.20;\n\nMACHINE = \"TMS1500\";\n\n/**\n * @copyright https://www.pcjs.org/modules/devices/machine.js (C) Jeff Parsons 2012-2018\n */\n\n/**\n * @class {Machine}\n * @unrestricted\n * @property {Chip} chip\n * @property {string} sConfigFile\n * @property {boolean} fConfigLoaded\n * @property {boolean} fPageLoaded\n */\nclass Machine extends Device {\n    /**\n     * Machine(idMachine, sConfig)\n     * \n     * If sConfig contains a JSON object definition, then we parse it immediately and save the result in this.config;\n     * otherwise, we assume it's the URL of an JSON object definition, so we request the resource, and once it's loaded,\n     * we parse it.\n     * \n     * Sample config:\n     *\n     *    {\n     *      \"ti57\": {\n     *        \"class\": \"Machine\",\n     *        \"type\": \"TI57\",\n     *        \"name\": \"TI-57 Programmable Calculator Simulation\",\n     *        \"version\": 1.10,\n     *        \"autoStart\": true,\n     *        \"autoRestore\": true,\n     *        \"bindings\": {\n     *          \"clear\": \"clearTI57\",\n     *          \"print\": \"printTI57\"\n     *        }\n     *      },\n     *      \"chip\": {\n     *        \"class\": \"Chip\",\n     *        \"type\": \"TMS-1500\",\n     *        \"input\": \"buttons\",\n     *        \"output\": \"display\"\n     *      },\n     *      \"clock\": {\n     *        \"class\": \"Time\",\n     *        \"cyclesPerSecond\": 650000\n     *        \"bindings\": {\n     *          \"run\": \"runTI57\",\n     *          \"speed\": \"speedTI57\",\n     *          \"step\": \"stepTI57\"\n     *        },\n     *        \"overrides\": [\"cyclesPerSecond\"]\n     *      },\n     *      \"display\": {\n     *        \"class\": \"LED\",\n     *        \"type\": 3,\n     *        \"cols\": 12,\n     *        \"rows\": 1,\n     *        \"color\": \"red\",\n     *        \"bindings\": {\n     *          \"container\": \"displayTI57\"\n     *        },\n     *        \"overrides\": [\"color\",\"backgroundColor\"]\n     *      },\n     *      \"buttons\": {\n     *        \"class\": \"Input\",\n     *        \"map\": [\n     *          [\"2nd\",  \"inv\",  \"lnx\",  \"\\\\b\",  \"clr\"],\n     *          [\"lrn\",  \"xchg\", \"sq\",   \"sqrt\", \"rcp\"],\n     *          [\"sst\",  \"sto\",  \"rcl\",  \"sum\",  \"exp\"],\n     *          [\"bst\",  \"ee\",   \"(\",    \")\",    \"/\"],\n     *          [\"gto\",  \"7\",    \"8\",    \"9\",    \"*\"],\n     *          [\"sbr\",  \"4\",    \"5\",    \"6\",    \"-\"],\n     *          [\"rst\",  \"1\",    \"2\",    \"3\",    \"+\"],\n     *          [\"r/s\",  \"0\",    \".\",    \"+/-\",  \"=|\\\\r\"]\n     *        ],\n     *        \"location\": [139, 325, 368, 478, 0.34, 0.5, 640, 853, 418, 180, 75, 36],\n     *        \"bindings\": {\n     *          \"surface\": \"imageTI57\",\n     *          \"power\": \"powerTI57\",\n     *          \"reset\": \"resetTI57\"\n     *        }\n     *      },\n     *      \"rom\": {\n     *        \"class\": \"ROM\",\n     *        \"wordSize\": 13,\n     *        \"valueSize\": 16,\n     *        \"valueTotal\": 2048,\n     *        \"littleEndian\": true,\n     *        \"file\": \"ti57le.bin\",\n     *        \"reference\": \"\",\n     *        \"values\": [\n     *        ]\n     *      }\n     *    }\n     *\n     * @this {Machine}\n     * @param {string} idMachine (of both the machine AND the <div> to contain it)\n     * @param {string} sConfig (JSON configuration for entire machine, including any static resources)\n     */\n    constructor(idMachine, sConfig)\n    {\n        super(idMachine, idMachine, Machine.VERSION);\n\n        let machine = this;\n        this.chip = null;\n        this.sConfigFile = \"\";\n        this.fConfigLoaded = this.fPageLoaded = false;\n        \n        sConfig = sConfig.trim();\n        \n        if (sConfig[0] == '{') {\n            this.loadConfig(sConfig);\n        } else {\n            this.sConfigFile = sConfig;\n            this.getResource(this.sConfigFile, function onLoadConfig(sURL, sResource, readyState, nErrorCode) {\n                if (readyState == 4) {\n                    if (!nErrorCode && sResource) {\n                        machine.loadConfig(sResource);\n                        machine.initDevices();\n                    }\n                    else {\n                        machine.printf(\"Error (%d) loading configuration: %s\\n\", nErrorCode, sURL);\n                    }\n                }\n            });\n        }\n        \n        /*\n         * Device initialization is now deferred until after the page is fully loaded, for the benefit\n         * of devices (eg, Input) that may be dependent on page resources.\n         *\n         * Strangely, for these page events, I must use the window object rather than the document object.\n         */\n        window.addEventListener('load', function onLoadPage(event) {\n            machine.fPageLoaded = true;\n            machine.initDevices();\n        });\n        let sEvent = this.isUserAgent(\"iOS\")? 'pagehide' : (this.isUserAgent(\"Opera\")? 'unload' : undefined);\n        window.addEventListener(sEvent || 'beforeunload', function onUnloadPage(event) {\n            machine.killDevices();\n        });\n    }\n\n    /**\n     * initDevices()\n     *\n     * Initializes devices in the proper order.  For example, any Time devices should be initialized first,\n     * to ensure that their timer services are available to other devices.\n     *\n     * @this {Machine}\n     */\n    initDevices()\n    {\n        if (this.fConfigLoaded && this.fPageLoaded) {\n            for (let iClass = 0; iClass < Machine.CLASSORDER.length; iClass++) {\n                for (let idDevice in this.config) {\n                    let device, sClass;\n                    try {\n                        let config = this.config[idDevice], sStatus = \"\";\n                        sClass = config['class'];\n                        if (sClass != Machine.CLASSORDER[iClass]) continue;\n                        switch (sClass) {\n                        case Machine.CLASS.CHIP:\n                            device = new Chip(this.idMachine, idDevice, config);\n                            this.chip = device;\n                            break;\n                        case Machine.CLASS.INPUT:\n                            device = new Input(this.idMachine, idDevice, config);\n                            break;\n                        case Machine.CLASS.LED:\n                            device = new LED(this.idMachine, idDevice, config);\n                            break;\n                        case Machine.CLASS.ROM:\n                            device = new ROM(this.idMachine, idDevice, config);\n                            if (device.config['revision']) sStatus = \"revision \" + device.config['revision'];\n                            break;\n                        case Machine.CLASS.TIME:\n                            device = new Time(this.idMachine, idDevice, config);\n                            break;\n                        case Machine.CLASS.MACHINE:\n                            this.printf(\"PCjs %s v%3.2f\\n\", config['name'], Machine.VERSION);\n                            this.println(Machine.COPYRIGHT);\n                            this.println(Machine.LICENSE);\n                            if (this.sConfigFile) this.println(\"Configuration: \" + this.sConfigFile);\n                            continue;\n                        default:\n                            this.println(\"unrecognized device class: \" + sClass);\n                            continue;\n                        }\n                        this.println(sClass + \" device initialized\" + (sStatus? \" (\" + sStatus + \")\" : \"\"));\n                    }\n                    catch (err) {\n                        this.println(\"error initializing \" + sClass + \" device '\" + idDevice + \"':\\n\" + err.message);\n                        this.removeDevice(idDevice);\n                    }\n                }\n            }\n            let chip = this.chip;\n            if (chip) {\n                if (chip.onLoad && this.fAutoRestore) chip.onLoad();\n                if (chip.onPower && this.fAutoStart) chip.onPower(true);\n            }\n        }\n    }\n\n    /**\n     * killDevices()\n     * \n     * @this {Machine}\n     */\n    killDevices()\n    {\n        let chip;\n        if (chip = this.chip) {\n            if (chip.onSave) chip.onSave();\n            if (chip.onPower) chip.onPower(false);\n        }\n        \n    }\n\n    /**\n     * loadConfig(sConfig)\n     *\n     * @this {Machine}\n     * @param {string} sConfig\n     */\n    loadConfig(sConfig)\n    {\n        try {\n            this.config = JSON.parse(sConfig);\n            let config = this.config[this.idMachine];\n            this.checkVersion(config);\n            this.checkOverrides(config);\n            this.addBindings(config['bindings']);\n            this.fAutoStart = (config['autoStart'] !== false);\n            this.fAutoRestore = (config['autoRestore'] !== false);\n            this.fConfigLoaded = true;\n        } catch(err) {\n            let sError = err.message;\n            let match = sError.match(/position ([0-9]+)/);\n            if (match) {\n                sError += \" ('\" + sConfig.substr(+match[1], 40).replace(/\\s+/g, ' ') + \"...')\";\n            }\n            this.println(\"machine '\" + this.idMachine + \"' initialization error: \" + sError);\n        }\n    }\n}\n\nMachine.CLASS = {\n    CHIP:       \"Chip\",\n    INPUT:      \"Input\",\n    LED:        \"LED\",\n    MACHINE:    \"Machine\",\n    ROM:        \"ROM\",\n    TIME:       \"Time\"\n};\n\nMachine.CLASSORDER = [\n    Machine.CLASS.MACHINE,\n    Machine.CLASS.TIME,\n    Machine.CLASS.LED,\n    Machine.CLASS.INPUT,\n    Machine.CLASS.ROM,\n    Machine.CLASS.CHIP\n];\n\nMachine.COPYRIGHT = \"Copyright © 2012-2018 Jeff Parsons <Jeff@pcjs.org>\";\nMachine.LICENSE = \"License: GPL version 3 or later <http://gnu.org/licenses/gpl.html>\";\n\nMachine.VERSION = +VERSION || 1.20;\n\nwindow[MACHINE] = Machine;\n"]}