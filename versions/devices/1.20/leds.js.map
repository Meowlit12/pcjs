{"version":3,"file":"leds.js","lineCount":112,"mappings":"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","sources":["versions/devices/1.20/leds-uncompiled.js"," [synthetic:util/objectcreate] "," [synthetic:es6/util/setprototypeof] "," [synthetic:es6/util/inherits] "," [synthetic:util/defineproperty] "," [synthetic:util/global] "," [synthetic:es6/symbol] "," [synthetic:es6/util/makeiterator] "," [synthetic:es6/util/arrayfromiterator] "," [synthetic:util/polyfill] "," [synthetic:es6/number/parseint] "," [synthetic:es6/math/trunc] "," [synthetic:es6/array/fill] "," [synthetic:es6/math/log2] "," [synthetic:es6/string/startswith] "," [synthetic:util/checkstringargs] "," [synthetic:es6/util/arrayfromiterable] "],"names":["$jscomp.objectCreate","$jscomp.setPrototypeOf","$jscomp.defineProperty","$jscomp.global","$jscomp.initSymbol","$jscomp.Symbol","$jscomp.SYMBOL_PREFIX","$jscomp.arrayIterator","$jscomp.initSymbolIterator","$jscomp.iteratorPrototype","$jscomp.polyfill","MACHINE","constructor","Device","idMachine","idDevice","version","config","bindings","Device.Machines","addDevice","push","checkVersion","checkOverrides","addBindings","sCommandPrev","addBinding","binding","element","device","Device.BINDING.CLEAR","onclick","element.onclick","findBinding","value","Device.BINDING.PRINT","addEventListener","onKeyPress","event","window","keyCode","which","sText","setSelectionRange","length","stopPropagation","preventDefault","blur","focus","doCommand","fDirectBindings","Array","isArray","id","document","getElementById","addBindingOptions","options","fReset","sDefault","prop","option","createElement","text","appendChild","selectedIndex","addHandler","fn","sType","Device.HANDLER.COMMAND","Device.Handlers","parms","getURLParms","indexOf","s","match","Number","parseInt","println","sVersion","devices","findDevice","i","machine","sprintf","sError","class","type","Device.Alerts.Version","Device.Alerts.list.indexOf","alert","Device.Alerts.list.push","afnHandlers","findHandlers","sCommand","slice","lastIndexOf","trim","aTokens","split","c","setCategory","sResult","Device.COMMANDS.forEach","forEach","cmd","unshift","name","undefined","findDeviceByClass","idClass","getBindingID","getBindingText","ROM.BINDING.CELLDESC","textContent","getBounded","n","min","max","getDefault","idConfig","defaultValue","getResource","sURL","done","nErrorCode","sResource","xmlHTTP","XMLHttpRequest","ActiveXObject","onreadystatechange","xmlHTTP.onreadystatechange","readyState","responseText","status","location","protocol","open","send","sParms","Device.URLParms","search","substr","pl","exec","decodeURIComponent","replace","hasLocalStorage","Device.LocalStorage.Available","f","localStorage","setItem","Device.LocalStorage.Test","getItem","removeItem","err","message","isUserAgent","userAgent","navigator","print","Device.Category","Device.Category.indexOf","Device.CATEGORY.BUFFER","Device.PrintBuffer","scrollTop","scrollHeight","console","log","printf","format","args","$jscomp.arrayFromIterator","$jscomp.makeIterator","setBindingText","category","cPrev","fFlush","sBuffer","buffer","aParts","iArg","iPart","arg","flags","minimum","precision","conversion","ach","Math","trunc","abs","round","pow","String","fromCharCode","Device.HexUpperCase","Device.HexLowerCase","CLEAR","PRINT","BUFFER","Device.COMMANDS","COMMAND","list","Version","Available","Test","Input","Input.VERSION","time","Machine.CLASS.TIME","onHover","onReset","onPower","onInput","fDrag","getDefaultBoolean","fScroll","fTouch","Input.BINDING.SURFACE","xInput","yInput","cxInput","cyInput","hGap","vGap","cxSurface","naturalWidth","cySurface","naturalHeight","xPower","yPower","cxPower","cyPower","map","nRows","nCols","fHexagonal","buttonDelay","getDefaultNumber","cxButton","cyButton","cxGap","cyGap","xStart","yStart","captureMouse","captureTouch","input","timerInputRelease","addTimer","onInputRelease","setPosition","timerKeyRelease","onKeyRelease","onKeyTimer","keyState","keysPressed","captureKeys","col","row","$jscomp.inherits","Input.BINDING.POWER","Input.BINDING.RESET","addClick","addHover","addInput","advanceKeyState","setTimer","onKeyDown","activeElement","ch","Input.KEYCODE","charCode","onMouseDown","button","x","scrollX","y","scrollY","scrollTo","processEvent","Input.ACTION.PRESS","onMouseMove","Input.ACTION.MOVE","onMouseUp","Input.ACTION.RELEASE","onMouseOut","onTouchStart","onTouchMove","onTouchEnd","rowMap","charCodeAt","shift","action","fMultiTouch","fButton","targetTouches","pageX","pageY","yOffset","xOffset","elementNext","isNaN","offsetLeft","offsetTop","offsetParent","offsetWidth","offsetHeight","fInput","fPower","cxCol","cyCol","colInput","rowInput","yCol","fRunning","iTimer","aTimers","timer","nCyclesLeft","PRESS","MOVE","RELEASE","POWER","RESET","SURFACE","VERSION","LED","LED.VERSION","container","LED.BINDING.CONTAINER","Error","canvasView","getContext","innerHTML","LED.TYPE.ROUND","LED.TYPE.SMALL","LED.TYPE.DIGIT","widthCell","LED.SIZES","heightCell","width","height","colsView","cols","rowsView","rows","widthView","heightView","colorTransparent","getRGBAColor","colorOn","getRGBColor","colorOff","colorHighlight","colorBackground","fFixed","style","fHighlight","fPersistent","setAttribute","toString","backgroundColor","contextView","canvasGrid","widthGrid","heightGrid","contextGrid","nBufferCells","nBufferInc","bufferClone","nBufferIncExtra","fBufferModified","fTickled","fDisplayOn","nShiftedLeft","iBufferRecent","led","addAnimator","ledAnimate","drawBuffer","clearBuffer","fDraw","initBuffer","clearGrid","fillStyle","fillRect","clearRect","fForced","colRedraw","drawGrid","cxVisible","drawImage","state","color","fLeaveModified","fModified","LED.FLAGS.MODIFIED","LED.STATE.OFF","fTransparent","colorCell","xDst","yDst","clearGridCell","coords","LED.SHAPES","beginPath","arc","PI","globalCompositeOperation","fill","LED.FLAGS.PERIOD","drawString","segments","LED.SYMBOL_SEGMENTS","drawGridSegment","LED.SEGMENTS","seg","lineTo","moveTo","closePath","enableDisplay","on","getLEDCountsPacked","getLEDState","colorDefault","LED.COLORS","alpha","brightness","rgb","parseRGBValues","initCell","iCell","base","setLEDColor","colorNew","setLEDCounts","counts","bits","setLEDState","flagsSet","LED.FLAGS.SET","SMALL","ROUND","DIGIT","CONTAINER","OFF","SET","PERIOD","MODIFIED","SQUARE","ROM","ROM.VERSION","data","ROM.BINDING.ARRAY","rom","addrLines","log2","ceil","floor","ledArray","configLEDs","getDefaultString","clearArray","ledInput","configInput","sCellDesc","onROMHover","chip","sDesc","addr","disassemble","opCode","ARRAY","CELLDESC","Time","Time.VERSION","nCyclesMinimum","nCyclesMaximum","nCyclesPerSecond","nYieldsPerSecond","Time.YIELDS_PER_SECOND","nYieldsPerUpdate","Time.YIELDS_PER_UPDATE","fRequestAnimationFrame","fClockByFrame","nBaseMultiplier","nCurrentMultiplier","nTargetMultiplier","mhzBase","mhzCurrent","mhzTarget","nYields","msYield","aAnimators","aClockers","aUpdaters","fYield","fThrottling","idRunTimeout","nStepping","onRunTimeout","run","bind","onAnimationFrame","animate","requestAnimationFrame","webkitRequestAnimationFrame","setTimeout","msLastAnimation","nCyclesDeposited","nCyclesDepositPerFrame","onYield","getCycles","updateStatus","resetSpeed","nCyclesRun","nCyclesBurst","nCyclesRemain","setSpeedThrottle","setSpeed","callBack","Time.BINDING.RUN","stop","start","Time.BINDING.STEP","step","nRepeat","Time.BINDING.THROTTLE","onThrottleStart","onThrottleStop","onThrottleChange","msAuto","t","snapStart","updateTimers","endBurst","doBurst","getCyclesPerFrame","snapStop","fSkip","Time.FRAMES_PER_SECOND","calcCycles","nMultiplier","nCyclesPerYield","nCycles","iClocker","nCyclesThisRun","ms","getSpeed","mhz","toFixed","hz","getCyclesPerBurst","elementInput","Time.BINDING.SPEED","getSpeedTarget","msStartRun","msEndRun","resetTimers","msOutsideThisRun","msStartThisRun","Date","now","msDelta","msRemainsThisRun","msElapsed","calcSpeed","TIME","clearTimeout","onStepTimeout","fTransition","getSpeedCurrent","RUN","SPEED","STEP","THROTTLE","Chip","Chip.VERSION","fWrap","font","sFont","Chip.FONTS","sRule","sPattern","setMessage","sMessageInit","fToggleColor","countBuffer","getCounts","leds","Machine.CLASS.LED","loadPattern","Machine.CLASS.INPUT","onLEDInput","colorSelected","ON","fAdvance","colors","updateColorSelection","updateColorSwatches","updateBackgroundImage","Chip.BINDING.IMAGE_SELECTION","clocker","onCommand","Chip.prototype","?.prototype","Chip.BINDING.COLOR_PALETTE","Chip.BINDING.COLOR_SELECTION","onchange","element.onchange","updateColorPalette","Chip.BINDING.PATTERN_SELECTION","buildPatternOptions","Chip.BINDING.SAVE","savePattern","elementSymbol","Chip.BINDING.SYMBOL_INPUT","Chip.BINDING.SAVE_TO_URL","href","onkeypress","elementInput.onkeypress","elementPreview","Chip.BINDING.SYMBOL_PREVIEW","startsWith","Chip.BINDING.COLOR_SWATCH","patterns","lines","nCyclesTarget","nCyclesClocked","Chip.RULES.ANIM4","cActive","doCycling","fSuccess","stateNew","iColor","Chip.RULES.LEFT1","doShifting","processMessageCmd","nInc","nIncPerRow","nEmptyCols","nLeftEmpty","nRightEmpty","isEmptyCol","iCellOrig","stateOld","flagsNew","Chip.RULES.LIFE1","doCounting","nIncPerGrid","iNO","iNW","iNE","iWE","iEA","iSO","iSW","iSE","nNeighbors","nActive","getCount","count","init","Chip.BINDING.COUNT_INIT","range","Chip.BINDING.COUNT_ON","Chip.BINDING.COUNT_OFF","Chip.COUNTS.length","Chip.COUNTS","iCol","iRow","sLine","end","rule","loadPatternString","fOverwrite","fColors","fCounts","colMax","token","v","nAdvance","join","Chip.COMMANDS.forEach","onLoad","loadLocalStorage","sValue","JSON","parse","stateChip","loadState","sMessage","iMessageNext","sMessageCmd","nMessageCount","stateLEDs","Chip_prototype$onPower","fOn","Chip_prototype$onReset","onSave","saveState","saveLocalStorage","stringify","Chip.MESSAGE_CMD.HALT","Chip.MESSAGE_CMD.LOAD","Chip.MESSAGE_CMD.SCROLL","Chip.MESSAGE_CMD.PAUSE","Chip.MESSAGE_CMD.CENTER","Chip.MESSAGE_CMD.OFF","Chip.MESSAGE_CMD.ON","chSymbol","d","Chip.MESSAGE_CODE","delta","toUpperCase","fMinWidth","flushRun","fEndRow","fDelta","nPrev","rgbPrev","countsPrev","statePrev","rgbLast","countsLast","colMin","rowMax","rowMin","sImage","elementPalette","elementSelection","fPaletteChange","colorPalette","sColorOverride","toLowerCase","elementSwatch","Chip.BINDING.COLOR_SWATCH_SELECTED","idColor","idSwatch","display","Chip_prototype$updateStatus","COLOR_PALETTE","COLOR_SELECTION","COLOR_SWATCH","COLOR_SWATCH_SELECTED","COUNT_INIT","COUNT_ON","COUNT_OFF","IMAGE_SELECTION","PATTERN_SELECTION","SYMBOL_INPUT","SYMBOL_PREVIEW","SAVE","SAVE_TO_URL","COUNT_CYCLE","Chip.COMMANDS","LOAD","SCROLL","PAUSE","HALT","CENTER","ANIM4","LEFT1","LIFE1","Machine","sConfig","Machine.VERSION","sConfigFile","fConfigLoaded","fPageLoaded","loadConfig","onLoadConfig","initDevices","onLoadPage","sEvent","onUnloadPage","iClass","Machine.CLASSORDER.length","sStatus","sClass","Machine.CLASSORDER","Machine.CLASS.CHIP","Machine.CLASS.ROM","Machine.CLASS.MACHINE","Machine.COPYRIGHT","Machine.LICENSE","removeDevice","splice","fAutoRestore","fAutoStart","CHIP","INPUT"],"sourcesContent":["\"use strict\";\n\n/**\n * @copyright https://www.pcjs.org/modules/devices/device.js (C) Jeff Parsons 2012-2018\n */\n\n/**\n * @define {boolean}\n */\nvar COMPILED = false;\n\n/**\n * @define {boolean}\n */\nvar DEBUG = true; // (window.location.hostname == \"pcjs\" || window.location.hostname == \"jeffpar.local\");\n\n/**\n * @type {string}\n */\nvar MACHINE = \"Machine\";\n\n/**\n * @define {string}\n */\nvar VERSION = \"\";\n\n/** @typedef {{ class: (string|undefined), bindings: (Object|undefined), version: (number|undefined), overrides: (Array.<string>|undefined) }} */\nvar Config;\n\n/**\n * @class {Device}\n * @unrestricted\n * @property {string} idMachine\n * @property {string} idDevice\n * @property {Config} config\n * @property {Object} bindings [added by addBindings()]\n * @property {string} sCommandPrev\n */\nclass Device {\n    /**\n     * Device()\n     *\n     * Supported config properties:\n     *\n     *      \"bindings\": object containing name/value pairs, where name is the generic name\n     *      of a element, and value is the ID of the DOM element that should be mapped to it\n     *\n     * The properties in the \"bindings\" object are copied to our own bindings object in addBindings(),\n     * but only for DOM elements that actually exist, and it is the elements themselves (rather than\n     * their IDs) that we store.\n     *\n     * Also, URL parameters can be used to override config properties.  For example, the URL:\n     *\n     *      http://pcjs:8088/devices/ti57/machine/?cyclesPerSecond=100000\n     *\n     * will set the Time device's cyclesPerSecond config property to 100000.  In general, the values\n     * will be treated as strings, unless they contain all digits (number), or equal \"true\" or \"false\"\n     * (boolean).\n     *\n     * @this {Device}\n     * @param {string} idMachine\n     * @param {string} idDevice\n     * @param {number} [version]\n     * @param {Config} [config]\n     */\n    constructor(idMachine, idDevice, version, config)\n    {\n        this.config = config || {};\n        this.idMachine = idMachine;\n        this.idDevice = idDevice;\n        this.version = version || 0;\n        this.bindings = {};\n        this.addDevice();\n        this.checkVersion(this.config);\n        this.checkOverrides(this.config);\n        this.addBindings(this.config['bindings']);\n        this.sCommandPrev = \"\";\n    }\n\n    /**\n     * addBinding(binding, element)\n     *\n     * @this {Device}\n     * @param {string} binding\n     * @param {Element} element\n     */\n    addBinding(binding, element)\n    {\n        let device = this;\n\n        switch (binding) {\n\n        case Device.BINDING.CLEAR:\n            element.onclick = function onClickClear() {\n                device.clear();\n            };\n            break;\n\n        case Device.BINDING.PRINT:\n            let elementTextArea = /** @type {HTMLTextAreaElement} */ (element);\n            /*\n             * This was added for Firefox (Safari will clear the <textarea> on a page reload, but Firefox does not).\n             */\n            elementTextArea.value = \"\";\n            /*\n             * An onKeyPress handler has been added to this element simply to stop event propagation, so that if the\n             * element has been explicitly given focus, any key presses won't be picked up by the Input device (which,\n             * as that device's constructor explains, is monitoring key presses for the entire document).\n             */\n            elementTextArea.addEventListener(\n                'keypress',\n                function onKeyPress(event) {\n                    event = event || window.event;\n                    let keyCode = event.which || event.keyCode;\n                    if (keyCode) {\n                        /*\n                         * Move the caret to the end of any text in the textarea.\n                         */\n                        let sText = elementTextArea.value;\n                        elementTextArea.setSelectionRange(sText.length, sText.length);\n\n                        /*\n                         * Don't let the Input device's document-based keypress handler see any key presses\n                         * that came to this element first.\n                         */\n                        event.stopPropagation();\n\n                        /*\n                         * On the ENTER key, look for any COMMAND handlers and invoke them until one of them\n                         * returns true.\n                         */\n                        if (keyCode == 13) {\n                            /*\n                             * At the time we call any command handlers, a linefeed will not yet have been\n                             * appended to the text, so for consistency, we prevent the default behavior and\n                             * add the linefeed ourselves.  Unfortunately, one side-effect is that we must\n                             * go to some extra effort to ensure the cursor remains in view; hence the stupid\n                             * blur() and focus() calls.\n                             */\n                            event.preventDefault();\n                            sText = (elementTextArea.value += '\\n');\n                            elementTextArea.blur();\n                            elementTextArea.focus();\n                            device.doCommand(sText);\n                        }\n                    }\n                }\n            );\n            break;\n        }\n    }\n\n    /**\n     * addBindings(bindings)\n     *\n     * Builds the set of ACTUAL bindings (this.bindings) from the set of DESIRED bindings (this.config['bindings']),\n     * using either a \"bindings\" object map OR an array of \"direct bindings\".\n     *\n     * @this {Device}\n     * @param {Object} bindings\n     */\n    addBindings(bindings)\n    {\n        let fDirectBindings = Array.isArray(bindings);\n        for (let binding in bindings) {\n            let id = bindings[binding];\n            if (fDirectBindings) binding = id;\n            let element = document.getElementById(id);\n            if (element) {\n                this.bindings[binding] = element;\n                this.addBinding(binding, element);\n                continue;\n            }\n            if (DEBUG && !fDirectBindings) this.println(\"unable to find device ID: \" + id);\n        }\n    }\n\n    /**\n     * addBindingOptions(element, options, fReset, sDefault)\n     *\n     * @this {Device}\n     * @param {Element|HTMLSelectElement} element\n     * @param {Object} options (eg, key/value pairs for a series of \"option\" elements)\n     * @param {boolean} [fReset]\n     * @param {string} [sDefault]\n     */\n    addBindingOptions(element, options, fReset, sDefault)\n    {\n        if (fReset) {\n            element.options.length = 0;\n        }\n        if (options) {\n            for (let prop in options) {\n                let option = document.createElement(\"option\");\n                option.text = prop;\n                option.value = (typeof options[prop] == \"string\"? options[prop] : prop);\n                element.appendChild(option);\n                if (option.value == sDefault) element.selectedIndex = element.options.length - 1;\n            }\n        }\n    }\n\n    /**\n     * addDevice()\n     *\n     * Adds this Device to the global set of Devices, so that findDevice(), findBinding(), etc, will work.\n     *\n     * @this {Device}\n     */\n    addDevice()\n    {\n        if (!Device.Machines[this.idMachine]) Device.Machines[this.idMachine] = [];\n        Device.Machines[this.idMachine].push(this);\n    }\n\n    /**\n     * addHandler(sType, fn)\n     *\n     * @this {Device}\n     * @param {string} sType\n     * @param {function(Array.<string>,Device)} fn\n     */\n    addHandler(sType, fn)\n    {\n        if (!Device.Handlers[this.idMachine]) Device.Handlers[this.idMachine] = {};\n        if (!Device.Handlers[this.idMachine][sType]) Device.Handlers[this.idMachine][sType] = [];\n        Device.Handlers[this.idMachine][sType].push(fn);\n    }\n\n    /**\n     * alert(s, type)\n     *\n     * @this {Device}\n     * @param {string} s\n     * @param {string} [type]\n     */\n    alert(s, type)\n    {\n        if (type && Device.Alerts.list.indexOf(type) < 0) {\n            alert(s);\n            Device.Alerts.list.push(type);\n        }\n        this.println(s);\n    }\n\n    /**\n     * assert(f, s)\n     *\n     * Verifies conditions that must be true (for DEBUG builds only).\n     *\n     * The Closure Compiler should automatically remove all references to assert() in non-DEBUG builds.\n     * TODO: Add a task to the build process that \"asserts\" there are no instances of \"assertion failure\" in RELEASE builds.\n     *\n     * @this {Device}\n     * @param {*} f is the expression asserted to be true\n     * @param {string} [s] is description of the assertion on failure\n     */\n    assert(f, s)\n    {\n        if (DEBUG) {\n            if (!f) {\n                throw new Error(s || \"assertion failure\");\n            }\n        }\n    }\n\n    /**\n     * checkOverrides(config)\n     *\n     * @this {Device}\n     * @param {Config} config\n     */\n    checkOverrides(config)\n    {\n        /*\n         * If this device's config contains an \"overrides\" array, then any of the properties listed in\n         * that array may be overridden with a URL parameter.  We don't impose any checks on the overriding\n         * value, so it is the responsibility of the component with overridable properties to validate them.\n         */\n        if (config['overrides']) {\n            let parms = this.getURLParms();\n            for (let prop in parms) {\n                if (config['overrides'].indexOf(prop) >= 0) {\n                    let value;\n                    let s = parms[prop];\n                    /*\n                     * You might think we could simply call parseInt() and check isNaN(), but parseInt() has\n                     * some annoying quirks, like stopping at the first non-numeric character.  If the ENTIRE\n                     * string isn't a number, then we don't want to treat ANY part of it as a number.\n                     */\n                    if (s.match(/^[+-]?[0-9.]+$/)) {\n                        value = Number.parseInt(s, 10);\n                    } else if (s == \"true\") {\n                        value = true;\n                    } else if (s == \"false\") {\n                        value = false;\n                    } else {\n                        value = s;\n                        s = '\"' + s + '\"';\n                    }\n                    config[prop] = value;\n                    this.println(\"overriding \" + this.idDevice + \" property '\" + prop + \"' with \" + s);\n                }\n            }\n        }\n    }\n\n    /**\n     * checkVersion(config)\n     *\n     * Verify that device's version matches the machine's version, and also that the config version stored in\n     * the JSON (if any) matches the device's version.\n     *\n     * This is normally performed by the constructor, but the Machine device cannot be fully initialized in the\n     * constructor, so it calls this separately.\n     *\n     * @this {Device}\n     * @param {Config} config\n     */\n    checkVersion(config)\n    {\n        if (this.version) {\n            let sVersion = \"\", version;\n            let machine = this.findDevice(this.idMachine);\n            if (machine.version != this.version) {\n                sVersion = \"Machine\";\n                version = machine.version;\n            }\n            else if (config.version && config.version > this.version) {\n                sVersion = \"Config\";\n                version = config.version;\n            }\n            if (sVersion) {\n                let sError = this.sprintf(\"%s Device version (%3.2f) incompatible with %s version (%3.2f)\", config.class, this.version, sVersion, version);\n                this.alert(\"Error: \" + sError + '\\n\\n' + \"Clearing your browser's cache may resolve the issue.\", Device.Alerts.Version);\n            }\n        }\n    }\n\n    /**\n     * clear()\n     *\n     * @this {Device}\n     */\n    clear()\n    {\n        let element = this.findBinding(Device.BINDING.PRINT, true);\n        if (element) element.value = \"\";\n    }\n\n    /**\n     * doCommand(sText)\n     * \n     * @this {Device}\n     * @param {string} sText\n     */\n    doCommand(sText)\n    {\n        let afnHandlers = this.findHandlers(Device.HANDLER.COMMAND);\n        if (afnHandlers) {\n\n            let i = sText.lastIndexOf('\\n', sText.length - 2);\n            let sCommand = sText.slice(i + 1, -1) || this.sCommandPrev;\n            this.sCommandPrev = \"\";\n            sCommand = sCommand.trim();\n            let aTokens = sCommand.split(' ');\n    \n            switch(aTokens[0]) {\n            case 'c':\n                let c = aTokens[1];\n                if (c) {\n                    this.println(\"set category '\" + c + \"'\");\n                    this.setCategory(c);\n                } else {\n                    c = this.setCategory();\n                    if (c) {\n                        this.println(\"cleared category '\" + c + \"'\");\n                    } else {\n                        this.println(\"no category set\");\n                    }\n                }\n                break;\n            case '?':\n                let sResult = \"\";\n                Device.COMMANDS.forEach(cmd => {sResult += '\\n' + cmd;});\n                if (sResult) this.println(\"default commands:\" + sResult);\n                /* falls through */\n            default:\n                aTokens.unshift(sCommand);\n                for (let i = 0; i < afnHandlers.length; i++) {\n                    if (afnHandlers[i](aTokens, this)) break;\n                }\n                break;\n            }\n        }\n    }\n    \n    /**\n     * findBinding(name, fAll)\n     *\n     * This will search the current device's bindings, and optionally all the device bindings within the\n     * machine.  If the binding is found in another device, that binding is recorded in this device as well.\n     *\n     * @this {Device}\n     * @param {string} name\n     * @param {boolean} [fAll]\n     * @returns {Element|null|undefined}\n     */\n    findBinding(name, fAll = false)\n    {\n        let element = this.bindings[name];\n        if (element === undefined && fAll) {\n            let devices = Device.Machines[this.idMachine];\n            for (let i in devices) {\n                element = devices[i].bindings[name];\n                if (element) break;\n            }\n            if (!element) element = null;\n            this.bindings[name] = element;\n        }\n        return element;\n    }\n\n    /**\n     * findDevice(idDevice)\n     *\n     * @this {Device}\n     * @param {string} idDevice\n     * @returns {Device|undefined}\n     */\n    findDevice(idDevice)\n    {\n        let device;\n        let devices = Device.Machines[this.idMachine];\n        if (devices) {\n            for (let i in devices) {\n                if (devices[i].idDevice == idDevice) {\n                    device = devices[i];\n                    break;\n                }\n            }\n        }\n        return device;\n    }\n\n    /**\n     * findDeviceByClass(idClass)\n     *\n     * @this {Device}\n     * @param {string} idClass\n     * @returns {Device|undefined}\n     */\n    findDeviceByClass(idClass)\n    {\n        let device;\n        let devices = Device.Machines[this.idMachine];\n        if (devices) {\n            for (let i in devices) {\n                if (devices[i].config['class'] == idClass) {\n                    device = devices[i];\n                    break;\n                }\n            }\n        }\n        return device;\n    }\n\n    /**\n     * findHandlers(sType)\n     *\n     * @this {Device}\n     * @param {string} sType\n     * @returns {Array.<function(Array.<string>,Device)>|undefined}\n     */\n    findHandlers(sType)\n    {\n        return Device.Handlers[this.idMachine] && Device.Handlers[this.idMachine][sType];\n    }\n\n    /**\n     * getBindingID(name)\n     * \n     * Since this.bindings contains the actual elements, not their original IDs, we must delve back into\n     * the original this.config['bindings'] to determine the original ID.\n     * \n     * @this {Device}\n     * @param {string} name \n     * @returns {string|undefined}\n     */\n    getBindingID(name)\n    {\n        return this.config['bindings'] && this.config['bindings'][name];\n    }\n    \n    /**\n     * getBindingText(name)\n     *\n     * @this {Device}\n     * @param {string} name\n     * @return {string|undefined}\n     */\n    getBindingText(name)\n    {\n        let sText;\n        let element = this.bindings[name];\n        if (element) sText = element.textContent;\n        return sText;\n    }\n\n    /**\n     * getBounded(n, min, max)\n     *\n     * Restricts n to the bounds defined by min and max.  A side-effect is ensuring that the return\n     * value is ALWAYS a number, even n is not.\n     *\n     * @this {Device}\n     * @param {number} n\n     * @param {number} min\n     * @param {number} max\n     * @returns {number} (updated n)\n     */\n    getBounded(n, min, max)\n    {\n\n        n = +n || 0;\n        if (n < min) n = min;\n        if (n > max) n = max;\n        return n;\n    }\n\n    /**\n     * getDefault(idConfig, defaultValue)\n     *\n     * @this {Device}\n     * @param {string} idConfig\n     * @param {*} defaultValue\n     * @returns {*}\n     */\n    getDefault(idConfig, defaultValue)\n    {\n        let value = this.config[idConfig];\n        if (value === undefined) {\n            value = defaultValue;\n        } else {\n            let type = typeof defaultValue;\n            if (typeof value != type) {\n\n                if (type == \"boolean\") {\n                    value = !!value;\n                } else if (typeof defaultValue == \"number\") {\n                    value = +value;\n                }\n            }\n        }\n        return value;\n    }\n\n    /**\n     * getDefaultBoolean(idConfig, defaultValue)\n     *\n     * @this {Device}\n     * @param {string} idConfig\n     * @param {boolean} defaultValue\n     * @returns {boolean}\n     */\n    getDefaultBoolean(idConfig, defaultValue)\n    {\n        return /** @type {boolean} */ (this.getDefault(idConfig, defaultValue));\n    }\n\n    /**\n     * getDefaultNumber(idConfig, defaultValue)\n     *\n     * @this {Device}\n     * @param {string} idConfig\n     * @param {number} defaultValue\n     * @returns {number}\n     */\n    getDefaultNumber(idConfig, defaultValue)\n    {\n        return /** @type {number} */ (this.getDefault(idConfig, defaultValue));\n    }\n\n    /**\n     * getDefaultString(idConfig, defaultValue)\n     *\n     * @this {Device}\n     * @param {string} idConfig\n     * @param {string} defaultValue\n     * @returns {string}\n     */\n    getDefaultString(idConfig, defaultValue)\n    {\n        return /** @type {string} */ (this.getDefault(idConfig, defaultValue));\n    }\n\n    /**\n     * getHost()\n     *\n     * @this {Device}\n     * @return {string}\n     */\n    getHost()\n    {\n        return (\"http://\" + (window? window.location.host : \"localhost\"));\n    }\n\n    /**\n     * getHostURL()\n     *\n     * @this {Device}\n     * @return {string|null}\n     */\n    getHostURL()\n    {\n        return (window? window.location.href : null);\n    }\n\n    /**\n     * getHostProtocol()\n     *\n     * @this {Device}\n     * @return {string}\n     */\n    getHostProtocol()\n    {\n        return (window? window.location.protocol : \"file:\");\n    }\n\n    /**\n     * getResource(sURL, done)\n     *\n     * Request the specified resource, and once the request is complete, notify done().\n     *\n     * done() is passed four parameters:\n     *\n     *      done(sURL, sResource, readyState, nErrorCode)\n     *\n     * readyState comes from the request's 'readyState' property, and the operation should not be considered complete\n     * until readyState is 4.\n     * \n     * If nErrorCode is zero, sResource should contain the requested data; otherwise, an error occurred.\n     *\n     * @param {string} sURL\n     * @param {function(string,string,number,number)} done\n     */\n    getResource(sURL, done)\n    {\n        let nErrorCode = 0, sResource = null;\n\n        if (DEBUG) {\n            /*\n             * The larger resources we put on archive.pcjs.org should also be available locally.\n             *\n             * NOTE: \"http://archive.pcjs.org\" is now \"https://s3-us-west-2.amazonaws.com/archive.pcjs.org\"\n             */\n            sURL = sURL.replace(/^(http:\\/\\/archive\\.pcjs\\.org|https:\\/\\/s3-us-west-2\\.amazonaws\\.com\\/archive\\.pcjs\\.org)(\\/.*)\\/([^\\/]*)$/, \"$2/archive/$3\");\n        }\n\n        let xmlHTTP = (window.XMLHttpRequest? new window.XMLHttpRequest() : new window.ActiveXObject(\"Microsoft.XMLHTTP\"));\n        xmlHTTP.onreadystatechange = function()\n        {\n            if (xmlHTTP.readyState !== 4) {\n                done(sURL, sResource, xmlHTTP.readyState, nErrorCode);\n                return;\n            }\n            \n            /*\n             * The following line was recommended for WebKit, as a work-around to prevent the handler firing multiple\n             * times when debugging.  Unfortunately, that's not the only XMLHttpRequest problem that occurs when\n             * debugging, so I think the WebKit problem is deeper than that.  When we have multiple XMLHttpRequests\n             * pending, any debugging activity means most of them simply get dropped on floor, so what may actually be\n             * happening are mis-notifications rather than redundant notifications.\n             *\n             *      xmlHTTP.onreadystatechange = undefined;\n             */\n            sResource = xmlHTTP.responseText;\n            \n            /*\n             * The normal \"success\" case is an HTTP status code of 200, but when testing with files loaded\n             * from the local file system (ie, when using the \"file:\" protocol), we have to be a bit more \"flexible\".\n             */\n            if (xmlHTTP.status == 200 || !xmlHTTP.status && sResource.length && this.getHostProtocol() == \"file:\") {\n                // if (MAXDEBUG) Web.log(\"xmlHTTP.onreadystatechange(\" + sURL + \"): returned \" + sResource.length + \" bytes\");\n            }\n            else {\n                nErrorCode = xmlHTTP.status || -1;\n            }\n            done(sURL, sResource, xmlHTTP.readyState, nErrorCode);\n        };\n        \n        xmlHTTP.open(\"GET\", sURL, true);\n        xmlHTTP.send();\n    }\n\n    /**\n     * getURLParms(sParms)\n     *\n     * @param {string} [sParms] containing the parameter portion of a URL (ie, after the '?')\n     * @returns {Object} containing properties for each parameter found\n     */\n    getURLParms(sParms)\n    {\n        let parms = Device.URLParms;\n        if (!parms) {\n            parms = {};\n            if (window) {\n                if (!sParms) {\n                    /*\n                     * Note that window.location.href returns the entire URL, whereas window.location.search\n                     * returns only the parameters, if any (starting with the '?', which we skip over with a substr() call).\n                     */\n                    sParms = window.location.search.substr(1);\n                }\n                let match;\n                let pl = /\\+/g; // RegExp for replacing addition symbol with a space\n                let search = /([^&=]+)=?([^&]*)/g;\n                let decode = function decodeParameter(s) {\n                    return decodeURIComponent(s.replace(pl, \" \")).trim();\n                };\n\n                while ((match = search.exec(sParms))) {\n                    parms[decode(match[1])] = decode(match[2]);\n                }\n            }\n            Device.URLParms = parms;\n        }\n        return parms;\n    }\n\n    /**\n     * hasLocalStorage\n     *\n     * If localStorage support exists, is enabled, and works, return true.\n     *\n     * @this {Device}\n     * @returns {boolean}\n     */\n    hasLocalStorage()\n    {\n        if (Device.LocalStorage.Available === undefined) {\n            let f = false;\n            if (window) {\n                try {\n                    window.localStorage.setItem(Device.LocalStorage.Test, Device.LocalStorage.Test);\n                    f = (window.localStorage.getItem(Device.LocalStorage.Test) == Device.LocalStorage.Test);\n                    window.localStorage.removeItem(Device.LocalStorage.Test);\n                } catch(err) {\n                    this.println(err.message);\n                    f = false;\n                }\n            }\n            Device.LocalStorage.Available = f;\n        }\n        return !!Device.LocalStorage.Available;\n    }\n\n    /**\n     * hex(n)\n     *\n     * This is a helper function intended for use in a debugging console, allowing you to display\n     * numbers as hex by evaluating the expression \"this.hex(n)\".  Technically, this should be a static\n     * method, since there's nothing instance-specific about it, but \"this.hex()\" is easier to type than\n     * \"Device.hex()\".\n     *\n     * @this {Device}\n     * @param {number} n\n     */\n    hex(n)\n    {\n        return this.sprintf(\"%x\", n);\n    }\n\n    /**\n     * isCategory(category)\n     *\n     * Use this function to enable/disable any code (eg, print() calls) based on 1) whether specific\n     * categories are required, and 2) whether the specified category is one of them.\n     *\n     * @this {Device}\n     * @param {string} category\n     */\n    isCategoryOn(category)\n    {\n        return (Device.Category && Device.Category.indexOf(category) >= 0);\n    }\n\n    /**\n     * isUserAgent(s)\n     *\n     * Check the browser's user-agent string for the given substring; \"iOS\" and \"MSIE\" are special values you can\n     * use that will match any iOS or MSIE browser, respectively (even IE11, in the case of \"MSIE\").\n     *\n     * 2013-11-06: In a questionable move, MSFT changed the user-agent reported by IE11 on Windows 8.1, eliminating\n     * the \"MSIE\" string (which MSDN calls a \"version token\"; see http://msdn.microsoft.com/library/ms537503.aspx);\n     * they say \"public websites should rely on feature detection, rather than browser detection, in order to design\n     * their sites for browsers that don't support the features used by the website.\" So, in IE11, we get a user-agent\n     * that tries to fool apps into thinking the browser is more like WebKit or Gecko:\n     *\n     *      Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko\n     *\n     * @this {Device}\n     * @param {string} s is a substring to search for in the user-agent; as noted above, \"iOS\" and \"MSIE\" are special values\n     * @returns {boolean} is true if the string was found, false if not\n     */\n    isUserAgent(s)\n    {\n        if (window) {\n            let userAgent = window.navigator.userAgent;\n            return s == \"iOS\" && !!userAgent.match(/(iPod|iPhone|iPad)/) && !!userAgent.match(/AppleWebKit/) || s == \"MSIE\" && !!userAgent.match(/(MSIE|Trident)/) || (userAgent.indexOf(s) >= 0);\n        }\n        return false;\n    }\n\n    /**\n     * loadLocalStorage()\n     *\n     * @this {Device}\n     * @returns {Array|null}\n     */\n    loadLocalStorage()\n    {\n        let state = null;\n        if (this.hasLocalStorage()) {\n            let sValue;\n            if (window) {\n                try {\n                    sValue = window.localStorage.getItem(this.idMachine);\n                    if (sValue) state = /** @type {Array} */ (JSON.parse(sValue));\n                } catch (err) {\n                    this.println(err.message);\n                }\n            }\n        }\n        return state;\n    }\n\n    /**\n     * print(s)\n     *\n     * @this {Device}\n     * @param {string} s\n     */\n    print(s)\n    {\n        if (this.isCategoryOn(Device.CATEGORY.BUFFER)) {\n            Device.PrintBuffer += s;\n            return;\n        }\n        let element = this.findBinding(Device.BINDING.PRINT, true);\n        if (element) {\n            element.value += s;\n            /*\n             * Prevent the <textarea> from getting too large; otherwise, printing becomes slower and slower.\n             */\n            if (!DEBUG && element.value.length > 8192) {\n                element.value = element.value.substr(element.value.length - 4096);\n            }\n            element.scrollTop = element.scrollHeight;\n        }\n        if (DEBUG || !element) {\n            let i = s.lastIndexOf('\\n');\n            if (i >= 0) {\n                console.log(Device.PrintBuffer + s.substr(0, i));\n                Device.PrintBuffer = \"\";\n                s = s.substr(i + 1);\n            }\n            Device.PrintBuffer += s;\n        }\n    }\n\n    /**\n     * println(s)\n     *\n     * @this {Device}\n     * @param {string} s\n     */\n    println(s)\n    {\n        this.print(s + '\\n');\n    }\n\n    /**\n     * printf(format, ...args)\n     *\n     * @this {Device}\n     * @param {string} format\n     * @param {...} args\n     */\n    printf(format, ...args)\n    {\n        this.print(this.sprintf(format, ...args));\n    }\n\n    /**\n     * removeDevice(idDevice)\n     *\n     * @this {Device}\n     * @param {string} idDevice\n     * @returns {boolean} (true if successfully removed, false if not)\n     */\n    removeDevice(idDevice)\n    {\n        let device;\n        let devices = Device.Machines[this.idMachine];\n        if (devices) {\n            for (let i in devices) {\n                if (devices[i].idDevice == idDevice) {\n                    devices.splice(i, 1);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * saveLocalStorage(state)\n     *\n     * @this {Device}\n     * @param {Array} state\n     * @returns {boolean} true if successful, false if error\n     */\n    saveLocalStorage(state)\n    {\n        if (this.hasLocalStorage()) {\n            let sValue = JSON.stringify(state);\n            try {\n                window.localStorage.setItem(this.idMachine, sValue);\n                return true;\n            } catch(err) {\n                this.println(err.message);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * setBindingText(name, text)\n     *\n     * @this {Device}\n     * @param {string} name\n     * @param {string} text\n     */\n    setBindingText(name, text)\n    {\n        let element = this.bindings[name];\n        if (element) element.textContent = text;\n    }\n\n    /**\n     * setCategory(category)\n     *\n     * Use this function to set/clear categories.  Generally, these are thought of as print categories,\n     * allowing code to use isCategoryOn() to decide whether to print a certain category of messages, but\n     * it can be used to control any functionality related to a given category, not just printing.\n     *\n     * You usually want to use one of the predefined category strings in Device.CATEGORIES, but in reality,\n     * the category string can be anything you want.\n     *\n     * If you want to enable multiple categories, specify them all in a single string (eg, \"time|buffer\",\n     * or Device.CATEGORY.TIME + Device.CATEGORY.BUFFER).\n     *\n     * Device.CATEGORY.BUFFER is special, causing all print calls to be buffered; the print buffer will be\n     * dumped as soon as setCategory() clears Device.CATEGORY.BUFFER.\n     *\n     * @this {Device}\n     * @param {string} [category] (if undefined, clear previous category)\n     * @returns {string}\n     */\n    setCategory(category = \"\")\n    {\n        let cPrev = Device.Category;\n        let fFlush = (!category && this.isCategoryOn(Device.CATEGORY.BUFFER));\n        Device.Category = category;\n        if (fFlush) {\n            let sBuffer = Device.PrintBuffer;\n            Device.PrintBuffer = \"\";\n            this.print(sBuffer);\n        }\n        return cPrev;\n    }\n\n    /**\n     * sprintf(format, ...args)\n     *\n     * Copied from the CCjs project (https://github.com/jeffpar/ccjs/blob/master/lib/stdio.js) and extended.\n     *\n     * Far from complete, let alone sprintf-compatible, but it's adequate for the handful of sprintf-style format\n     * specifiers that I use.\n     *\n     * @this {Device}\n     * @param {string} format\n     * @param {...} args\n     * @returns {string}\n     */\n    sprintf(format, ...args)\n    {\n        let buffer = \"\";\n        let aParts = format.split(/%([-+ 0#]?)([0-9]*)(\\.?)([0-9]*)([hlL]?)([A-Za-z%])/);\n\n        let iArg = 0, iPart;\n        for (iPart = 0; iPart < aParts.length - 7; iPart += 7) {\n\n            buffer += aParts[iPart];\n\n            let arg = args[iArg++];\n            let flags = aParts[iPart+1];\n            let minimum = +aParts[iPart+2] || 0;\n            let precision = +aParts[iPart+4] || 0;\n            let conversion = aParts[iPart+6];\n            let ach = null, s;\n\n            switch(conversion) {\n            case 'd':\n                /*\n                 * We could use \"arg |= 0\", but there may be some value to supporting integers > 32 bits.\n                 */\n                arg = Math.trunc(arg);\n                /* falls through */\n\n            case 'f':\n                s = Math.trunc(arg) + \"\";\n                if (precision) {\n                    minimum -= (precision + 1);\n                }\n                if (s.length < minimum) {\n                    if (flags == '0') {\n                        if (arg < 0) minimum--;\n                        s = (\"0000000000\" + Math.abs(arg)).slice(-minimum);\n                        if (arg < 0) s = '-' + s;\n                    } else {\n                        s = (\"          \" + s).slice(-minimum);\n                    }\n                }\n                if (precision) {\n                    arg = Math.round((arg - Math.trunc(arg)) * Math.pow(10, precision));\n                    s += '.' + (\"0000000000\" + Math.abs(arg)).slice(-precision);\n                }\n                buffer += s;\n                break;\n\n            case 'c':\n                arg = String.fromCharCode(arg);\n                /* falls through */\n\n            case 's':\n                while (arg.length < minimum) {\n                    if (flags == '-') {\n                        arg += ' ';\n                    } else {\n                        arg = ' ' + arg;\n                    }\n                }\n                buffer += arg;\n                break;\n\n            case 'X':\n                ach = Device.HexUpperCase;\n                /* falls through */\n\n            case 'x':\n                if (!ach) ach = Device.HexLowerCase;\n                s = \"\";\n                do {\n                    s = ach[arg & 0xf] + s;\n                    arg >>>= 4;\n                } while (--minimum > 0 || arg);\n                buffer += s;\n                break;\n\n            default:\n                /*\n                 * The supported ANSI C set of conversions: \"dioxXucsfeEgGpn%\"\n                 */\n                buffer += \"(unrecognized printf conversion %\" + conversion + \")\";\n                break;\n            }\n        }\n\n        buffer += aParts[iPart];\n        return buffer;\n    }\n}\n\nDevice.BINDING = {\n    CLEAR:      \"clear\",\n    PRINT:      \"print\"\n};\n\n/*\n * List of standard categories.\n *\n * Device.CATEGORY.BUFFER is special, causing all print calls to be buffered; the print buffer will be\n * dumped as soon as setCategory() clears Device.CATEGORY.BUFFER.\n */\nDevice.CATEGORY = {\n    TIME:       \"time\",\n    BUFFER:     \"buffer\"\n};\n\nDevice.COMMANDS = [\n    \"c\\t\\tset category\"\n];\n\nDevice.HANDLER = {\n    COMMAND:    \"command\"\n};\n\nDevice.Alerts = {\n    list:       [],\n    Version:    \"version\"\n};\n\nDevice.LocalStorage = {\n    Available:  undefined,\n    Test:       \"PCjs.localStorage\"\n};\n\n/**\n * Handlers is a global object whose properties are machine IDs, each of which contains zero or more\n * handler IDs, each of which contains an arrays of functions.\n *\n * @type {Object}\n */\nDevice.Handlers = {};\n\n/**\n * Machines is a global object whose properties are machine IDs and whose values are arrays of Devices.\n *\n * @type {Object}\n */\nDevice.Machines = {};\n\n/**\n * Category is a global string that contains zero or more Device.CATEGORY strings; see setCategory().\n *\n * @type {string}\n */\nDevice.Category = \"\";\n\n/**\n * PrintBuffer is a global string that buffers partial lines for our print services when using console.log().\n *\n * @type {string}\n */\nDevice.PrintBuffer = \"\";\n\n/*\n * Handy global constants\n */\nDevice.HexLowerCase = \"0123456789abcdef\";\nDevice.HexUpperCase = \"0123456789ABCDEF\";\n\n/**\n * @copyright https://www.pcjs.org/modules/devices/input.js (C) Jeff Parsons 2012-2018\n */\n\n/** @typedef {{ class: string, bindings: (Object|undefined), version: (number|undefined), overrides: (Array.<string>|undefined), location: Array.<number>, map: (Array.<Array.<number>>|undefined), drag: (boolean|undefined), scroll: (boolean|undefined), hexagonal: (boolean|undefined), buttonDelay: (number|undefined) }} */\nvar InputConfig;\n\n/**\n * @class {Input}\n * @unrestricted\n * @property {InputConfig} config\n * @property {Array.<number>} location\n * @property {Array.<Array.<number>>} map\n * @property {boolean} fDrag\n * @property {boolean} fScroll\n * @property {boolean} fHexagonal\n * @property {number} buttonDelay\n * @property {{\n *  surface: HTMLImageElement|undefined\n * }} bindings\n */\nclass Input extends Device {\n    /**\n     * Input(idMachine, idDevice, config)\n     *\n     * Sample config:\n     *\n     *      \"input\": {\n     *        \"class\": \"Input\",\n     *        \"location\": [139, 325, 368, 478, 0.34, 0.5, 640, 853],\n     *        \"map\": [\n     *          [\"2nd\",  \"inv\",  \"lnx\",  \"\\\\b\",  \"clr\"],\n     *          [\"lrn\",  \"xchg\", \"sq\",   \"sqrt\", \"rcp\"],\n     *          [\"sst\",  \"sto\",  \"rcl\",  \"sum\",  \"exp\"],\n     *          [\"bst\",  \"ee\",   \"(\",    \")\",    \"/\"],\n     *          [\"gto\",  \"7\",    \"8\",    \"9\",    \"*\"],\n     *          [\"sbr\",  \"4\",    \"5\",    \"6\",    \"-\"],\n     *          [\"rst\",  \"1\",    \"2\",    \"3\",    \"+\"],\n     *          [\"r/s\",  \"0\",    \".\",    \"+/-\",  \"=|\\\\r\"]\n     *        ],\n     *        \"drag\": false,\n     *        \"bindings\": {\n     *          \"surface\": \"imageTI57\",\n     *          \"power\": \"powerTI57\",\n     *          \"reset\": \"resetTI57\"\n     *        }\n     *      }\n     *\n     * A word about the \"power\" button: the page will likely use absolute positioning to overlay the HTML button\n     * onto the image of the physical button, and the temptation might be to use the style \"display:none\" to hide\n     * it, but \"opacity:0\" should be used instead, because otherwise our efforts to use it as focusable element\n     * may fail.\n     *\n     * @this {Input}\n     * @param {string} idMachine\n     * @param {string} idDevice\n     * @param {InputConfig} [config]\n     */\n    constructor(idMachine, idDevice, config)\n    {\n        super(idMachine, idDevice, Input.VERSION, config);\n\n        this.time = /** @type {Time} */ (this.findDeviceByClass(Machine.CLASS.TIME));\n\n        this.onInput = null;\n        this.onPower = null;\n        this.onReset = null;\n        this.onHover = null;\n\n        /*\n         * If 'drag' is true, then the onInput() handler will be called whenever the current col and/or row\n         * changes, even if the mouse hasn't been released since the previous onInput() call.\n         *\n         * The default is false, because in general, allowing drag is a bad idea for calculator buttons.  But\n         * I've made this an option for other input surfaces, like LED arrays, where you might want to turn a\n         * series of LEDs on or off.\n         */\n        this.fDrag = this.getDefaultBoolean('drag', false);\n\n        /*\n         * If 'scroll' is true, then we do NOT call preventDefault() on touch events; this permits the input\n         * surface to be scrolled like any other part of the page.  The default is false, because this has other\n         * side-effects (eg, inadvertent zooms).\n         */\n        this.fScroll = this.getDefaultBoolean('scroll', false);\n\n        /*\n         * This is set on receipt of the first 'touch' event of any kind, and is used by the 'mouse' event\n         * handlers to disregard mouse events if set.\n         */\n        this.fTouch = false;\n\n        let element = this.bindings[Input.BINDING.SURFACE];\n        if (element) {\n            /*\n             * The location array, eg:\n             *\n             *      \"location\": [139, 325, 368, 478, 0.34, 0.5, 640, 853, 180, 418, 75, 36],\n             *\n             * contains the top left corner (xInput, yInput) and dimensions (cxInput, cyInput)\n             * of the input rectangle where the buttons described in the map are located, relative\n             * to the surface image.  It also describes the average amount of horizontal and vertical\n             * space between buttons, as fractions of the average button width and height (hGap, vGap).\n             *\n             * With all that, we can now calculate the center lines for each column and row.  This\n             * obviously assumes that all the buttons are evenly laid out in a perfect grid.  For\n             * devices that don't have such a nice layout, a different location array format will\n             * have to be defined.\n             *\n             * NOTE: While element.naturalWidth and element.naturalHeight should, for all modern\n             * browsers, contain the surface image's dimensions as well, those values still might not\n             * be available if our constructor is called before the page's onload event has fired,\n             * so we allow them to be stored in the next two elements of the location array, too.\n             *\n             * Finally, the position and size of the device's power button may be stored in the array\n             * as well, in case some browsers refuse to generate onClickPower() events (eg, if they\n             * think the button is inaccessible/not visible).\n             */\n            let location = this.config['location'];\n            this.xInput = location[0];\n            this.yInput = location[1];\n            this.cxInput = location[2];\n            this.cyInput = location[3];\n            this.hGap = location[4] || 1.0;\n            this.vGap = location[5] || 1.0;\n            this.cxSurface = location[6] || element.naturalWidth || this.cxInput;\n            this.cySurface = location[7] || element.naturalHeight || this.cyInput;\n            this.xPower = location[8] || 0;\n            this.yPower = location[9] || 0;\n            this.cxPower = location[10] || 0;\n            this.cyPower = location[11] || 0;\n            this.map = this.config['map'];\n            if (this.map) {\n                this.nRows = this.map.length;\n                this.nCols = this.map[0].length;\n            } else {\n                this.nCols = this.hGap;\n                this.nRows = this.vGap;\n                this.hGap = this.vGap = 0;\n            }\n\n            /*\n             * If 'hexagonal' is true, then we treat the input grid as hexagonal, where even rows of the associated\n             * display are offset.\n             */\n            this.fHexagonal = this.getDefaultBoolean('hexagonal', false);\n            \n            /*\n             * The 'buttonDelay' setting is only necessary for devices (ie, old calculator chips) that are either slow\n             * to respond and/or have debouncing logic that would otherwise be defeated.\n             */\n            this.buttonDelay = this.getDefaultNumber('buttonDelay', 0);\n\n            /*\n             * To calculate the average button width (cxButton), we know that the overall width\n             * must equal the sum of all the button widths + the sum of all the button gaps:\n             *\n             *      cxInput = nCols * cxButton + nCols * (cxButton * hGap)\n             *\n             * The number of gaps would normally be (nCols - 1), but we require that cxInput include\n             * only 1/2 the gap at the edges, too.  Solving for cxButton:\n             *\n             *      cxButton = cxInput / (nCols + nCols * hGap)\n             */\n            this.cxButton = (this.cxInput / (this.nCols + this.nCols * this.hGap))|0;\n            this.cyButton = (this.cyInput / (this.nRows + this.nRows * this.vGap))|0;\n            this.cxGap = (this.cxButton * this.hGap)|0;\n            this.cyGap = (this.cyButton * this.vGap)|0;\n\n            /*\n             * xStart and yStart record the last 'touchstart' or 'mousedown' position on the surface\n             * image; they will be reset to -1 when movement has ended (eg, 'touchend' or 'mouseup').\n             */\n            this.xStart = this.yStart = -1;\n\n            this.captureMouse(element);\n            this.captureTouch(element);\n\n            if (this.time) {\n                /*\n                 * We use a timer for the touch/mouse release events, to ensure that the machine had\n                 * enough time to notice the input before releasing it.\n                 */\n                let input = this;\n                if (this.buttonDelay) {\n                    this.timerInputRelease = this.time.addTimer(\"timerInputRelease\", function onInputRelease() {\n                        if (input.xStart < 0 && input.yStart < 0) { // auto-release ONLY if it's REALLY released\n                            input.setPosition(-1, -1);\n                        }\n                    });\n                }\n                if (this.map) {\n                    /*\n                     * This auto-releases the last key reported after an appropriate delay, to ensure that\n                     * the machine had enough time to notice the corresponding button was pressed.\n                     */\n                    if (this.buttonDelay) {\n                        this.timerKeyRelease = this.time.addTimer(\"timerKeyRelease\", function onKeyRelease() {\n                            input.onKeyTimer();\n                        });\n                    }\n                    /*\n                     * I used to maintain a single-key buffer (this.keyPressed) and would immediately release\n                     * that key as soon as another key was pressed, but it appears that the ROM wants a minimum\n                     * delay between release and the next press -- probably for de-bouncing purposes.  So we\n                     * maintain a key state: 0 means no key has gone down or up recently, 1 means a key just went\n                     * down, and 2 means a key just went up.  keysPressed maintains a queue of keys (up to 16)\n                     * received while key state is non-zero.\n                     */\n                    this.keyState = 0;\n                    this.keysPressed = [];\n                    /*\n                     * I'm attaching my 'keypress' handlers to the document object, since image elements are\n                     * not focusable.  I'm disinclined to do what I've done with other machines (ie, create an\n                     * invisible <textarea> overlay), because in this case, I don't really want a soft keyboard\n                     * popping up and obscuring part of the display.\n                     *\n                     * A side-effect, however, is that if the user attempts to explicitly give the image\n                     * focus, we don't have anything for focus to attach to.  We address that in onMouseDown(),\n                     * by redirecting focus to the \"power\" button, if any, not because we want that or any other\n                     * button to have focus, but simply to remove focus from any other input element on the page.\n                     */\n                    this.captureKeys(document);\n                }\n            }\n\n            /*\n             * Finally, the active input state.  If there is no active input, col and row are -1.  After\n             * this point, these variables will be updated by setPosition().\n             */\n            this.col = this.row = -1;\n        }\n    }\n\n    /**\n     * addBinding(binding, element)\n     *\n     * @this {Input}\n     * @param {string} binding\n     * @param {Element} element\n     */\n    addBinding(binding, element)\n    {\n        let input = this;\n\n        switch(binding) {\n\n        case Input.BINDING.POWER:\n            element.onclick = function onClickPower() {\n                if (input.onPower) input.onPower();\n            };\n            break;\n\n        case Input.BINDING.RESET:\n            element.onclick = function onClickReset() {\n                if (input.onReset) input.onReset();\n            };\n            break;\n        }\n        super.addBinding(binding, element);\n    }\n\n    /**\n     * addClick(onPower, onReset)\n     *\n     * Called by the Chip device to set up power and reset notifications.\n     *\n     * @this {Input}\n     * @param {function()} [onPower] (called when the \"power\" button, if any, is clicked)\n     * @param {function()} [onReset] (called when the \"reset\" button, if any, is clicked)\n     */\n    addClick(onPower, onReset)\n    {\n        this.onPower = onPower;\n        this.onReset = onReset;\n    }\n\n    /**\n     * addHover(onHover)\n     *\n     * @this {Input}\n     * @param {function(number, number)} onHover\n     */\n    addHover(onHover)\n    {\n        this.onHover = onHover;\n    }\n\n    /**\n     * addInput(onInput)\n     *\n     * Called by the Chip device to set up input notifications.\n     *\n     * @this {Input}\n     * @param {function(number,number)} onInput\n     */\n    addInput(onInput)\n    {\n        this.onInput = onInput;\n    }\n\n    /**\n     * advanceKeyState()\n     *\n     * @this {Input}\n     */\n    advanceKeyState()\n    {\n        if (!this.buttonDelay) {\n            this.onKeyTimer();\n        } else {\n            this.time.setTimer(this.timerKeyRelease, this.buttonDelay);\n        }\n    }\n\n    /**\n     * captureKeys(element)\n     *\n     * @this {Input}\n     * @param {Document|Element} element\n     */\n    captureKeys(element)\n    {\n        let input = this;\n        element.addEventListener(\n            'keydown',\n            function onKeyDown(event) {\n                event = event || window.event;\n                let activeElement = document.activeElement;\n                if (activeElement == input.bindings[Input.BINDING.POWER]) {\n                    let keyCode = event.which || event.keyCode;\n                    let ch = Input.KEYCODE[keyCode];\n                    if (ch && input.onKeyPress(ch)) event.preventDefault();\n                }\n            }\n        );\n        element.addEventListener(\n            'keypress',\n            function onKeyPress(event) {\n                event = event || window.event;\n                let charCode = event.which || event.charCode;\n                let ch = String.fromCharCode(charCode);\n                if (ch && input.onKeyPress(ch)) event.preventDefault();\n            }\n        );\n    }\n\n    /**\n     * captureMouse(element)\n     *\n     * @this {Input}\n     * @param {HTMLImageElement} element\n     */\n    captureMouse(element)\n    {\n        let input = this;\n\n        element.addEventListener(\n            'mousedown',\n            function onMouseDown(event) {\n                if (input.fTouch) return;\n                /*\n                 * If there are any text input elements on the page that might currently have focus,\n                 * this is a good time to divert focus to a focusable element of our own (eg, a \"power\"\n                 * button).  Otherwise, key presses could be confusingly processed in two places.\n                 *\n                 * Unfortunately, setting focus on an element can cause the browser to scroll the element\n                 * into view, so to avoid that, we use the following scrollTo() work-around.\n                 */\n                let button = input.bindings[Input.BINDING.POWER];\n                if (button) {\n                    let x = window.scrollX, y = window.scrollY;\n                    button.focus();\n                    window.scrollTo(x, y);\n                }\n                if (!event.button) {\n                    input.processEvent(element, Input.ACTION.PRESS, event);\n                }\n            }\n        );\n\n        element.addEventListener(\n            'mousemove',\n            function onMouseMove(event) {\n                if (input.fTouch) return;\n                input.processEvent(element, Input.ACTION.MOVE, event);\n            }\n        );\n\n        element.addEventListener(\n            'mouseup',\n            function onMouseUp(event) {\n                if (input.fTouch) return;\n                if (!event.button) {\n                    input.processEvent(element, Input.ACTION.RELEASE, event);\n                }\n            }\n        );\n\n        element.addEventListener(\n            'mouseout',\n            function onMouseOut(event) {\n                if (input.fTouch) return;\n                if (input.xStart < 0) {\n                    input.processEvent(element, Input.ACTION.MOVE, event);\n                } else {\n                    input.processEvent(element, Input.ACTION.RELEASE, event);\n                }\n            }\n        );\n    }\n\n    /**\n     * captureTouch(element)\n     *\n     * @this {Input}\n     * @param {HTMLImageElement} element\n     */\n    captureTouch(element)\n    {\n        let input = this;\n\n        /*\n         * NOTE: The mouse event handlers below deal only with events where the left button is involved\n         * (ie, left button is pressed, down, or released).\n         */\n        element.addEventListener(\n            'touchstart',\n            function onTouchStart(event) {\n                /*\n                 * Under normal circumstances (ie, when fScroll is false), when any touch events arrive,\n                 * processEvent() calls preventDefault(), which prevents a variety of potentially annoying\n                 * behaviors (ie, zooming, scrolling, fake mouse events, etc).  Under non-normal circumstances,\n                 * (ie, when fScroll is true), we set fTouch on receipt of a 'touchstart' event, which will\n                 * help our mouse event handlers avoid any redundant actions due to fake mouse events.\n                 */\n                if (input.fScroll) input.fTouch = true;\n                input.processEvent(element, Input.ACTION.PRESS, event);\n            }\n        );\n\n        element.addEventListener(\n            'touchmove',\n            function onTouchMove(event) {\n                input.processEvent(element, Input.ACTION.MOVE, event);\n            }\n        );\n\n        element.addEventListener(\n            'touchend',\n            function onTouchEnd(event) {\n                input.processEvent(element, Input.ACTION.RELEASE, event);\n            }\n        );\n    }\n\n    /**\n     * onKeyPress(ch)\n     *\n     * @this {Input}\n     * @param {string} ch\n     * @returns {boolean} (true if processed, false if not)\n     */\n    onKeyPress(ch)\n    {\n        for (let row = 0; row < this.map.length; row++) {\n            let rowMap = this.map[row];\n            for (let col = 0; col < rowMap.length; col++) {\n                let aParts = rowMap[col].split('|');\n                if (aParts.indexOf(ch) >= 0) {\n                    if (this.keyState) {\n                        if (this.keysPressed.length < 16) {\n                            this.keysPressed.push(ch);\n                        }\n                    } else {\n                        this.keyState = 1;\n                        this.setPosition(col, row);\n                        this.advanceKeyState();\n                    }\n                    return true;\n                }\n            }\n        }\n        this.printf(\"unrecognized key '%s' (0x%02x)\\n\", ch, ch.charCodeAt(0));\n        return false;\n    }\n\n    /**\n     * onKeyTimer()\n     *\n     * @this {Input}\n     */\n    onKeyTimer()\n    {\n\n        if (this.keyState == 1) {\n            this.keyState++;\n            this.setPosition(-1, -1);\n            this.advanceKeyState();\n        } else {\n            this.keyState = 0;\n            if (this.keysPressed.length) {\n                this.onKeyPress(this.keysPressed.shift());\n            }\n        }\n    }\n\n    /**\n     * processEvent(element, action, event)\n     *\n     * @this {Input}\n     * @param {HTMLImageElement} element\n     * @param {number} action\n     * @param {Event|MouseEvent|TouchEvent} [event] (eg, the object from a 'touch' or 'mouse' event)\n     */\n    processEvent(element, action, event)\n    {\n        let col = -1, row = -1;\n        let fMultiTouch = false;\n        let x, y, xInput, yInput, fButton, fInput, fPower;\n\n        if (action < Input.ACTION.RELEASE) {\n\n            /**\n             * @name Event\n             * @property {Array} targetTouches\n             */\n            event = event || window.event;\n\n            if (!event.targetTouches || !event.targetTouches.length) {\n                x = event.pageX;\n                y = event.pageY;\n            } else {\n                x = event.targetTouches[0].pageX;\n                y = event.targetTouches[0].pageY;\n                fMultiTouch = (event.targetTouches.length > 1);\n            }\n\n            /*\n             * Touch coordinates (that is, the pageX and pageY properties) are relative to the page, so to make\n             * them relative to the element, we must subtract the element's left and top positions.  This Apple web page:\n             *\n             *      https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/AddingMouseandTouchControlstoCanvas/AddingMouseandTouchControlstoCanvas.html\n             *\n             * makes it sound simple, but it turns out we have to walk the element's entire \"parentage\" of DOM elements\n             * to get the exact offsets.\n             */\n            let xOffset = 0;\n            let yOffset = 0;\n            let elementNext = element;\n            do {\n                if (!isNaN(elementNext.offsetLeft)) {\n                    xOffset += elementNext.offsetLeft;\n                    yOffset += elementNext.offsetTop;\n                }\n            } while ((elementNext = elementNext.offsetParent));\n\n            /*\n             * Due to the responsive nature of our pages, the displayed size of the surface image may be smaller than\n             * the original size, and the coordinates we receive from events are based on the currently displayed size.\n             */\n            x = ((x - xOffset) * (this.cxSurface / element.offsetWidth))|0;\n            y = ((y - yOffset) * (this.cySurface / element.offsetHeight))|0;\n\n            xInput = x - this.xInput;\n            yInput = y - this.yInput;\n\n            /*\n             * fInput is set if the event occurred somewhere within the input region (ie, the calculator keypad),\n             * either on a button or between buttons, whereas fButton is set if the event occurred squarely (rectangularly?)\n             * on a button.  fPower deals separately with the power button; it is set if the event occurred on the\n             * power button.\n             */\n            fInput = fButton = false;\n            fPower = (x >= this.xPower && x < this.xPower + this.cxPower && y >= this.yPower && y < this.yPower + this.cyPower);\n\n            /*\n             * I use the top of the input region, less some gap, to calculate a dividing line, above which\n             * default actions should be allowed, and below which they should not.  Ditto for any event inside\n             * the power button.\n             */\n            if (xInput >= 0 && xInput < this.cxInput && yInput + this.cyGap >= 0 || fPower) {\n                /*\n                 * If we allow touch events to be processed, they will generate mouse events as well, causing\n                 * confusion and delays.  We can sidestep that problem by preventing default actions on any event\n                 * that occurs within the input region.  One downside is that you can no longer scroll or zoom the\n                 * image using touch, but that may be just as well, because you probably don't want sloppy touches\n                 * moving your display around (or worse, a rapid double-tap zooming the display).  I do try to\n                 * make one small concession for two-finger zoom operations (see fMultiTouch), but that's a bit\n                 * fiddly, because it depends on both fingers hitting the surface at the same instant.\n                 */\n                if (!fMultiTouch && !this.fScroll) event.preventDefault();\n\n                if (xInput >= 0 && xInput < this.cxInput && yInput >= 0 && yInput < this.cyInput) {\n                    fInput = true;\n                    /*\n                     * The width and height of each column and row could be determined by computing cxGap + cxButton\n                     * and cyGap + cyButton, respectively, but those gap and button sizes are merely estimates, and should\n                     * only be used to help with the final button coordinate checks farther down.\n                     */\n                    let cxCol = (this.cxInput / this.nCols) | 0;\n                    let cyCol = (this.cyInput / this.nRows) | 0;\n                    let colInput = (xInput / cxCol) | 0;\n                    let rowInput = (yInput / cyCol) | 0;\n\n                    /*\n                     * If the grid is hexagonal (aka \"Lite-Brite\" mode), then the cells of even-numbered rows are\n                     * offset horizontally by 1/2 cell.  In addition, the last cell in those rows is unused, so if\n                     * after compensating by 1/2 cell, the target column is the last cell, we set xInput to -1,\n                     * effectively ignoring input on that cell.\n                     */\n                    if (this.fHexagonal && !(rowInput & 0x1)) {\n                        xInput -= (cxCol >> 1);\n                        colInput = (xInput / cxCol) | 0;\n                        if (colInput == this.nCols - 1) xInput = -1;\n                    }\n\n                    /*\n                     * (xCol,yCol) will be the top left corner of the button closest to the point of input.  However, that's\n                     * based on our gap estimate.  If things seem \"too tight\", shrink the gap estimates, which will automatically\n                     * increase the button size estimates.\n                     */\n                    let xCol = colInput * cxCol + (this.cxGap >> 1);\n                    let yCol = rowInput * cyCol + (this.cyGap >> 1);\n\n                    xInput -= xCol;\n                    yInput -= yCol;\n                    if (xInput >= 0 && xInput < this.cxButton && yInput >= 0 && yInput < this.cyButton) {\n                        col = colInput;\n                        row = rowInput;\n                        fButton = true;\n                    }\n                }\n            }\n        }\n\n        if (fMultiTouch) return;\n\n        if (action == Input.ACTION.PRESS) {\n            /*\n             * Record the position of the event, transitioning xStart and yStart to non-negative values.\n             */\n            this.xStart = x;\n            this.yStart = y;\n            if (fInput) {\n                /*\n                 * The event occurred in the input region, so we call setPosition() regardless of whether\n                 * it hit or missed a button.\n                 */\n                this.setPosition(col, row);\n                /*\n                 * On the other hand, if it DID hit a button, then we arm the auto-release timer, to ensure\n                 * a minimum amount of time (ie, BUTTON_DELAY).\n                 */\n                if (fButton && this.buttonDelay) {\n                    this.time.setTimer(this.timerInputRelease, this.buttonDelay, true);\n                }\n            } else if (fPower && this.onPower) {\n                this.onPower();\n            }\n        }\n        else if (action == Input.ACTION.MOVE) {\n            if (this.xStart >= 0 && this.yStart >= 0 && this.fDrag) {\n                this.setPosition(col, row);\n            }\n            else if (this.onHover) {\n                this.onHover(col, row);\n            }\n        }\n        else if (action == Input.ACTION.RELEASE) {\n            /*\n             * Don't immediately signal the release if the release timer is active (let the timer take care of it).\n             */\n            if (!this.buttonDelay || !this.time.isTimerSet(this.timerInputRelease)) {\n                this.setPosition(-1, -1);\n            }\n            this.xStart = this.yStart = -1;\n        }\n        else {\n            this.println(\"unrecognized action: \" + action);\n        }\n    }\n\n    /**\n     * setPosition(col, row)\n     *\n     * @this {Input}\n     * @param {number} col\n     * @param {number} row\n     */\n    setPosition(col, row)\n    {\n        if (col != this.col || row != this.row) {\n            this.col = col;\n            this.row = row;\n            if (this.onInput) this.onInput(col, row);\n        }\n    }\n}\n\nInput.ACTION = {\n    PRESS:      1,              // eg, an action triggered by a 'mousedown' or 'touchstart' event\n    MOVE:       2,              // eg, an action triggered by a 'mousemove' or 'touchmove' event\n    RELEASE:    3               // eg, an action triggered by a 'mouseup' (or 'mouseout') or 'touchend' event\n};\n\nInput.BINDING = {\n    POWER:      \"power\",\n    RESET:      \"reset\",\n    SURFACE:    \"surface\"\n};\n\nInput.KEYCODE = {               // keyCode from keydown/keyup events\n    0x08:       \"\\b\"            // backspace\n};\n\nInput.BUTTON_DELAY = 50;        // minimum number of milliseconds to ensure between button presses and releases\n\nInput.VERSION = +VERSION || 1.20;\n\n/**\n * @copyright https://www.pcjs.org/modules/devices/led.js (C) Jeff Parsons 2012-2018\n */\n\n/** @typedef {{ class: string, bindings: (Object|undefined), version: (number|undefined), overrides: (Array.<string>|undefined), type: number, width: (number|undefined), height: (number|undefined), cols: (number|undefined), colsExtra: (number|undefined), rows: (number|undefined), rowsExtra: (number|undefined), color: (string|undefined), backgroundColor: (string|undefined), fixed: (boolean|undefined), hexagonal: (boolean|undefined), highlight: (boolean|undefined), persistent: (boolean|undefined) }} */\nvar LEDConfig;\n\n/**\n * The ultimate goal is to provide support for a variety of LED types, such as:\n *\n * 1) LED Light (single light)\n * 2) LED Digit (7-segment digit)\n *\n * The initial goal is to manage a 12-element array of 7-segment LED digits for the TI-57.\n *\n * We create a \"view\" canvas element inside the specified \"container\" element, along with a \"grid\" canvas\n * where all the real drawing occurs; drawView() then renders the \"grid\" canvas onto the \"view\" canvas.\n *\n * Internally, our LED digits have a width and height of 96 and 128.  Those are \"grid\" dimensions which\n * cannot be changed, because our table of drawing coordinates in LED.SEGMENTS are hard-coded for those\n * dimensions.  The cell width and height that are specified as part of the LEDConfig are \"view\" dimensions,\n * which usually match the grid dimensions, but you're welcome to scale them up or down; the browser's\n * drawImage() function takes care of that.\n *\n * There is a low-level function, drawGridSegment(), for drawing specific LED segments of specific digits;\n * generally, you start with clearGrid(), draw all the segments for a given update, and then call drawView()\n * to make them visible.\n *\n * However, our Chip devices operate at a higher level.  They use setLEDState() to modify the state,\n * character, etc, that each of the LED cells should display, which updates our internal LED buffer.  Then\n * at whatever display refresh rate is set (typically 60Hz), drawBuffer() is called to see if the buffer\n * contents have been modified since the last refresh, and if so, it converts the contents of the buffer to\n * a string and calls drawString().\n *\n * This buffering strategy, combined with the buffer \"tickled\" flag (see below), not only makes life\n * simple for the Chip device, but also simulates how the display goes blank for short periods of time while\n * the Chip is busy performing calculations.\n *\n * @class {LED}\n * @unrestricted\n * @property {LEDConfig} config\n * @property {number} type (one of the LED.TYPE values)\n * @property {number} width (default is 96 for LED.TYPE.DIGIT, 32 otherwise; see LED.SIZES)\n * @property {number} height (default is 128 for LED.TYPE.DIGIT, 32 otherwise; see LED.SIZES)\n * @property {number} cols (default is 1)\n * @property {number} rows (default is 1)\n * @property {number} colsView (default is cols)\n * @property {number} rowsView (default is rows)\n * @property {string} color (default is none; ie, transparent foreground)\n * @property {string} colorBackground (default is none; ie, transparent background)\n * @property {boolean} fFixed (default is false, meaning the view may fill the container to its maximum size)\n * @property {boolean} fHexagonal (default is false)\n * @property {boolean} fHighlight (default is true)\n * @property {boolean} fPersistent (default is false for LED.TYPE.DIGIT, meaning the view will be blanked if not refreshed)\n * @property {number} widthView (computed)\n * @property {number} heightView (computed)\n * @property {number} widthGrid (computed)\n * @property {number} heightGrid (computed)\n * @property {HTMLCanvasElement} canvasView\n * @property {CanvasRenderingContext2D} contextView\n * @property {HTMLCanvasElement} canvasGrid\n * @property {CanvasRenderingContext2D} contextGrid\n * @property {{ container: Element|undefined }} bindings\n * @property {Array.<string|number|null>} buffer\n * @property {Array.<string|number>|null} bufferClone\n * @property {boolean} fBufferModified\n * @property {boolean} fTickled\n */\nclass LED extends Device {\n    /**\n     * LED(idMachine, idDevice, config)\n     *\n     * Sample config:\n     *\n     *      \"display\": {\n     *        \"class\": \"LED\",\n     *        \"type\": 3,\n     *        \"cols\": 12,\n     *        \"rows\": 1,\n     *        \"color\": \"red\",\n     *        \"bindings\": {\n     *          \"container\": \"displayTI57\"\n     *        }\n     *      }\n     *\n     * @this {LED}\n     * @param {string} idMachine\n     * @param {string} idDevice\n     * @param {LEDConfig} [config]\n     */\n    constructor(idMachine, idDevice, config)\n    {\n        super(idMachine, idDevice, LED.VERSION, config);\n\n        let container = this.bindings[LED.BINDING.CONTAINER];\n        if (!container) {\n            let sError = \"LED binding for '\" + LED.BINDING.CONTAINER + \"' missing: '\" + this.config.bindings[LED.BINDING.CONTAINER] + \"'\";\n            throw new Error(sError);\n        }\n\n        let canvasView = /** @type {HTMLCanvasElement} */ (document.createElement(\"canvas\"));\n        if (!canvasView || !canvasView.getContext) {\n            let sError = \"LED device requires HTML5 canvas support\";\n            container.innerHTML = sError;\n            throw new Error(sError);\n        }\n\n        this.container = container;\n        this.canvasView = canvasView;\n\n        this.type = this.getBounded(this.getDefaultNumber('type', LED.TYPE.ROUND), LED.TYPE.SMALL, LED.TYPE.DIGIT);\n        this.widthCell = LED.SIZES[this.type][0];\n        this.heightCell = LED.SIZES[this.type][1];\n        this.width = this.getDefaultNumber('width', this.widthCell);\n        this.height = this.getDefaultNumber('height', this.heightCell);\n        this.colsView = this.getDefaultNumber('cols',  1);\n        this.cols = this.colsView + this.getDefaultNumber('colsExtra', 0);\n        this.rowsView = this.getDefaultNumber('rows',  1);\n        this.rows = this.rowsView + this.getDefaultNumber('rowsExtra', 0);\n        this.widthView = this.width * this.colsView;\n        this.heightView = this.height * this.rowsView;\n\n        this.colorTransparent = this.getRGBAColor(\"black\", 0);\n        this.colorOn = this.getRGBColor(this.config['color']) || this.colorTransparent;\n        this.colorOff = this.getRGBAColor(this.colorOn, 1.0, 0.25);\n        this.colorHighlight = this.getRGBAColor(this.colorOn, 1.0, 2.0);\n        this.colorBackground = this.getRGBColor(this.config['backgroundColor']);\n\n        /*\n         * We generally want our view canvas to be \"responsive\", not \"fixed\" (ie, to automatically resize\n         * with changes to the overall window size), so we apply the following style attributes (formerly\n         * applied with the \"pcjs-canvas\" style in /modules/shared/templates/components.css):\n         *\n         *      width: 100%;\n         *      height: auto;\n         *\n         * But, if you really don't want that feature, then set the LED config's \"fixed\" property to true.\n         */\n        this.fFixed = this.getDefaultBoolean('fixed', false);\n        if (!this.fFixed) {\n            canvasView.style.width = \"100%\";\n            canvasView.style.height = \"auto\";\n        }\n\n        /*\n         * Hexagonal (aka \"Lite-Brite\" mode) and highlighting options\n         */\n        this.fHexagonal = this.getDefaultBoolean('hexagonal', false);\n        this.fHighlight = this.getDefaultBoolean('highlight', true);\n\n        /*\n         * Persistent LEDS are the default, except for LED.TYPE.DIGIT, which is used with calculator displays\n         * whose underlying hardware must constantly \"refresh\" the LEDs to prevent them from going dark.\n         */\n        this.fPersistent = this.getDefaultBoolean('persistent', (this.type < LED.TYPE.DIGIT));\n\n        canvasView.setAttribute(\"width\", this.widthView.toString());\n        canvasView.setAttribute(\"height\", this.heightView.toString());\n        canvasView.style.backgroundColor = this.colorTransparent;\n        container.appendChild(canvasView);\n        this.contextView = /** @type {CanvasRenderingContext2D} */ (canvasView.getContext(\"2d\"));\n\n        /*\n         * canvasGrid is where all LED segments are composited; then they're drawn onto canvasView.\n         */\n        this.canvasGrid = /** @type {HTMLCanvasElement} */ (document.createElement(\"canvas\"));\n        if (this.canvasGrid) {\n            this.canvasGrid.width = this.widthGrid = this.widthCell * this.colsView;\n            this.canvasGrid.height = this.heightGrid = this.heightCell * this.rowsView;\n            this.contextGrid = this.canvasGrid.getContext(\"2d\");\n        }\n\n        /*\n         * Time to allocate our internal LED buffer.  Other devices access the buffer through interfaces\n         * like setLEDState() and getLEDState().  The LED buffer contains four per elements per LED cell:\n         *\n         *      [0]:    state (eg, ON or OFF or a digit)\n         *      [1]:    color\n         *      [2]:    count(s) (eg, 0 to 8  4-bit counts)\n         *      [3]:    flags (eg, PERIOD, MODIFIED, etc)\n         *\n         * The LED buffer also contains an extra (scratch) row at the end.  This extra row, along with the\n         * dynamically allocated \"clone\" buffer, is used by the LED Controller for direct buffer manipulation;\n         * see the low-level getBuffer(), getBufferClone(), and swapBuffers() interfaces.\n         */\n        this.nBufferInc = 4;\n        this.nBufferCells = ((this.rows + 1) * this.cols) * this.nBufferInc;\n        this.buffer = new Array(this.nBufferCells);\n        this.bufferClone = null;\n        this.nBufferIncExtra = (this.colsView < this.cols? (this.cols - this.colsView) * 4 : 0);\n\n        /*\n         * fBufferModified is straightforward: set to true by any setLEDState() call that actually\n         * changed something in the LED buffer, set to false after every drawBuffer() call, periodic\n         * or otherwise.\n         *\n         * fTickled is a flag which, under normal (idle) circumstances, will constantly be set to\n         * true by periodic display operations that call setLEDState(); we clear it after every\n         * periodic drawBuffer(), so if the machine fails to execute a setBuffer() in a timely manner,\n         * we will see that fTickled hasn't been \"tickled\", and automatically blank the display.\n         * \n         * fDisplayOn is a global \"on/off\" switch for the entire display.\n         */\n        this.fBufferModified = this.fTickled = false;\n        this.fDisplayOn = true;\n\n        /*\n         * nShiftedLeft is an optimization that tells drawGrid() when it can minimize the number of\n         * individual cells to redraw, by shifting the entire grid image leftward and redrawing only\n         * the rightmost cells.\n         */\n        this.nShiftedLeft = 0;\n\n        /*\n         * This records the location of the most recent LED buffer location updated via setLEDState(),\n         * in case we want to highlight it.\n         */\n        this.iBufferRecent = -1;\n\n        let led = this;\n        this.time = /** @type {Time} */ (this.findDeviceByClass(Machine.CLASS.TIME));\n        if (this.time) {\n            this.time.addAnimator(function ledAnimate() {\n                led.drawBuffer();\n            });\n        }\n    }\n\n    /**\n     * clearBuffer(fDraw)\n     *\n     * @this {LED}\n     * @param {boolean} [fDraw]\n     */\n    clearBuffer(fDraw)\n    {\n        this.initBuffer(this.buffer);\n        this.fBufferModified = this.fTickled = true;\n        if (fDraw) this.drawBuffer(true);\n    }\n\n    /**\n     * clearGrid()\n     *\n     * @this {LED}\n     */\n    clearGrid()\n    {\n        if (this.colorBackground) {\n            this.contextGrid.fillStyle = this.colorBackground;\n            this.contextGrid.fillRect(0, 0, this.widthGrid, this.heightGrid);\n        } else {\n            this.contextGrid.clearRect(0, 0, this.widthGrid, this.heightGrid);\n        }\n    }\n\n    /**\n     * clearGridCell(col, row, xOffset)\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @param {number} xOffset\n     */\n    clearGridCell(col, row, xOffset)\n    {\n        let xDst = col * this.widthCell + xOffset;\n        let yDst = row * this.heightCell;\n        if (this.colorBackground) {\n            this.contextGrid.fillStyle = this.colorBackground;\n            this.contextGrid.fillRect(xDst, yDst, this.widthCell, this.heightCell);\n        } else {\n            this.contextGrid.clearRect(xDst, yDst, this.widthCell, this.heightCell);\n        }\n    }\n\n    /**\n     * drawBuffer(fForced)\n     *\n     * This is our periodic (60Hz) redraw function; however, it can also be called synchronously\n     * (eg, see clearBuffer()).  The other important periodic side-effect of this function is clearing\n     * fTickled, so that if no other setLEDState() calls occur between now and the next drawBuffer(),\n     * an automatic clearBuffer() will be triggered.  This simulates the normal blanking of the display\n     * whenever the machine performs lengthy calculations, because for an LED display to remain lit,\n     * the machine must perform a display operation (\"refresh\") at least 30-60 times per second.\n     *\n     * @this {LED}\n     * @param {boolean} [fForced] (if not set, this is a normal refresh call)\n     */\n    drawBuffer(fForced = false)\n    {\n        if (this.fBufferModified || fForced) {\n            if (this.type < LED.TYPE.DIGIT) {\n                this.drawGrid(fForced);\n            } else {\n                let s = \"\";\n                for (let i = 0; i < this.buffer.length; i += this.nBufferInc) {\n                    s += this.buffer[i] || ' ';\n                    if (this.buffer[i+3] & LED.FLAGS.PERIOD) s += '.';\n                }\n                this.drawString(s);\n            }\n            this.fBufferModified = false;\n            this.iBufferRecent = -1;\n        }\n        else if (!this.fPersistent && !this.fTickled) {\n            this.clearBuffer(true);\n        }\n        this.fTickled = false;\n    }\n\n    /**\n     * drawGrid(fForced)\n     *\n     * Used by drawBuffer() for LED.TYPE.ROUND, LED.TYPE.SQUARE, etc.\n     * \n     * If the buffer was recently shifted left (ie, nShiftedLeft is set), then we take advantage\n     * of that knowledge to use drawImage() to shift the entire grid image left, and then redrawing\n     * only the rightmost visible column.\n     *\n     * @this {LED}\n     * @param {boolean} [fForced] (if not set, this is a normal refresh call)\n     */\n    drawGrid(fForced)\n    {\n        let colRedraw = 0;\n        if (!this.fPersistent || fForced) {\n            this.clearGrid();\n        } else if (this.nShiftedLeft) {\n            colRedraw = this.colsView - this.nShiftedLeft;\n            let xStart = this.widthCell * this.nShiftedLeft;\n            let cxVisible = this.widthCell * colRedraw;\n            this.contextGrid.drawImage(this.canvasGrid, xStart, 0, cxVisible, this.heightGrid, 0, 0, cxVisible, this.heightGrid);\n            /*\n             * At this point, the only grid drawing we might need to do now is the column at colRedraw,\n             * but we still loop over the entire buffer to ensure all the cell MODIFIED states are in sync.\n             */\n        }\n        let i = 0;\n        for (let row = 0; row < this.rows; row++) {\n            for (let col = 0; col < this.colsView; col++) {\n                let state = this.buffer[i];\n                let color = this.buffer[i+1] || this.colorTransparent;\n                let fLeaveModified = false;\n                let fModified = !!(this.buffer[i+3] & LED.FLAGS.MODIFIED);\n                let fHighlight = (this.fHighlight && i == this.iBufferRecent);\n                if (!this.fDisplayOn && state) {\n                    state = LED.STATE.OFF;\n                    fModified = fLeaveModified = true;\n                }\n                if (fModified || fHighlight || fForced) {\n                    if (col >= colRedraw) {\n                        this.drawGridCell(state, color, col, row, fHighlight);\n                    }\n                    if (fHighlight || fLeaveModified) {\n                        this.buffer[i+3] |= LED.FLAGS.MODIFIED;\n                    } else {\n                        this.buffer[i+3] &= ~LED.FLAGS.MODIFIED;\n                    }\n                }\n                i += this.nBufferInc;\n            }\n            i += this.nBufferIncExtra;\n        }\n        this.nShiftedLeft = 0;\n        this.drawView();\n    }\n\n    /**\n     * drawGridCell(state, color, col, row, fHighlight)\n     *\n     * Used by drawGrid() for LED.TYPE.ROUND, LED.TYPE.SQUARE, etc.\n     *\n     * @this {LED}\n     * @param {string} state (eg, LED.STATE.ON or LED.STATE.OFF)\n     * @param {string} [color]\n     * @param {number} [col] (default is zero)\n     * @param {number} [row] (default is zero)\n     * @param {boolean} [fHighlight] (true if the cell should be highlighted; default is false)\n     */\n    drawGridCell(state, color, col = 0, row = 0, fHighlight = false)\n    {\n        let xOffset = 0;\n        if (this.fHexagonal) {\n            if (!(row & 0x1)) {\n                xOffset = (this.widthCell >> 1);\n                if (col == this.colsView - 1) return;\n            }\n        }\n\n        let colorOn, colorOff;\n        if (!color || color == this.colorOn) {\n            colorOn = fHighlight? this.colorHighlight : this.colorOn;\n            colorOff = this.colorOff;\n        } else {\n            colorOn = fHighlight? this.getRGBAColor(color, 1.0, 2.0) : color;\n            colorOff = this.getRGBAColor(color, 1.0, 0.25);\n        }\n\n        let fTransparent = false;\n        let colorCell = (state? colorOn : colorOff);\n        if (colorOn == this.colorTransparent) {\n            colorCell = this.colorBackground;\n            fTransparent = true;\n        }\n\n        let xDst = col * this.widthCell + xOffset;\n        let yDst = row * this.heightCell;\n\n        /*\n         * If this is NOT a persistent LED display, then drawGrid() will have done a preliminary clearGrid(),\n         * eliminating the need to clear individual cells.  Whereas if this IS a persistent LED display, then\n         * we need to clear cells on an as-drawn basis.  If we don't, there could be residual \"bleed over\"\n         * around the edges of the shape we drew here previously.\n         */\n        if (this.fPersistent) {\n            this.clearGridCell(col, row, xOffset);\n        }\n\n        this.contextGrid.fillStyle = colorCell;\n\n        let coords = LED.SHAPES[this.type];\n        if (coords.length == 3) {\n            this.contextGrid.beginPath();\n            this.contextGrid.arc(xDst + coords[0], yDst + coords[1], coords[2], 0, Math.PI * 2);\n            if (fTransparent) {\n                /*\n                 * The following code works as well:\n                 *\n                 *      this.contextGrid.save();\n                 *      this.contextGrid.clip();\n                 *      this.contextGrid.clearRect(xDst, yDst, this.widthCell, this.heightCell);\n                 *      this.contextGrid.restore();\n                 *\n                 * but I assume it's not as efficient.\n                 */\n                this.contextGrid.globalCompositeOperation = \"destination-out\";\n                this.contextGrid.fill();\n                this.contextGrid.globalCompositeOperation = \"source-over\";\n            } else {\n                this.contextGrid.fill();\n            }\n        } else {\n            this.contextGrid.fillRect(xDst + coords[0], yDst + coords[1], coords[2], coords[3]);\n        }\n    }\n\n    /**\n     * drawGridSegment(seg, col, row)\n     *\n     * Used by drawSymbol() for LED.TYPE.DIGIT.\n     *\n     * @this {LED}\n     * @param {string} seg (eg, \"A\")\n     * @param {number} [col] (default is zero)\n     * @param {number} [row] (default is zero)\n     */\n    drawGridSegment(seg, col = 0, row = 0)\n    {\n        let coords = LED.SEGMENTS[seg];\n        if (coords) {\n            let xDst = col * this.widthCell;\n            let yDst = row * this.heightCell;\n            this.contextGrid.fillStyle = this.colorOn;\n            this.contextGrid.beginPath();\n            if (coords.length == 3) {\n                this.contextGrid.arc(xDst + coords[0], yDst + coords[1], coords[2], 0, Math.PI * 2);\n            } else {\n                for (let i = 0; i < coords.length; i += 2) {\n                    if (!i) {\n                        this.contextGrid.moveTo(xDst + coords[i], yDst + coords[i+1]);\n                    } else {\n                        this.contextGrid.lineTo(xDst + coords[i], yDst + coords[i+1]);\n                    }\n                }\n            }\n            this.contextGrid.closePath();\n            this.contextGrid.fill();\n        }\n    }\n\n    /**\n     * drawString(s)\n     *\n     * Used by drawBuffer() for LED.TYPE.DIGIT.\n     *\n     * @this {LED}\n     * @param {string} s\n     */\n    drawString(s)\n    {\n        this.clearGrid();\n        for (let i = 0, col = 0, row = 0; i < s.length; i++) {\n            let ch = s[i];\n            if (ch == '.') {\n                if (col) col--;\n            }\n            this.drawSymbol(ch, col, row);\n            if (++col == this.colsView) {\n                col = 0;\n                if (++row == this.rows) {\n                    break;\n                }\n            }\n        }\n        this.drawView();\n    }\n\n    /**\n     * drawSymbol(symbol, col, row)\n     *\n     * Used by drawString() for LED.TYPE.DIGIT.\n     *\n     * If the symbol does not exist in LED.SYMBOL_SEGMENTS, then nothing is drawn.\n     *\n     * @this {LED}\n     * @param {string} symbol\n     * @param {number} [col] (default is zero)\n     * @param {number} [row] (default is zero)\n     */\n    drawSymbol(symbol, col = 0, row = 0)\n    {\n        let segments = LED.SYMBOL_SEGMENTS[symbol];\n        if (segments) {\n            for (let i = 0; i < segments.length; i++) {\n                this.drawGridSegment(segments[i], col, row)\n            }\n        }\n    }\n\n    /**\n     * drawView()\n     *\n     * @this {LED}\n     */\n    drawView()\n    {\n        /*\n         * Setting the 'globalCompositeOperation' property of a 2D context is something you rarely need to do,\n         * because the default draw behavior (\"source-over\") is fine for most cases.  One case where it is NOT\n         * fine is when we're using a transparent background color, because it doesn't copy over any transparent\n         * pixels, effectively making it impossible to \"turn off\" any previously drawn LED segments.  To force\n         * that behavior, we must select the \"copy\" behavior.\n         *\n         * Refer to: https://www.w3.org/TR/2dcontext/#dom-context-2d-globalcompositeoperation\n         */\n        this.contextView.globalCompositeOperation = (this.colorBackground && this.colorOn != this.colorTransparent)? \"source-over\" : \"copy\";\n        this.contextView.drawImage(this.canvasGrid, 0, 0, this.widthGrid, this.heightGrid, 0, 0, this.widthView, this.heightView);\n    }\n\n    /**\n     * enableDisplay(on)\n     * \n     * @this {LED}\n     * @param {boolean} [on]\n     */\n    enableDisplay(on = true)\n    {\n        if (this.fDisplayOn != on) {\n            this.fDisplayOn = on;\n            this.fBufferModified = true;\n        }\n    }\n    \n    /**\n     * getBuffer()\n     *\n     * @this {LED}\n     * @returns {Array}\n     */\n    getBuffer()\n    {\n        return this.buffer;\n    }\n\n    /**\n     * getBufferClone()\n     *\n     * @this {LED}\n     * @returns {Array}\n     */\n    getBufferClone()\n    {\n        if (!this.bufferClone) {\n            this.bufferClone = new Array(this.nBufferCells);\n            this.initBuffer(this.bufferClone);\n        }\n        return this.bufferClone;\n    }\n\n    /**\n     * getLEDColor(col, row)\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @returns {string}\n     */\n    getLEDColor(col, row)\n    {\n        let i = (row * this.cols + col) * this.nBufferInc;\n        return this.buffer[i+1] || this.colorTransparent;\n    }\n\n    /**\n     * getLEDColorValues(col, row, rgb)\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @param {Array.<number>} rgb\n     * @returns {boolean}\n     */\n    getLEDColorValues(col, row, rgb)\n    {\n        let i = (row * this.cols + col) * this.nBufferInc;\n        return this.parseRGBValues(this.buffer[i+1] || this.colorTransparent, rgb);\n    }\n\n    /**\n     * getLEDCounts(col, row, counts)\n     *\n     * This function returns success (true) ONLY for cells that are not transparent.\n     *\n     * For a typical \"Lite-Brite\" grid, transparent cells are considered \"empty\", so we want to\n     * ignore them.\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @param {Array.<number>} counts\n     * @returns {boolean}\n     */\n    getLEDCounts(col, row, counts)\n    {\n        let fSuccess = false;\n        let i = (row * this.cols + col) * this.nBufferInc;\n        if (i <= this.buffer.length - this.nBufferInc && this.buffer[i+1]) {\n            fSuccess = true;\n            let bits = this.buffer[i+2];\n            for (let c = counts.length - 1; c >= 0; c--) {\n                counts[c] = bits & 0xf;\n                bits >>>= 4;\n            }\n        }\n        return fSuccess;\n    }\n\n    /**\n     * getLEDCountsPacked(col, row)\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @returns {number}\n     */\n    getLEDCountsPacked(col, row)\n    {\n        let i = (row * this.cols + col) * this.nBufferInc;\n        return (i <= this.buffer.length - this.nBufferInc)? this.buffer[i+2] : 0;\n    }\n\n    /**\n     * getLEDState(col, row)\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @returns {number|undefined}\n     */\n    getLEDState(col, row)\n    {\n        let state;\n        let i = (row * this.cols + col) * this.nBufferInc;\n        if (i <= this.buffer.length - this.nBufferInc) {\n            state = this.buffer[i];\n        }\n        return state;\n    }\n\n    /**\n     * getDefaultColor()\n     *\n     * @this {LED}\n     * @returns {string}\n     */\n    getDefaultColor()\n    {\n        return this.colorOn;\n    }\n\n    /**\n     * getRGBColor(color, colorDefault)\n     *\n     * Returns a color string in the \"hex\" format that fillStyle recognizes (eg, \"#rrggbb\").\n     *\n     * The default is optional, allowing an undefined color to remain undefined if we want to use\n     * that to signal transparency (as in the case of colorBackground).\n     *\n     * @this {LED}\n     * @param {string|undefined} color\n     * @param {string} [colorDefault]\n     * @returns {string|undefined}\n     */\n    getRGBColor(color, colorDefault)\n    {\n        color = color || colorDefault;\n        return color && LED.COLORS[color] || color;\n    }\n\n    /**\n     * getRGBColorString(rgb)\n     *\n     * Returns a color string fillStyle recognizes (ie, \"#rrggbb\", or \"rgba(r,g,b,a)\" if an alpha value\n     * less than 1 is set).\n     *\n     * TODO: Cache frequently requested colors.\n     * \n     * @this {LED}\n     * @param {Array.<number>} rgb\n     * @returns {string}\n     */\n    getRGBColorString(rgb)\n    {\n        let s;\n        if (rgb.length < 4 || rgb[3] == 1) {\n            s = this.sprintf(\"#%02x%02x%02x\", rgb[0], rgb[1], rgb[2]);\n        } else {\n            s = this.sprintf(\"rgba(%d,%d,%d,%d)\", rgb[0], rgb[1], rgb[2], rgb[3]);\n        }\n        return s;\n    }\n\n    /**\n     * getRGBAColor(color, alpha, brightness)\n     *\n     * Returns a color string in the \"rgba\" format that fillStyle recognizes (eg, \"rgba(255, 255, 255, 0)\").\n     *\n     * I used to use \"alpha\" to adjust the brightness, but it's safer to use the \"brightness\" parameter,\n     * which simply scales all the RGB values.  That's because if any shapes are redrawn using a fillStyle\n     * with alpha < 1.0, the target alpha values will be added instead of replaced, resulting in progressively\n     * brighter shapes; probably not what you want.\n     *\n     * @this {LED}\n     * @param {string} color\n     * @param {number} [alpha]\n     * @param {number} [brightness]\n     * @returns {string}\n     */\n    getRGBAColor(color, alpha = 1.0, brightness = 1.0)\n    {\n        if (color) {\n            let rgb = [];\n            color = LED.COLORS[color] || color;\n            if (this.parseRGBValues(color, rgb)) {\n                color = \"rgba(\";\n                let i;\n                for (i = 0; i < 3; i++) {\n                    let n = Math.round(rgb[i] * brightness);\n                    n = (n < 0? 0 : (n > 255? 255 : n));\n                    color += n + \",\";\n                }\n                color += (i < rgb.length? rgb[i] : alpha) + \")\";\n            }\n        }\n        return color;\n    }\n\n    /**\n     * initBuffer(buffer)\n     *\n     * @this {LED}\n     * @param {Array.<number|string|null>} buffer\n     */\n    initBuffer(buffer)\n    {\n        for (let i = 0; i < buffer.length; i += this.nBufferInc) {\n            this.initCell(buffer, i);\n        }\n    }\n\n    /**\n     * initCell(buffer, iCell)\n     *\n     * @this {LED}\n     * @param {Array.<number|string|null>} buffer\n     * @param {number} iCell\n     */\n    initCell(buffer, iCell)\n    {\n        if (this.type < LED.TYPE.DIGIT) {\n            buffer[iCell] = LED.STATE.OFF;\n        } else {\n            buffer[iCell] = ' ';\n        }\n        buffer[iCell+1] = (this.colorOn == this.colorTransparent? null : this.colorOn);\n        buffer[iCell+2] = 0;\n        buffer[iCell+3] = LED.FLAGS.MODIFIED;\n    }\n\n    /**\n     * loadState(state)\n     *\n     * If any saved values don't match (possibly overridden), abandon the given state and return false.\n     *\n     * @this {LED}\n     * @param {Array} state\n     * @returns {boolean}\n     */\n    loadState(state)\n    {\n        let colorOn = state.shift();\n        let colorBackground = state.shift();\n        let buffer = state.shift();\n        if (colorOn == this.colorOn && colorBackground == this.colorBackground && buffer && buffer.length == this.buffer.length) {\n            this.buffer = buffer;\n            /*\n             * Loop over all the buffer colors to fix a legacy problem (ie, before we started storing null for colorTransparent)\n             */\n            for (let i = 0; i <= this.buffer.length - this.nBufferInc; i += this.nBufferInc) {\n                if (this.buffer[i+1] == this.colorTransparent) this.buffer[i+1] = null;\n            }\n            this.drawBuffer(true);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * parseRGBValues(color, rgb)\n     *\n     * @this {LED}\n     * @param {string} color\n     * @param {Array.<number>} rgb\n     * @returns {boolean}\n     */\n    parseRGBValues(color, rgb)\n    {\n        let base = 16;\n        let match = color.match(/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i);\n        if (!match) {\n            base = 10;\n            match = color.match(/^rgba?\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,?\\s*(\\d+|)\\)$/i);\n        }\n        if (match) {\n            let i;\n            for (i = 1; i < match.length; i++) {\n                rgb[i-1] = Number.parseInt(match[i], base);\n            }\n            rgb.length = i-1;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * saveState(state)\n     *\n     * @this {LED}\n     * @param {Array} state\n     */\n    saveState(state)\n    {\n        if (this.buffer) {\n            state.push(this.colorOn);\n            state.push(this.colorBackground);\n            state.push(this.buffer);\n        }\n    }\n\n    /**\n     * setContainerStyle(sAttr, sValue)\n     * \n     * @this {LED}\n     * @param {string} sAttr \n     * @param {string} sValue \n     */\n    setContainerStyle(sAttr, sValue)\n    {\n        if (this.container) this.container.style[sAttr] = sValue;\n    }\n\n    /**\n     * setLEDColor(col, row, color)\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @param {string} [color]\n     * @returns {boolean|null} (true if this call modified the LED color, false if not, null if error)\n     */\n    setLEDColor(col, row, color)\n    {\n        let fModified = null;\n        if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {\n            fModified = false;\n            let colorNew = color || this.colorOn;\n            if (colorNew == this.colorTransparent) colorNew = null;\n            let i = (row * this.cols + col) * this.nBufferInc;\n            if (this.buffer[i+1] !== colorNew) {\n                this.buffer[i+1] = colorNew;\n                if (!colorNew) this.buffer[i] = LED.STATE.OFF;  // transparent LEDs are automatically turned off\n                this.buffer[i+3] |= LED.FLAGS.MODIFIED;\n                this.fBufferModified = fModified = true;\n            }\n            this.iBufferRecent = i;\n            this.fTickled = true;\n        }\n        return fModified;\n    }\n\n    /**\n     * setLEDCounts(col, row, counts)\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @param {Array.<number>} counts\n     * @returns {boolean|null} (true if this call modified the LED color, false if not, null if error)\n     */\n    setLEDCounts(col, row, counts)\n    {\n        let fModified = null;\n        if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {\n            fModified = false;\n            let i = (row * this.cols + col) * this.nBufferInc;\n            let bits = 0;\n            if (this.buffer[i+1]) {                             // only non-transparent LEDs are allowed to set counters\n                for (let c = 0; c < counts.length; c++) {\n                    bits = (bits << 4) | (counts[c] & 0xf);\n                }\n            }\n            if (this.buffer[i+2] !== bits) {\n                this.buffer[i+2] = bits;\n                this.buffer[i+3] |= LED.FLAGS.MODIFIED;\n                this.fBufferModified = fModified = true;\n            }\n            this.iBufferRecent = i;\n            this.fTickled = true;\n        }\n        return fModified;\n    }\n\n    /**\n     * setLEDCountsPacked(col, row, counts)\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @param {number} counts\n     * @returns {boolean|null} (true if this call modified the LED state, false if not, null if error)\n     */\n    setLEDCountsPacked(col, row, counts)\n    {\n        let i = (row * this.cols + col) * this.nBufferInc;\n        if (i <= this.buffer.length - this.nBufferInc) {\n            if (this.buffer[i+2] != counts) {\n                this.buffer[i+2] = counts;\n                return true;\n            }\n            return false;\n        }\n        return null;\n    }\n\n    /**\n     * setLEDState(col, row, state, flags)\n     *\n     * For LED.TYPE.ROUND or LED.TYPE.SQUARE, the state parameter should be LED.STATE.OFF or LED.STATE.ON.\n     *\n     * @this {LED}\n     * @param {number} col\n     * @param {number} row\n     * @param {string|number} state (new state for the specified cell)\n     * @param {number} [flags]\n     * @returns {boolean} (true if this call modified the LED state, false if not)\n     */\n    setLEDState(col, row, state, flags = 0)\n    {\n        let fModified = false;\n        let flagsSet = flags & LED.FLAGS.SET;\n        let i = (row * this.cols + col) * this.nBufferInc;\n        if (i <= this.buffer.length - this.nBufferInc) {\n            if (this.buffer[i] !== state || (this.buffer[i+3] & LED.FLAGS.SET) !== flagsSet) {\n                this.buffer[i] = state;\n                this.buffer[i+3] = (this.buffer[i+3] & ~LED.FLAGS.SET) | flagsSet | LED.FLAGS.MODIFIED;\n                this.fBufferModified = fModified = true;\n            }\n            this.iBufferRecent = i;\n            this.fTickled = true;\n            this.nShiftedLeft = 0;\n        }\n        return fModified;\n    }\n\n    /**\n     * swapBuffers()\n     *\n     * @this {LED}\n     */\n    swapBuffers()\n    {\n        let buffer = this.buffer;\n        this.buffer = this.bufferClone;\n        this.bufferClone = buffer;\n        this.fBufferModified = true;\n    }\n}\n\nLED.TYPE = {\n    SMALL:      0,      // a smaller, more efficient (round) LED for large grids\n    ROUND:      1,      // a single (round) LED\n    SQUARE:     2,      // a single (square) LED\n    DIGIT:      3       // a 7-segment (digit) LED, with optional period as an 8th segment\n};\n\nLED.BINDING = {\n    CONTAINER:  \"container\"\n};\n\nLED.COLORS = {\n    \"aliceblue\":            \"#f0f8ff\",\n    \"antiquewhite\":         \"#faebd7\",\n    \"aqua\":                 \"#00ffff\",\n    \"aquamarine\":           \"#7fffd4\",\n    \"azure\":                \"#f0ffff\",\n    \"beige\":                \"#f5f5dc\",\n    \"bisque\":               \"#ffe4c4\",\n    \"black\":                \"#000000\",\n    \"blanchedalmond\":       \"#ffebcd\",\n    \"blue\":                 \"#0000ff\",\n    \"blueviolet\":           \"#8a2be2\",\n    \"brown\":                \"#a52a2a\",\n    \"burlywood\":            \"#deb887\",\n    \"cadetblue\":            \"#5f9ea0\",\n    \"chartreuse\":           \"#7fff00\",\n    \"chocolate\":            \"#d2691e\",\n    \"coral\":                \"#ff7f50\",\n    \"cornflowerblue\":       \"#6495ed\",\n    \"cornsilk\":             \"#fff8dc\",\n    \"crimson\":              \"#dc143c\",\n    \"cyan\":                 \"#00ffff\",\n    \"darkblue\":             \"#00008b\",\n    \"darkcyan\":             \"#008b8b\",\n    \"darkgoldenrod\":        \"#b8860b\",\n    \"darkgray\":             \"#a9a9a9\",\n    \"darkgreen\":            \"#006400\",\n    \"darkkhaki\":            \"#bdb76b\",\n    \"darkmagenta\":          \"#8b008b\",\n    \"darkolivegreen\":       \"#556b2f\",\n    \"darkorange\":           \"#ff8c00\",\n    \"darkorchid\":           \"#9932cc\",\n    \"darkred\":              \"#8b0000\",\n    \"darksalmon\":           \"#e9967a\",\n    \"darkseagreen\":         \"#8fbc8f\",\n    \"darkslateblue\":        \"#483d8b\",\n    \"darkslategray\":        \"#2f4f4f\",\n    \"darkturquoise\":        \"#00ced1\",\n    \"darkviolet\":           \"#9400d3\",\n    \"deeppink\":             \"#ff1493\",\n    \"deepskyblue\":          \"#00bfff\",\n    \"dimgray\":              \"#696969\",\n    \"dodgerblue\":           \"#1e90ff\",\n    \"firebrick\":            \"#b22222\",\n    \"floralwhite\":          \"#fffaf0\",\n    \"forestgreen\":          \"#228b22\",\n    \"fuchsia\":              \"#ff00ff\",\n    \"gainsboro\":            \"#dcdcdc\",\n    \"ghostwhite\":           \"#f8f8ff\",\n    \"gold\":                 \"#ffd700\",\n    \"goldenrod\":            \"#daa520\",\n    \"gray\":                 \"#808080\",\n    \"green\":                \"#008000\",\n    \"greenyellow\":          \"#adff2f\",\n    \"honeydew\":             \"#f0fff0\",\n    \"hotpink\":              \"#ff69b4\",\n    \"indianred \":           \"#cd5c5c\",\n    \"indigo\":               \"#4b0082\",\n    \"ivory\":                \"#fffff0\",\n    \"khaki\":                \"#f0e68c\",\n    \"lavender\":             \"#e6e6fa\",\n    \"lavenderblush\":        \"#fff0f5\",\n    \"lawngreen\":            \"#7cfc00\",\n    \"lemonchiffon\":         \"#fffacd\",\n    \"lightblue\":            \"#add8e6\",\n    \"lightcoral\":           \"#f08080\",\n    \"lightcyan\":            \"#e0ffff\",\n    \"lightgoldenrodyellow\": \"#fafad2\",\n    \"lightgrey\":            \"#d3d3d3\",\n    \"lightgreen\":           \"#90ee90\",\n    \"lightpink\":            \"#ffb6c1\",\n    \"lightsalmon\":          \"#ffa07a\",\n    \"lightseagreen\":        \"#20b2aa\",\n    \"lightskyblue\":         \"#87cefa\",\n    \"lightslategray\":       \"#778899\",\n    \"lightsteelblue\":       \"#b0c4de\",\n    \"lightyellow\":          \"#ffffe0\",\n    \"lime\":                 \"#00ff00\",\n    \"limegreen\":            \"#32cd32\",\n    \"linen\":                \"#faf0e6\",\n    \"magenta\":              \"#ff00ff\",\n    \"maroon\":               \"#800000\",\n    \"mediumaquamarine\":     \"#66cdaa\",\n    \"mediumblue\":           \"#0000cd\",\n    \"mediumorchid\":         \"#ba55d3\",\n    \"mediumpurple\":         \"#9370d8\",\n    \"mediumseagreen\":       \"#3cb371\",\n    \"mediumslateblue\":      \"#7b68ee\",\n    \"mediumspringgreen\":    \"#00fa9a\",\n    \"mediumturquoise\":      \"#48d1cc\",\n    \"mediumvioletred\":      \"#c71585\",\n    \"midnightblue\":         \"#191970\",\n    \"mintcream\":            \"#f5fffa\",\n    \"mistyrose\":            \"#ffe4e1\",\n    \"moccasin\":             \"#ffe4b5\",\n    \"navajowhite\":          \"#ffdead\",\n    \"navy\":                 \"#000080\",\n    \"oldlace\":              \"#fdf5e6\",\n    \"olive\":                \"#808000\",\n    \"olivedrab\":            \"#6b8e23\",\n    \"orange\":               \"#ffa500\",\n    \"orangered\":            \"#ff4500\",\n    \"orchid\":               \"#da70d6\",\n    \"palegoldenrod\":        \"#eee8aa\",\n    \"palegreen\":            \"#98fb98\",\n    \"paleturquoise\":        \"#afeeee\",\n    \"palevioletred\":        \"#d87093\",\n    \"papayawhip\":           \"#ffefd5\",\n    \"peachpuff\":            \"#ffdab9\",\n    \"peru\":                 \"#cd853f\",\n    \"pink\":                 \"#ffc0cb\",\n    \"plum\":                 \"#dda0dd\",\n    \"powderblue\":           \"#b0e0e6\",\n    \"purple\":               \"#800080\",\n    \"rebeccapurple\":        \"#663399\",\n    \"red\":                  \"#ff0000\",\n    \"rosybrown\":            \"#bc8f8f\",\n    \"royalblue\":            \"#4169e1\",\n    \"saddlebrown\":          \"#8b4513\",\n    \"salmon\":               \"#fa8072\",\n    \"sandybrown\":           \"#f4a460\",\n    \"seagreen\":             \"#2e8b57\",\n    \"seashell\":             \"#fff5ee\",\n    \"sienna\":               \"#a0522d\",\n    \"silver\":               \"#c0c0c0\",\n    \"skyblue\":              \"#87ceeb\",\n    \"slateblue\":            \"#6a5acd\",\n    \"slategray\":            \"#708090\",\n    \"snow\":                 \"#fffafa\",\n    \"springgreen\":          \"#00ff7f\",\n    \"steelblue\":            \"#4682b4\",\n    \"tan\":                  \"#d2b48c\",\n    \"teal\":                 \"#008080\",\n    \"thistle\":              \"#d8bfd8\",\n    \"tomato\":               \"#ff6347\",\n    \"turquoise\":            \"#40e0d0\",\n    \"violet\":               \"#ee82ee\",\n    \"wheat\":                \"#f5deb3\",\n    \"white\":                \"#ffffff\",\n    \"whitesmoke\":           \"#f5f5f5\",\n    \"yellow\":               \"#ffff00\",\n    \"yellowgreen\":          \"#9acd32\"\n};\n\nLED.STATE = {\n    OFF:        0,\n    ON:         1\n};\n\n/*\n * NOTE: Although technically the MODIFIED flag is an internal flag, it may be set explicitly as well;\n * the ROM device uses the setLEDState() flags parameter to set it, in order to trigger highlighting of\n * the most recently active LED.\n */\nLED.FLAGS = {\n    NONE:       0x00,\n    SET:        0x81,   // bits that may be set using the flags parameter of setLEDState()\n    PERIOD:     0x01,   // used with DIGIT-type LED to indicate that the period \"segment\" should be on, too\n    MODIFIED:   0x80,   // cell has been modified since the last time it was drawn\n};\n\nLED.SHAPES = {\n    [LED.TYPE.SMALL]:   [4, 4, 4],\n    [LED.TYPE.ROUND]:   [16, 16, 14],\n    [LED.TYPE.SQUARE]:  [2, 2, 28, 28]\n};\n\nLED.SIZES = [\n    [8,   8],           // LED.TYPE.SMALL\n    [32,  32],          // LED.TYPE.ROUND\n    [32,  32],          // LED.TYPE.SQUARE\n    [96, 128]           // LED.TYPE.DIGIT\n];\n\n/*\n * The segments are arranged roughly as follows, in a 96x128 grid:\n *\n *      AAAA\n *     F    B\n *     F    B\n *      GGGG\n *     E    C\n *     E    C\n *      DDDD P\n *\n * The following arrays specify pairs of moveTo()/lineTo() coordinates, used by drawGridSegment().  They all\n * assume the hard-coded width and height in LED.SIZES[LED.TYPE.DIGIT] specified above.  If there is a triplet\n * instead of one or more pairs (eg, the 'P' or period segment), then the coordinates are treated as arc()\n * parameters.\n */\nLED.SEGMENTS = {\n    'A':        [30,   8,  79,   8,  67,  19,  37,  19],\n    'B':        [83,  10,  77,  52,  67,  46,  70,  22],\n    'C':        [77,  59,  71, 100,  61,  89,  64,  64],\n    'D':        [28,  91,  58,  91,  69, 104,  15, 104],\n    'E':        [18,  59,  28,  64,  25,  88,  12, 100],\n    'F':        [24,  10,  34,  21,  31,  47,  18,  52],\n    'G':        [24,  56,  34,  50,  60,  50,  71,  56,  61,  61,  33,  61],\n    'P':        [80, 102,  8]\n};\n\n/*\n * Segmented symbols are formed with the following segments.\n */\nLED.SYMBOL_SEGMENTS = {\n    ' ':        [],\n    '0':        ['A','B','C','D','E','F'],\n    '1':        ['B','C'],\n    '2':        ['A','B','D','E','G'],\n    '3':        ['A','B','C','D','G'],\n    '4':        ['B','C','F','G'],\n    '5':        ['A','C','D','F','G'],\n    '6':        ['A','C','D','E','F','G'],\n    '7':        ['A','B','C'],\n    '8':        ['A','B','C','D','E','F','G'],\n    '9':        ['A','B','C','D','F','G'],\n    '-':        ['G'],\n    'E':        ['A','D','E','F','G'],\n    '.':        ['P']\n};\n\nLED.VERSION = +VERSION || 1.20;\n\n/**\n * @copyright https://www.pcjs.org/modules/devices/rom.js (C) Jeff Parsons 2012-2018\n */\n\n/** @typedef {{ class: string, bindings: (Object|undefined), version: (number|undefined), overrides: (Array.<string>|undefined), wordSize: number, valueSize: number, valueTotal: number, littleEndian: boolean, file: string, reference: string, chipID: string, revision: (number|undefined), colorROM: (string|undefined), backgroundColorROM: (string|undefined), values: Array.<number> }} */\nvar ROMConfig;\n\n/**\n * @class {ROM}\n * @unrestricted\n * @property {ROMConfig} config\n * @property {Array.<number>} data\n * @property {number} addrMask\n */\nclass ROM extends Device {\n    /**\n     * ROM(idMachine, idDevice, config)\n     *\n     * Sample config:\n     *\n     *      \"rom\": {\n     *        \"class\": \"ROM\",\n     *        \"wordSize\": 13,\n     *        \"valueSize\": 16,\n     *        \"valueTotal\": 2048,\n     *        \"littleEndian\": true,\n     *        \"file\": \"ti57le.bin\",\n     *        \"reference\": \"\",\n     *        \"chipID\": \"TMC1501NC DI 7741\",\n     *        \"revision\": \"0\",\n     *        \"bindings\": {\n     *          \"array\": \"romArrayTI57\",\n     *          \"cellDesc\": \"romCellTI57\"\n     *        },\n     *        \"overrides\": [\"colorROM\",\"backgroundColorROM\"],\n     *        \"values\": [\n     *          ...\n     *        ]\n     *      }\n     *\n     * @this {ROM}\n     * @param {string} idMachine\n     * @param {string} idDevice\n     * @param {ROMConfig} [config]\n     */\n    constructor(idMachine, idDevice, config)\n    {\n        super(idMachine, idDevice, ROM.VERSION, config);\n\n        this.data = config['values'];\n\n        /*\n         * This addrMask calculation assumes that the data array length is a power-of-two (which we assert).\n         */\n        this.addrMask = this.data.length - 1;\n\n\n        /*\n         * If an \"array\" binding has been supplied, then create an LED array sufficiently large to represent the\n         * entire ROM.  If the power-of-two is odd, then we will favor a slightly wider array over a taller one,\n         * by virtue of using Math.ceil() for cols and Math.floor() for rows.\n         */\n        if (this.bindings[ROM.BINDING.ARRAY]) {\n            let rom = this;\n            let addrLines = Math.log2(this.data.length) / 2;\n            this.cols = Math.pow(2, Math.ceil(addrLines));\n            this.rows = Math.pow(2, Math.floor(addrLines));\n            let configLEDs = {\n                \"class\":            \"LED\",\n                \"bindings\":         {\"container\": this.getBindingID(ROM.BINDING.ARRAY)},\n                \"type\":             LED.TYPE.ROUND,\n                \"cols\":             this.cols,\n                \"rows\":             this.rows,\n                \"color\":            this.getDefaultString('colorROM', \"green\"),\n                \"backgroundColor\":  this.getDefaultString('backgroundColorROM', \"black\"),\n                \"persistent\":       true\n            };\n            this.ledArray = new LED(idMachine, idDevice + \"LEDs\", configLEDs);\n            this.clearArray();\n            let configInput = {\n                \"class\":        \"Input\",\n                \"location\":     [0, 0, this.ledArray.widthView, this.ledArray.heightView, this.cols, this.rows],\n                \"bindings\":     {\"surface\": this.getBindingID(ROM.BINDING.ARRAY)}\n            };\n            this.ledInput = new Input(idMachine, idDevice + \"Input\", configInput);\n            this.sCellDesc = this.getBindingText(ROM.BINDING.CELLDESC);\n            this.ledInput.addHover(function onROMHover(col, row) {\n                if (rom.chip) {\n                    let sDesc = rom.sCellDesc;\n                    if (col >= 0 && row >= 0) {\n                        let addr = row * rom.cols + col;\n\n                        let opCode = rom.data[addr];\n                        sDesc = rom.chip.disassemble(opCode, addr);\n                    }\n                    rom.setBindingText(ROM.BINDING.CELLDESC, sDesc);\n                }\n            });\n        }\n    }\n\n    /**\n     * clearArray()\n     *\n     * clearBuffer(true) performs a combination of clearBuffer() and drawBuffer().\n     *\n     * @this {ROM}\n     */\n    clearArray()\n    {\n        if (this.ledArray) this.ledArray.clearBuffer(true);\n    }\n\n    /**\n     * drawArray()\n     *\n     * This performs a simple drawBuffer(); intended for synchronous updates (eg, step operations);\n     * otherwise, you should allow the LED object's async animation handler take care of drawing updates.\n     *\n     * @this {ROM}\n     */\n    drawArray()\n    {\n        if (this.ledArray) this.ledArray.drawBuffer();\n    }\n\n    /**\n     * getData(addr, fInternal)\n     *\n     * Set fInternal to true if an internal caller (eg, the disassembler) is accessing the ROM, to avoid touching\n     * the ledArray.\n     *\n     * @this {ROM}\n     * @param {number} addr\n     * @param {boolean} [fInternal]\n     * @returns {number|undefined}\n     */\n    getData(addr, fInternal)\n    {\n        if (this.ledArray && !fInternal) {\n            this.ledArray.setLEDState(addr % this.cols, (addr / this.cols)|0, LED.STATE.ON, LED.FLAGS.MODIFIED);\n        }\n        return this.data[addr];\n    }\n\n    /**\n     * loadState(state)\n     *\n     * If any saved values don't match (presumably overridden), abandon the given state and return false.\n     * \n     * @this {ROM}\n     * @param {Array} state\n     * @returns {boolean}\n     */\n    loadState(state)\n    {\n        let buffer = state.shift();\n        if (buffer && this.ledArray) {\n\n            if (this.ledArray.buffer.length == buffer.length) {\n                this.ledArray.buffer = buffer;\n                this.ledArray.drawBuffer(true);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * saveState(state)\n     *\n     * @this {ROM}\n     * @param {Array} state\n     */\n    saveState(state)\n    {\n        if (this.ledArray) {\n            state.push(this.ledArray.buffer);\n        }\n    }\n\n    /**\n     * setChip()\n     *\n     * @this {ROM}\n     * @param {Chip} chip\n     */\n    setChip(chip)\n    {\n        this.chip = chip;\n    }\n}\n\nROM.BINDING = {\n    ARRAY:      \"array\",\n    CELLDESC:   \"cellDesc\"\n};\n\nROM.VERSION = +VERSION || 1.20;\n\n/**\n * @copyright https://www.pcjs.org/modules/devices/time.js (C) Jeff Parsons 2012-2018\n */\n\n/** @typedef {{ id: string, callBack: function(), msAuto: number, nCyclesLeft: number }} */\nvar Timer;\n\n/** @typedef {{ class: string, bindings: (Object|undefined), version: (number|undefined), overrides: (Array.<string>|undefined), cyclesMinimum: (number|undefined), cyclesMaximum: (number|undefined), cyclesPerSecond: (number|undefined), yieldsPerSecond: (number|undefined), yieldsPerUpdate: (number|undefined), requestAnimationFrame: (boolean|undefined), clockByFrame: (boolean|undefined) }} */\nvar TimeConfig;\n\n/**\n * @class {Time}\n * @unrestricted\n * @property {TimeConfig} config\n * @property {number} nCyclesMinimum\n * @property {number} nCyclesMaximum\n * @property {number} nCyclesPerSecond\n * @property {number} nYieldsPerSecond\n * @property {number} nYieldsPerUpdate\n * @property {boolean} fClockByFrame\n */\nclass Time extends Device {\n    /**\n     * Time(idMachine, idDevice, config)\n     *\n     * Sample config:\n     *\n     *      \"clock\": {\n     *        \"class\": \"Time\",\n     *        \"cyclesPerSecond\": 650000,\n     *        \"clockByFrame\": true,\n     *        \"bindings\": {\n     *          \"run\": \"runTI57\",\n     *          \"speed\": \"speedTI57\",\n     *          \"step\": \"stepTI57\"\n     *        },\n     *        \"overrides\": [\"cyclesPerSecond\",\"yieldsPerSecond\",\"yieldsPerUpdate\"]\n     *      }\n     *\n     * @this {Time}\n     * @param {string} idMachine\n     * @param {string} idDevice\n     * @param {TimeConfig} [config]\n     */\n    constructor(idMachine, idDevice, config)\n    {\n        super(idMachine, idDevice, Time.VERSION, config);\n\n        /*\n         * NOTE: The default speed of 650,000Hz (0.65Mhz) was a crude approximation based on real world TI-57\n         * device timings.  I had originally assumed the speed as 1,600,000Hz (1.6Mhz), based on timing information\n         * in TI's patents, but in hindsight, that speed seems rather high for a mid-1970's device, and reality\n         * suggests it was much lower.  The TMS-1500 does burn through a lot of cycles (minimum of 128) per instruction,\n         * but either that cycle burn was much higher, or the underlying clock speed was much lower.  I assume the latter.\n         */\n        this.nCyclesMinimum = this.getDefaultNumber('cyclesMinimum', 100000);\n        this.nCyclesMaximum = this.getDefaultNumber('cyclesMaximum', 3000000);\n        this.nCyclesPerSecond = this.getBounded(this.getDefaultNumber('cyclesPerSecond', 650000), this.nCyclesMinimum, this.nCyclesMaximum);\n        this.nYieldsPerSecond = this.getBounded(this.getDefaultNumber('yieldsPerSecond', Time.YIELDS_PER_SECOND), 30, 120);\n        this.nYieldsPerUpdate = this.getBounded(this.getDefaultNumber('yieldsPerUpdate', Time.YIELDS_PER_UPDATE), 1, this.nYieldsPerSecond);\n        this.fClockByFrame = this.getDefaultBoolean('clockByFrame', this.nCyclesPerSecond <= 120);\n        this.fRequestAnimationFrame = this.fClockByFrame || this.getDefaultBoolean('requestAnimationFrame', true);\n\n        this.nBaseMultiplier = this.nCurrentMultiplier = this.nTargetMultiplier = 1;\n        this.mhzBase = (this.nCyclesPerSecond / 10000) / 100;\n        this.mhzCurrent = this.mhzTarget = this.mhzBase * this.nTargetMultiplier;\n        this.nYields = 0;\n        this.msYield = Math.round(1000 / this.nYieldsPerSecond);\n        this.aAnimators = [];\n        this.aClockers = [];\n        this.aTimers = [];\n        this.aUpdaters = [];\n        this.fRunning = this.fYield = this.fThrottling = false;\n        this.nStepping = 0;\n        this.idRunTimeout = this.idStepTimeout = 0;\n        this.onRunTimeout = this.run.bind(this);\n        this.onAnimationFrame = this.animate.bind(this);\n        this.requestAnimationFrame = (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.setTimeout).bind(window);\n        this.msLastAnimation = 0;\n\n        /*\n         * When fClockByFrame is true, we rely exclusively on requestAnimationFrame() instead of setTimeout()\n         * to drive the clock, which means we automatically yield after every frame, so no yield timer is required.\n         */\n        if (!this.fClockByFrame) {\n            let time = this;\n            this.timerYield = this.addTimer(\"timerYield\", function onYield() {\n                time.onYield();\n            }, this.msYield);\n        }\n        else {\n            /*\n             * When clocking exclusively by animation frames, setSpeed() calculates how many cycles\n             * each animation frame should \"deposit\" in our cycle bank:\n             * \n             *      this.nCyclesDepositPerFrame = (nCyclesPerSecond / 60) + 0.00000001;\n             *\n             * After that amount is added to our \"balance\" (this.nCyclesDeposited), we make a \"withdrawal\"\n             * whenever the balance is >= 1.0 and call all our clocking functions with the maximum number\n             * of cycles we were able to withdraw.\n             *\n             * setSpeed() also adds a tiny amount of \"interest\" to each \"deposit\" (0.00000001); otherwise\n             * you can end up in situations where the deposit amount is, say, 0.2499999 instead of 0.25,\n             * and four such deposits would still fall short of the 1-cycle threshold.\n             */\n            this.nCyclesDeposited = this.nCyclesDepositPerFrame = 0;\n        }\n        this.resetSpeed();\n    }\n\n    /**\n     * addAnimator(callBack)\n     *\n     * Animators are functions that used to be called with YIELDS_PER_SECOND frequency, when animate()\n     * was called on every onYield() call, but now we rely on requestAnimationFrame(), so the frequency\n     * is browser-dependent (but presumably at least 60Hz).\n     *\n     * @this {Time}\n     * @param {function()} callBack\n     */\n    addAnimator(callBack)\n    {\n        this.aAnimators.push(callBack);\n    }\n\n    /**\n     * addBinding(binding, element)\n     *\n     * @this {Time}\n     * @param {string} binding\n     * @param {Element} element\n     */\n    addBinding(binding, element)\n    {\n        let time = this;\n\n        switch(binding) {\n\n        case Time.BINDING.RUN:\n            element.onclick = function onClickRun() {\n                time.onRun();\n            };\n            break;\n\n        case Time.BINDING.STEP:\n            element.onclick = function onClickStep() {\n                time.onStep();\n            };\n            break;\n\n        case Time.BINDING.THROTTLE:\n            let elementInput = /** @type {HTMLInputElement} */ (element);\n            elementInput.addEventListener(\"mousedown\", function onThrottleStart() {\n                time.fThrottling = true;\n            });\n            elementInput.addEventListener(\"mouseup\", function onThrottleStop() {\n                time.setSpeedThrottle();\n                time.fThrottling = false;\n            });\n            elementInput.addEventListener(\"mousemove\", function onThrottleChange() {\n                if (time.fThrottling) {\n                    time.setSpeedThrottle();\n                }\n            });\n            elementInput.addEventListener(\"change\", function onThrottleChange() {\n                time.fThrottling = true;\n                time.setSpeedThrottle();\n                time.fThrottling = false;\n            });\n            break;\n        }\n        super.addBinding(binding, element);\n    }\n\n    /**\n     * addClocker(callBack)\n     *\n     * Adds a clocker function that's called from doBurst() to process a specified number of cycles.\n     *\n     * @this {Time}\n     * @param {function(number)} callBack\n     */\n    addClocker(callBack)\n    {\n        this.aClockers.push(callBack);\n    }\n\n    /**\n     * addTimer(id, callBack, msAuto)\n     *\n     * Devices that want to have timers that fire after some number of milliseconds call addTimer() to create\n     * the timer, and then setTimer() when they want to arm it.  Alternatively, they can specify an automatic\n     * timeout value (in milliseconds) to have the timer fire automatically at regular intervals.  There is\n     * currently no removeTimer() because these are generally used for the entire lifetime of a device.\n     *\n     * A timer is initially dormant; dormant timers have a cycle count of -1 (although any negative number will\n     * suffice) and active timers have a non-negative cycle count.\n     *\n     * @this {Time}\n     * @param {string} id\n     * @param {function()} callBack\n     * @param {number} [msAuto] (if set, enables automatic setTimer calls)\n     * @returns {number} timer index (1-based)\n     */\n    addTimer(id, callBack, msAuto = -1)\n    {\n        let nCyclesLeft = -1;\n        let iTimer = this.aTimers.length + 1;\n        this.aTimers.push({id, callBack, msAuto, nCyclesLeft});\n        if (msAuto >= 0) this.setTimer(iTimer, msAuto);\n        return iTimer;\n    }\n\n    /**\n     * addUpdater(callBack)\n     *\n     * Adds a status update function that's called from updateStatus(), either as the result\n     * of periodic status updates from onYield(), single-step updates from step(), or transitional\n     * updates from start() and stop().\n     *\n     * @this {Time}\n     * @param {function(boolean)} callBack\n     */\n    addUpdater(callBack)\n    {\n        this.aUpdaters.push(callBack);\n    }\n\n    /**\n     * animate(t)\n     *\n     * This is the callback function we supply to requestAnimationFrame().  The callback has a single\n     * (DOMHighResTimeStamp) argument, which indicates the current time (returned from performance.now())\n     * for when requestAnimationFrame() starts to fire callbacks.\n     *\n     * See: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestAnimationFrame\n     *\n     * @this {Time}\n     * @param {number} [t]\n     */\n    animate(t)\n    {\n        if (this.fClockByFrame) {\n            /*\n             * Mimic the logic in run()\n             */\n            if (!this.fRunning) return;\n            this.snapStart();\n            try {\n                this.fYield = false;\n                do {\n                    /*\n                     * Execute the burst and then update all timers.\n                     */\n                    this.updateTimers(this.endBurst(this.doBurst(this.getCyclesPerFrame())));\n                } while (this.fRunning && !this.fYield);\n            }\n            catch (err) {\n                this.println(err.message);\n                this.stop();\n                return;\n            }\n            this.snapStop();\n        }\n        let fSkip = false;\n        if (t !== undefined) {\n            if (this.nCyclesPerSecond > Time.YIELDS_PER_SECOND) {\n                if (this.msLastAnimation && (t - this.msLastAnimation) < ((1000 / Time.FRAMES_PER_SECOND)|0)) {\n                    fSkip = true;\n                }\n            }\n        }\n        if (!fSkip) {\n            for (let i = 0; i < this.aAnimators.length; i++) {\n                this.aAnimators[i]();\n            }\n            this.msLastAnimation = t;\n        }\n        if (this.fRunning && this.fRequestAnimationFrame) this.requestAnimationFrame(this.onAnimationFrame);\n    }\n\n    /**\n     * calcCycles()\n     *\n     * Calculate the maximum number of cycles we should attempt to process before the next yield.\n     *\n     * @this {Time}\n     */\n    calcCycles()\n    {\n        let nMultiplier = this.mhzCurrent / this.mhzBase;\n        if (!nMultiplier || nMultiplier > this.nTargetMultiplier) {\n            nMultiplier = this.nTargetMultiplier;\n        }\n        /*\n         * nCyclesPerYield is now allowed to be a fractional number, so that for machines configured\n         * to run at an extremely slow speed (eg, less than 60Hz), a fractional value here will signal\n         * to snapStop() that it should increase msYield to a proportionally higher value.\n         */\n        this.nCyclesPerYield = (this.nCyclesPerSecond / this.nYieldsPerSecond * nMultiplier);\n        this.nCurrentMultiplier = nMultiplier;\n    }\n\n    /**\n     * calcSpeed(nCycles, msElapsed)\n     *\n     * @this {Time}\n     * @param {number} nCycles\n     * @param {number} msElapsed\n     */\n    calcSpeed(nCycles, msElapsed)\n    {\n        if (msElapsed) {\n            this.mhzCurrent = (nCycles / (msElapsed * 10)) / 100;\n        }\n    }\n\n    /**\n     * doBurst(nCycles)\n     *\n     * @this {Time}\n     * @param {number} nCycles\n     * @returns {number} (number of cycles actually executed)\n     */\n    doBurst(nCycles)\n    {\n        this.nCyclesBurst = this.nCyclesRemain = nCycles;\n        if (!this.aClockers.length) {\n            this.nCyclesRemain = 0;\n            return this.nCyclesBurst;\n        }\n        let iClocker = 0;\n        while (this.nCyclesRemain > 0) {\n            if (iClocker < this.aClockers.length) {\n                nCycles = this.aClockers[iClocker++](nCycles) || 1;\n            } else {\n                iClocker = nCycles = 0;\n            }\n            this.nCyclesRemain -= nCycles;\n        }\n        return this.nCyclesBurst - this.nCyclesRemain;\n    }\n\n    /**\n     * doOutside(fn)\n     *\n     * Use this function to perform any work outside of normal time (eg, DOM updates),\n     * to prevent that work from disrupting our speed calculations.\n     *\n     * @this {Time}\n     * @param {function()} fn (should return true only if the function actually performed any work)\n     * @returns {boolean}\n     */\n    doOutside(fn)\n    {\n        let msStart = Date.now();\n        if (fn()) {\n            let msStop = Date.now();\n            this.msOutsideThisRun += msStop - msStart;\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * endBurst(nCycles)\n     *\n     * @this {Time}\n     * @param {number} [nCycles]\n     * @returns {number} (number of cycles executed in burst)\n     */\n    endBurst(nCycles = this.nCyclesBurst - this.nCyclesRemain)\n    {\n        if (this.fClockByFrame) {\n            this.nCyclesDeposited -= nCycles;\n            if (this.nCyclesDeposited < 1) {\n                this.fYield = true;\n            }\n        }\n        this.nCyclesBurst = this.nCyclesRemain = 0;\n        this.nCyclesThisRun += nCycles;\n        this.nCyclesRun += nCycles;\n        if (!this.fRunning) this.nCyclesRun = 0;\n        return nCycles;\n    }\n\n    /**\n     * getCycles(ms)\n     *\n     * If no time period is specified, this returns the current number of cycles per second.\n     *\n     * @this {Time}\n     * @param {number} ms (default is 1000)\n     * @returns {number} number of corresponding cycles\n     */\n    getCycles(ms = 1000)\n    {\n        return Math.ceil((this.nCyclesPerSecond * this.nCurrentMultiplier) / 1000 * ms);\n    }\n\n    /**\n     * getCyclesPerBurst()\n     *\n     * This tells us how many cycles to execute as a burst.\n     *\n     * @this {Time}\n     * @returns {number} (the maximum number of cycles we should execute in the next burst)\n     */\n    getCyclesPerBurst()\n    {\n        let nCycles = this.getCycles(this.msYield);\n        for (let iTimer = this.aTimers.length; iTimer > 0; iTimer--) {\n            let timer = this.aTimers[iTimer-1];\n\n            if (timer.nCyclesLeft < 0) continue;\n            if (nCycles > timer.nCyclesLeft) {\n                nCycles = timer.nCyclesLeft;\n            }\n        }\n        return nCycles;\n    }\n\n    /**\n     * getCyclesPerFrame()\n     *\n     * This tells us how many cycles to execute per frame (assuming fClockByFrame).\n     *\n     * @this {Time}\n     * @returns {number} (the maximum number of cycles we should execute in the next burst)\n     */\n    getCyclesPerFrame()\n    {\n        let nCycles = (this.nCyclesDeposited += this.nCyclesDepositPerFrame);\n        if (nCycles < 1) {\n            nCycles = 0;\n        } else {\n            nCycles |= 0;\n            for (let iTimer = this.aTimers.length; iTimer > 0; iTimer--) {\n                let timer = this.aTimers[iTimer-1];\n\n                if (timer.nCyclesLeft < 0) continue;\n                if (nCycles > timer.nCyclesLeft) {\n                    nCycles = timer.nCyclesLeft;\n                }\n            }\n        }\n        return nCycles;\n    }\n\n    /**\n     * getSpeed(mhz)\n     *\n     * @this {Time}\n     * @param {number} mhz\n     * @returns {string} the given speed, as a formatted string\n     */\n    getSpeed(mhz)\n    {\n        let s;\n        if (mhz >= 1) {\n            s = mhz.toFixed(2) + \"Mhz\";\n        } else {\n            let hz = Math.round(mhz * 1000000);\n            if (hz <= 999) {\n                s = hz + \"Hz\";\n            } else {\n                s = Math.ceil(hz / 1000) + \"Khz\";\n            }\n        }\n        return s;\n    }\n\n    /**\n     * getSpeedCurrent()\n     *\n     * @this {Time}\n     * @returns {string} the current speed, as a formatted string\n     */\n    getSpeedCurrent()\n    {\n        return (this.fRunning && this.mhzCurrent)? this.getSpeed(this.mhzCurrent) : \"Stopped\";\n    }\n\n    /**\n     * getSpeedTarget()\n     *\n     * @this {Time}\n     * @returns {string} the target speed, as a formatted string\n     */\n    getSpeedTarget()\n    {\n        return this.getSpeed(this.mhzTarget);\n    }\n\n    /**\n     * isRunning()\n     *\n     * @this {Time}\n     * @returns {boolean}\n     */\n    isRunning()\n    {\n        return this.fRunning;\n    }\n\n    /**\n     * isTimerSet(iTimer)\n     *\n     * NOTE: Even if the timer is armed, we return false if the clock is currently stopped;\n     * in that sense, perhaps this function should be named isTimerArmedAndWillItFireOnTime().\n     *\n     * @this {Time}\n     * @param {number} iTimer\n     * @returns {boolean}\n     */\n    isTimerSet(iTimer)\n    {\n        if (this.fRunning) {\n            if (iTimer > 0 && iTimer <= this.aTimers.length) {\n                let timer = this.aTimers[iTimer - 1];\n                return (timer.nCyclesLeft >= 0);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * onRun()\n     *\n     * This handles the \"run\" button, if any, attached to the Time device.\n     *\n     * Note that this serves a different purpose than the \"power\" button that's managed by the Input device,\n     * because toggling power also requires resetting the program counter prior to start() OR clearing the display\n     * after stop().  See the Chip's onPower() function for details.\n     *\n     * @this {Time}\n     */\n    onRun()\n    {\n        if (this.fRunning) {\n            this.stop();\n        } else {\n            this.start();\n        }\n    }\n\n    /**\n     * onStep(nRepeat)\n     *\n     * This handles the \"step\" button, if any, attached to the Time device.\n     *\n     * @this {Time}\n     * @param {number} [nRepeat]\n     */\n    onStep(nRepeat)\n    {\n        if (!this.fRunning) {\n            if (this.nStepping) {\n                this.stop();\n            } else {\n                this.step(nRepeat);\n            }\n        } else {\n            this.println(\"already running\");\n        }\n    }\n\n    /**\n     * onYield()\n     *\n     * @this {Time}\n     */\n    onYield()\n    {\n        this.fYield = true;\n        let nYields = this.nYields;\n        let nCyclesPerSecond = this.getCycles();\n        if (nCyclesPerSecond >= this.nYieldsPerSecond) {\n            this.nYields++;\n        } else {\n            /*\n             * Let's imagine that nCyclesPerSecond has dropped to 4, whereas the usual nYieldsPerSecond is 60;\n             * that's means we're yielding at 1/15th the usual rate, so to compensate, we want to bump nYields\n             * by 15 instead of 1.\n             */\n            this.nYields += Math.ceil(this.nYieldsPerSecond / nCyclesPerSecond);\n        }\n        if (this.nYields >= this.nYieldsPerUpdate && nYields < this.nYieldsPerUpdate) {\n            this.updateStatus();\n        }\n        if (this.nYields >= this.nYieldsPerSecond) {\n            this.nYields = 0;\n        }\n    }\n\n    /**\n     * resetSpeed()\n     *\n     * Resets speed and cycle information as part of any reset() or restore(); this typically occurs during powerUp().\n     * It's important that this be called BEFORE the actual restore() call, because restore() may want to call setSpeed(),\n     * which in turn assumes that all the cycle counts have been initialized to sensible values.\n     *\n     * @this {Time}\n     */\n    resetSpeed()\n    {\n        this.nCyclesRun = this.nCyclesBurst = this.nCyclesRemain = 0;\n        if (!this.setSpeedThrottle()) this.setSpeed(this.nBaseMultiplier);\n    }\n\n    /**\n     * resetTimers()\n     *\n     * When the target speed multiplier is altered, it's a good idea to run through all the timers that\n     * have a fixed millisecond period and re-arm them, because the timers are using cycle counts that were based\n     * on a previous multiplier.\n     *\n     * @this {Time}\n     */\n    resetTimers()\n    {\n        for (let iTimer = this.aTimers.length; iTimer > 0; iTimer--) {\n            let timer = this.aTimers[iTimer-1];\n            if (timer.msAuto >= 0) this.setTimer(iTimer, timer.msAuto, true);\n        }\n    }\n\n    /**\n     * run()\n     *\n     * @this {Time}\n     */\n    run()\n    {\n        this.idRunTimeout = 0;\n        if (!this.fRunning) return;\n        this.snapStart();\n        try {\n            this.fYield = false;\n            do {\n                /*\n                 * Execute the burst and then update all timers.\n                 */\n                this.updateTimers(this.endBurst(this.doBurst(this.getCyclesPerBurst())));\n\n            } while (this.fRunning && !this.fYield);\n        }\n        catch(err) {\n            this.println(err.message);\n            this.stop();\n            return;\n        }\n        if (this.fRunning) {\n\n            this.idRunTimeout = setTimeout(this.onRunTimeout, this.snapStop());\n            if (!this.fRequestAnimationFrame) this.animate();\n        }\n    }\n\n    /**\n     * setSpeedThrottle()\n     *\n     * This handles speed adjustments requested by the throttling slider.\n     *\n     * @this {Time}\n     * @returns {boolean} (true if a throttle exists, false if not)\n     */\n    setSpeedThrottle()\n    {\n        /*\n         * We're not going to assume any direct relationship between the slider's min/max/value\n         * and our own nCyclesMinimum/nCyclesMaximum/nCyclesPerSecond.  We're just going to calculate\n         * a new target nCyclesPerSecond that is proportional, and then convert that to a speed multiplier.\n         */\n        let elementInput = this.bindings[Time.BINDING.THROTTLE];\n        if (elementInput) {\n            let ratio = (elementInput.value - elementInput.min) / (elementInput.max - elementInput.min);\n            let nCycles = Math.floor((this.nCyclesMaximum - this.nCyclesMinimum) * ratio + this.nCyclesMinimum);\n            let nMultiplier = nCycles / this.nCyclesPerSecond;\n\n            this.setSpeed(nMultiplier);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * setSpeed(nMultiplier)\n     *\n     * @this {Time}\n     * @param {number} [nMultiplier] is the new proposed multiplier (reverts to default if target was too high)\n     * @returns {boolean} true if successful, false if not\n     *\n     * @desc Whenever the speed is changed, the running cycle count and corresponding start time must be reset,\n     * so that the next effective speed calculation obtains sensible results.  In fact, when run() initially calls\n     * setSpeed() with no parameters, that's all this function does (it doesn't change the current speed setting).\n     */\n    setSpeed(nMultiplier)\n    {\n        let fSuccess = true;\n        if (nMultiplier !== undefined) {\n            /*\n             * If we haven't reached 90% (0.9) of the current target speed, revert to the default multiplier.\n             */\n            if (!this.fThrottling && this.mhzCurrent > 0 && this.mhzCurrent < this.mhzTarget * 0.9) {\n                nMultiplier = this.nBaseMultiplier;\n                fSuccess = false;\n            }\n            this.nTargetMultiplier = nMultiplier;\n            let mhzTarget = this.mhzBase * this.nTargetMultiplier;\n            if (this.mhzTarget != mhzTarget) {\n                this.mhzTarget = mhzTarget;\n                this.setBindingText(Time.BINDING.SPEED, this.getSpeedTarget());\n            }\n            /*\n             * After every yield, calcSpeed() will update mhzCurrent, but we also need to be optimistic\n             * and set it to the mhzTarget now, so that the next calcCycles() call will make a reasonable\n             * initial estimate.\n             */\n            this.mhzCurrent = this.mhzTarget;\n        }\n        if (this.fClockByFrame) {\n            let nCyclesPerSecond = this.mhzCurrent * 1000000;\n            this.nCyclesDepositPerFrame = (nCyclesPerSecond / 60) + 0.00000001;\n            this.nCyclesDeposited = 0;\n        }\n        this.nCyclesRun = 0;\n        this.msStartRun = this.msEndRun = 0;\n        this.calcCycles();      // calculate a new value for the current cycle multiplier\n        this.resetTimers();     // and then update all the fixed-period timers using the new cycle multiplier\n        return fSuccess;\n    }\n\n    /**\n     * setTimer(iTimer, ms, fReset)\n     *\n     * Using the timer index from a previous addTimer() call, this sets that timer to fire after the\n     * specified number of milliseconds.\n     *\n     * @this {Time}\n     * @param {number} iTimer\n     * @param {number} ms (converted into a cycle countdown internally)\n     * @param {boolean} [fReset] (true if the timer should be reset even if already armed)\n     * @returns {number} (number of cycles used to arm timer, or -1 if error)\n     */\n    setTimer(iTimer, ms, fReset)\n    {\n        let nCycles = -1;\n        if (iTimer > 0 && iTimer <= this.aTimers.length) {\n            let timer = this.aTimers[iTimer-1];\n            if (fReset || timer.nCyclesLeft < 0) {\n                nCycles = this.getCycles(ms);\n                /*\n                 * If we're currently executing a burst of cycles, the number of cycles it has executed in\n                 * that burst so far must NOT be charged against the cycle timeout we're about to set.  The simplest\n                 * way to resolve that is to immediately call endBurst() and bias the cycle timeout by the number\n                 * of cycles that the burst executed.\n                 */\n                if (this.fRunning) {\n                    nCycles += this.endBurst();\n                }\n                timer.nCyclesLeft = nCycles;\n            }\n        }\n        return nCycles;\n    }\n\n    /**\n     * snapStart()\n     *\n     * @this {Time}\n     */\n    snapStart()\n    {\n        this.calcCycles();\n\n        this.nCyclesThisRun = 0;\n        this.msOutsideThisRun = 0;\n        this.msStartThisRun = Date.now();\n        if (!this.msStartRun) this.msStartRun = this.msStartThisRun;\n\n        /*\n         * Try to detect situations where the browser may have throttled us, such as when the user switches\n         * to a different tab; in those situations, Chrome and Safari may restrict setTimeout() callbacks\n         * to roughly one per second.\n         *\n         * Another scenario: the user resizes the browser window.  setTimeout() callbacks are not throttled,\n         * but there can still be enough of a lag between the callbacks that speed will be noticeably\n         * erratic if we don't compensate for it here.\n         *\n         * We can detect throttling/lagging by verifying that msEndRun (which was set at the end of the\n         * previous run and includes any requested sleep time) is comparable to the current msStartThisRun;\n         * if the delta is significant, we compensate by bumping msStartRun forward by that delta.\n         *\n         * This shouldn't be triggered when the Debugger stops time, because setSpeed() -- which is called\n         * whenever the time starts again -- zeroes msEndRun.\n         */\n        let msDelta = 0;\n        if (this.msEndRun) {\n            msDelta = this.msStartThisRun - this.msEndRun;\n            if (msDelta > this.msYield) {\n                this.msStartRun += msDelta;\n                /*\n                 * Bumping msStartRun forward should NEVER cause it to exceed msStartThisRun; however, just\n                 * in case, I make absolutely sure it cannot happen, since doing so could result in negative\n                 * speed calculations.\n                 */\n\n                if (this.msStartRun > this.msStartThisRun) {\n                    this.msStartRun = this.msStartThisRun;\n                }\n            }\n        }\n    }\n\n    /**\n     * snapStop()\n     *\n     * @this {Time}\n     * @returns {number}\n     */\n    snapStop()\n    {\n        this.msEndRun = Date.now();\n\n        if (this.msOutsideThisRun) {\n            this.msStartRun += this.msOutsideThisRun;\n            this.msStartThisRun += this.msOutsideThisRun;\n        }\n\n        let msYield = this.msYield;\n        if (this.nCyclesThisRun) {\n            /*\n             * Normally, we assume we executed a full quota of work over msYield.  If nCyclesThisRun is correct,\n             * then the ratio of nCyclesThisRun/nCyclesPerYield should represent the percentage of work we performed,\n             * and so applying that percentage to msYield should give us a better estimate of work vs. time.\n             */\n            msYield = Math.round(msYield * this.nCyclesThisRun / this.nCyclesPerYield);\n        }\n\n        let msElapsedThisRun = this.msEndRun - this.msStartThisRun;\n        let msRemainsThisRun = msYield - msElapsedThisRun;\n\n        let nCycles = this.nCyclesRun;\n        let msElapsed = this.msEndRun - this.msStartRun;\n\n        if (DEBUG && msRemainsThisRun < 0 && this.nTargetMultiplier > 1) {\n            this.println(\"warning: updates @\" + msElapsedThisRun + \"ms (prefer \" + Math.round(msYield) + \"ms)\");\n        }\n\n        this.calcSpeed(nCycles, msElapsed);\n\n        if (msRemainsThisRun < 0) {\n            /*\n             * Try \"throwing out\" the effects of large anomalies, by moving the overall run start time up;\n             * ordinarily, this should only happen when the someone is using an external Debugger or some other\n             * tool or feature that is interfering with our overall execution.\n             */\n            if (msRemainsThisRun < -1000) {\n                this.msStartRun -= msRemainsThisRun;\n            }\n            /*\n             * If the last burst took MORE time than we allotted (ie, it's taking more than 1 second to simulate\n             * nCyclesPerSecond), all we can do is yield for as little time as possible (ie, 0ms) and hope that the\n             * simulation is at least usable.\n             */\n            msRemainsThisRun = 0;\n        }\n        else if (this.mhzCurrent < this.mhzTarget) {\n            msRemainsThisRun = 0;\n        }\n\n        this.msEndRun += msRemainsThisRun;\n\n        if (this.isCategoryOn(Device.CATEGORY.TIME)) {\n            this.printf(\"after running %d cycles, resting for %dms\\n\", this.nCyclesThisRun, msRemainsThisRun);\n        }\n\n        return msRemainsThisRun;\n    }\n\n    /**\n     * start()\n     *\n     * @this {Time}\n     * @returns {boolean}\n     */\n    start()\n    {\n        if (this.fRunning || this.nStepping) {\n            return false;\n        }\n\n        if (this.idRunTimeout) {\n            clearTimeout(this.idRunTimeout);\n            this.idRunTimeout = 0;\n        }\n\n        this.fRunning = true;\n        this.msStartRun = this.msEndRun = 0;\n        this.updateStatus(true);\n\n        /*\n         * Kickstart both the clockers and requestAnimationFrame; it's a little premature to start\n         * animation here, because the first run() should take place before the first animate(), but\n         * since clock speed is now decoupled from animation speed, this isn't something we should\n         * worry about.\n         */\n        if (!this.fClockByFrame) {\n\n            this.idRunTimeout = setTimeout(this.onRunTimeout, 0);\n        }\n        if (this.fRequestAnimationFrame) this.requestAnimationFrame(this.onAnimationFrame);\n        return true;\n    }\n\n    /**\n     * step(nRepeat)\n     *\n     * @this {Time}\n     * @param {number} [nRepeat]\n     * @returns {boolean} true if successful, false if already running\n     */\n    step(nRepeat = 1)\n    {\n        if (!this.fRunning) {\n            if (nRepeat && !this.nStepping) {\n                this.nStepping = nRepeat;\n            }\n            if (this.nStepping) {\n                /*\n                 * Execute a minimum-cycle burst and then update all timers.\n                 */\n                let nCycles = (this.fClockByFrame? (this.getCyclesPerFrame() || 1) : 1);\n                this.nStepping--;\n                this.updateTimers(this.endBurst(this.doBurst(nCycles)));\n                this.updateStatus();\n                if (this.nStepping) {\n                    let time = this;\n                    this.idStepTimeout = setTimeout(function onStepTimeout() {\n                        time.step(0);\n                    }, 0);\n                    return true;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * stop()\n     *\n     * @this {Time}\n     * @returns {boolean} true if successful, false if already stopped\n     */\n    stop()\n    {\n        if (this.nStepping) {\n            this.nStepping = 0;\n            this.updateStatus(true);\n            return true;\n        }\n        if (this.fRunning) {\n            this.fRunning = false;\n            this.endBurst();\n            this.updateStatus(true);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * updateStatus(fTransition)\n     *\n     * Used for periodic status updates from onYield(), single-step updates from step(), and transitional\n     * updates from start() and stop().\n     *\n     * @this {Time}\n     * @param {boolean} [fTransition]\n     */\n    updateStatus(fTransition)\n    {\n        if (fTransition) {\n            if (this.fRunning) {\n                this.println(\"starting (\" + this.getSpeedTarget() + \" target by \" + (this.fClockByFrame? \"frame\" : \"timer\") + \")\");\n                fTransition = false;\n            } else {\n                this.println(\"stopping\");\n            }\n        }\n\n        this.setBindingText(Time.BINDING.RUN, this.fRunning? \"Halt\" : \"Run\");\n        this.setBindingText(Time.BINDING.STEP, this.nStepping? \"Stop\" : \"Step\");\n        if (!this.fThrottling) {\n            this.setBindingText(Time.BINDING.SPEED, this.getSpeedCurrent());\n        }\n\n        for (let i = 0; i < this.aUpdaters.length; i++) {\n            this.aUpdaters[i](fTransition);\n        }\n    }\n\n    /**\n     * updateTimers(nCycles)\n     *\n     * Used by run() to reduce all active timer countdown values by the number of cycles just executed;\n     * this is the function that actually \"fires\" any timer(s) whose countdown has reached (or dropped below)\n     * zero, invoking their callback function.\n     *\n     * @this {Time}\n     * @param {number} nCycles (number of cycles actually executed)\n     */\n    updateTimers(nCycles)\n    {\n        if (nCycles >= 1) {\n            for (let iTimer = this.aTimers.length; iTimer > 0; iTimer--) {\n                let timer = this.aTimers[iTimer-1];\n\n                if (timer.nCyclesLeft < 0) continue;\n                timer.nCyclesLeft -= nCycles;\n                if (timer.nCyclesLeft <= 0) {\n                    timer.nCyclesLeft = -1; // zero is technically an \"active\" value, so ensure the timer is dormant now\n                    timer.callBack();       // safe to invoke the callback function now\n                    if (timer.msAuto >= 0) {\n                        this.setTimer(iTimer, timer.msAuto);\n                    }\n                }\n            }\n        }\n    }\n}\n\nTime.BINDING = {\n    RUN:        \"run\",\n    SPEED:      \"speed\",\n    STEP:       \"step\",\n    THROTTLE:   \"throttle\"\n};\n\n/*\n * We yield more often now (120 times per second instead of 60), to help ensure that requestAnimationFrame()\n * callbacks can be called as timely as possible.  And we still only want to perform DOM-related status updates\n * no more than twice per second, so the required number of yields before each update has been increased as well.\n */\nTime.FRAMES_PER_SECOND = 60;\nTime.YIELDS_PER_SECOND = 120;\nTime.YIELDS_PER_UPDATE = 60;\n\nTime.VERSION = +VERSION || 1.20;\n\n/**\n * @copyright https://www.pcjs.org/modules/devices/ledctrl.js (C) Jeff Parsons 2012-2018\n */\n\n/** @typedef {{ class: string, bindings: (Object|undefined), version: (number|undefined), overrides: (Array.<string>|undefined), wrap: (boolean|undefined), font: (string|undefined), rule: (string|undefined), pattern: (string|undefined), patterns: (Object|undefined), message: (string|undefined), toggleColor: (boolean|undefined), colors: (Object|undefined) }} */\nvar LCConfig;\n\n/**\n * LED Controller Chip\n *\n * @class {Chip}\n * @unrestricted\n * @property {boolean} fWrap\n * @property {string} sFont\n * @property {string} sRule\n * @property {string} sPattern\n * @property {string} sMessage\n * @property {string} sMessageInit\n * @property {boolean} fToggleColor\n * @property {LED} leds\n * @property {Object} colorPalette\n * @property {string} colorDefault (obtained from the leds)\n * @property {string} colorSelected (set by updateColorSelection())\n * @property {Array.<string>} colors\n */\nclass Chip extends Device {\n    /**\n     * Chip(idMachine, idDevice, config)\n     *\n     * @this {Chip}\n     * @param {string} idMachine\n     * @param {string} idDevice\n     * @param {LCConfig} [config]\n     */\n    constructor(idMachine, idDevice, config)\n    {\n        super(idMachine, idDevice, Chip.VERSION, config);\n\n        /*\n         * These are grid \"behavior\" properties.  If 'wrap' is true, then any off-grid neighbor cell\n         * locations are mapped to the opposite edge; otherwise, they are mapped to the LED \"scratch\" row.\n         */\n        this.fWrap = this.getDefaultBoolean('wrap', false);\n        this.sFont = this.getDefaultString('font', \"\");\n        this.font = this.sFont && Chip.FONTS[this.sFont] || Chip.FONTS[\"Helvetica\"];\n        this.sRule = this.getDefaultString('rule', \"\");\n        this.sPattern = this.getDefaultString('pattern', \"\");\n        this.setMessage(this.sMessageInit = this.getDefaultString('message', \"\"));\n        \n        /*\n         * The 'toggleColor' property currently affects only grids that have a color palette: if true,\n         * then only an LED's color is toggled; otherwise, only its state (ie, ON or OFF) is toggled.\n         */\n        this.fToggleColor = this.getDefaultBoolean('toggleColor', false);\n        \n        /*\n         * Since all bindings should have been completed by super(), we can make a preliminary call\n         * to getCounts() to determine how many counts are stored per LED, to preallocate a count buffer.\n         */\n        this.countBuffer = new Array(this.getCounts().length);\n\n        /*\n         * Get access to the LED device, so we can update its display.\n         */\n        let leds = /** @type {LED} */ (this.findDeviceByClass(Machine.CLASS.LED));\n        if (leds) {\n            this.leds = leds;\n\n            /*\n             * If loadPattern() didn't load anything into the LED array, then call\n             * clearBuffer(true), which performs a combination of clearBuffer() and drawBuffer().\n             */\n            if (!this.loadPattern()) leds.clearBuffer(true);\n\n            /*\n             * Get access to the Input device, so we can add our click functions.\n             */\n            this.input = /** @type {Input} */ (this.findDeviceByClass(Machine.CLASS.INPUT));\n            if (this.input) {\n                this.input.addClick(this.onPower.bind(this), this.onReset.bind(this));\n            }\n\n            let configInput = {\n                \"class\":        \"Input\",\n                \"location\":     [0, 0, leds.widthView, leds.heightView, leds.colsView, leds.rowsView],\n                \"drag\":         !!(this.input && this.input.fDrag),\n                \"scroll\":       !!(this.input && this.input.fScroll),\n                \"hexagonal\":    leds.fHexagonal,\n                \"bindings\":     {\"surface\": leds.getBindingID(LED.BINDING.CONTAINER)}\n            };\n\n            let chip = this;\n            this.ledInput = new Input(idMachine, idDevice + \"Input\", configInput);\n            this.ledInput.addInput(function onLEDInput(col, row) {\n                chip.onInput(col, row);\n            });\n\n            this.colors = [];\n            this.colorDefault = leds.getDefaultColor();\n            this.updateColorSelection(this.colorDefault);\n            this.updateColorSwatches();\n            this.updateBackgroundImage(this.config[Chip.BINDING.IMAGE_SELECTION]);\n\n            /*\n             * Get access to the Time device, so we can give it our clocker() function.\n             */\n            this.time = /** @type {Time} */ (this.findDeviceByClass(Machine.CLASS.TIME));\n            if (this.time) {\n                this.time.addClocker(this.clocker.bind(this));\n                this.time.addUpdater(this.updateStatus.bind(this));\n            }\n\n            /*\n             * Establish an onCommand() handler.\n             */\n            this.addHandler(Device.HANDLER.COMMAND, this.onCommand.bind(this));\n        }\n    }\n\n    /**\n     * addBinding(binding, element)\n     *\n     * @this {Chip}\n     * @param {string} binding\n     * @param {Element} element\n     */\n    addBinding(binding, element)\n    {\n        let chip = this;\n\n        switch(binding) {\n        case Chip.BINDING.COLOR_PALETTE:\n        case Chip.BINDING.COLOR_SELECTION:\n            element.onchange = function onSelectChange() {\n                chip.updateColorPalette(binding);\n            };\n            this.updateColorPalette();\n            break;\n\n        case Chip.BINDING.IMAGE_SELECTION:\n            element.onchange = function onImageChange() {\n                chip.updateBackgroundImage();\n            };\n            break;\n\n        case Chip.BINDING.PATTERN_SELECTION:\n            this.addBindingOptions(element, this.buildPatternOptions(this.config[Chip.BINDING.PATTERN_SELECTION]), false, this.config['pattern']);\n            element.onchange = function onPatternChange() {\n                chip.updatePattern();\n            };\n            break;\n\n        case Chip.BINDING.SAVE:\n            element.onclick = function onClickSave() {\n                let sPattern = chip.savePattern(true);\n                let elementSymbol = chip.bindings[Chip.BINDING.SYMBOL_INPUT];\n                if (elementSymbol) {\n                    sPattern = '\"' + elementSymbol.value + '\":\"' + sPattern.replace(/^([0-9]+\\/)*/, \"\") + '\",';\n                }\n                chip.println(sPattern);\n            };\n            break;\n\n        case Chip.BINDING.SAVE_TO_URL:\n            element.onclick = function onClickSaveToURL() {\n                let sPattern = chip.savePattern();\n                chip.println(sPattern);\n                let href = window.location.href;\n                if (href.indexOf('pattern=') >= 0) {\n                    href = href.replace(/(pattern=)[^&]*/, \"$1\" + sPattern.replace(/\\$/g, \"$$$$\"));\n                } else {\n                    href += ((href.indexOf('?') < 0)? '?' : '&') + \"pattern=\" + sPattern;\n                }\n                window.location = href;\n            };\n            break;\n\n        case Chip.BINDING.SYMBOL_INPUT:\n            let elementInput = /** @type {HTMLInputElement} */ (element);\n            elementInput.onkeypress = function onChangeSymbol(event) {\n                elementInput.value = String.fromCharCode(event.charCode);\n                let elementPreview = chip.bindings[Chip.BINDING.SYMBOL_PREVIEW];\n                if (elementPreview) elementPreview.textContent = elementInput.value;\n                event.preventDefault();\n            };\n            break;\n\n        default:\n            if (binding.startsWith(Chip.BINDING.COLOR_SWATCH)) {\n                element.onclick = function onClickColorSwatch() {\n                    chip.updateColorSwatches(binding);\n                };\n                break;\n            }\n            /*\n             * This code allows you to bind a specific control (ie, a button) to a specific pattern;\n             * however, it's preferable to use the PATTERN_SELECTION binding above, and use a single list.\n             */\n            let patterns = this.config[Chip.BINDING.PATTERN_SELECTION];\n            if (patterns && patterns[binding]) {\n                element.onclick = function onClickPattern() {\n                    chip.loadPattern(binding);\n                };\n            }\n        }\n        super.addBinding(binding, element);\n    }\n\n    /**\n     * buildPatternOptions(patterns)\n     *\n     * @this {Chip}\n     * @param {Object} patterns\n     * @returns {Object}\n     */\n    buildPatternOptions(patterns)\n    {\n        let options = {};\n        for (let id in patterns) {\n            let name = id;\n            let lines = patterns[id];\n            for (let i = 0; i < lines.length; i++) {\n                if (lines[i].indexOf(\"#N\") == 0) {\n                    name = lines[i].substr(2).trim();\n                    break;\n                }\n            }\n            options[name] = id;\n        }\n        return options;\n    }\n\n    /**\n     * clocker(nCyclesTarget)\n     *\n     * @this {Chip}\n     * @param {number} nCyclesTarget (0 to single-step)\n     * @returns {number} (number of cycles actually \"clocked\")\n     */\n    clocker(nCyclesTarget = 0)\n    {\n        let nCyclesClocked = 0;\n        if (nCyclesTarget >= 0) {\n            let nActive, nCycles = 1;\n            do {\n                switch(this.sRule) {\n                case Chip.RULES.ANIM4:\n                    nActive = this.doCycling();\n                    break;\n                case Chip.RULES.LEFT1:\n                    nCycles = nCyclesTarget || nCycles;\n                    nActive = this.doShifting(nCycles);\n                    break;\n                case Chip.RULES.LIFE1:\n                    nActive = this.doCounting();\n                    break;\n                }\n                if (!nCyclesTarget) this.println(\"active cells: \" + nActive);\n                nCyclesClocked += nCycles;\n            } while (nCyclesClocked < nCyclesTarget);\n        }\n        return nCyclesClocked;\n    }\n\n    /**\n     * doCounting()\n     *\n     * Implements rule LIFE1 (straight-forward implementation of Conway's Game of Life rule \"B3/S23\").\n     * \n     * This iterates row-by-row and column-by-column.  It takes advantage of the one-dimensional LED\n     * buffer layout to move through the entire grid with a \"master\" cell index (iCell) and corresponding\n     * indexes for all 8 \"neighboring\" cells (iNO, iNE, iEA, iSE, iSO, iSW, iWE, and iNW), incrementing\n     * them all in unison.\n     *\n     * The row and col variables are used only to detect when we are at the \"edges\" of the grid, and whether\n     * (depending on the wrap setting) any north, east, south, or west indexes that are now \"off the grid\"\n     * should be adjusted to the other side of the grid (or set to the dead \"scratch\" row at the end of the\n     * grid if wrap is disabled).  Similarly, when we leave an \"edge\", those same indexes must be restored\n     * to their normal positions, relative to the \"master\" index (iCell).\n     *\n     * The inline tests for whether iCell is at an edge are unavoidable, unless we break the logic up into\n     * 5 discrete steps: one for the rectangle just inside the edges, and then four for each of the north,\n     * east, south, and west edge strips.  But unless we really need that (presumably tiny) speed boost,\n     * I'm inclined to keep the logic simple.\n     *\n     * The logic is still a bit cluttered by the all the edge detection checks (and the wrap checks within\n     * each edge case), and perhaps I should have written two versions of this function (with and without wrap),\n     * but again, that would produce more repetition of the rest of the game logic, so I'm still inclined to\n     * leave it as-is.\n     *\n     * @this {Chip}\n     * @returns {number}\n     */\n    doCounting()\n    {\n        let cActive = 0;\n        let leds = this.leds;\n        let buffer = leds.getBuffer();\n        let bufferClone = leds.getBufferClone();\n        let nCols = leds.colsView;\n        let nRows = leds.rows;\n        /*\n         * The number of LED buffer elements per cell is an LED implementation detail that should not be\n         * assumed, so we obtain it from the LED object, and use it to calculate the per-cell increment,\n         * per-row increment, and per-grid increment; the latter gives us the offset of the LED buffer's\n         * scratch row, which we rely upon when wrap is turned off.\n         * \n         * NOTE: Since we're only processing colsView, not cols, we must include nBufferIncExtra in nIncPerRow.\n         */\n        let nInc = leds.nBufferInc;\n        let nIncPerRow = nCols * nInc + leds.nBufferIncExtra;\n        let nIncPerGrid = nRows * nIncPerRow;\n\n        let iCell = 0;\n        let iCellDummy = nIncPerGrid;\n        let iNO = iCell - nIncPerRow;\n        let iNW = iNO - nInc;\n        let iNE = iNO + nInc;\n        let iWE = iCell - nInc;\n        let iEA = iCell + nInc;\n        let iSO = iCell + nIncPerRow;\n        let iSW = iSO - nInc;\n        let iSE = iSO + nInc;\n\n        for (let row = 0; row < nRows; row++) {\n            if (!row) {                         // at top (north) edge; restore will be done after the col loop ends\n                if (!this.fWrap) {\n                    iNO = iNW = iNE = iCellDummy;\n                } else {\n                    iNO += nIncPerGrid; iNW += nIncPerGrid; iNE += nIncPerGrid;\n                }\n            } else if (row == nRows - 1) {      // at bottom (south) edge\n                if (!this.fWrap) {\n                    iSO = iSW = iSE = iCellDummy;\n                } else {\n                    iSO -= nIncPerGrid; iSW -= nIncPerGrid; iSE -= nIncPerGrid;\n                }\n            }\n            for (let col = 0; col < nCols; col++) {\n                if (!col) {                     // at left (west) edge\n                    if (!this.fWrap) {\n                        iWE = iNW = iSW = iCellDummy;\n                    } else {\n                        iWE += nIncPerRow; iNW += nIncPerRow; iSW += nIncPerRow;\n                    }\n                } else if (col == 1) {          // just finished left edge, restore west indexes\n                    if (!this.fWrap) {\n                        iWE = iCell - nInc; iNW = iNO - nInc; iSW = iSO - nInc;\n                    } else {\n                        iWE -= nIncPerRow; iNW -= nIncPerRow; iSW -= nIncPerRow;\n                    }\n                } else if (col == nCols - 1) {  // at right (east) edge; restore will be done after the col loop ends\n                    if (!this.fWrap) {\n                        iEA = iNE = iSE = iCellDummy;\n                    } else {\n                        iEA -= nIncPerRow; iNE -= nIncPerRow; iSE -= nIncPerRow;\n                    }\n                }\n                let state = buffer[iCell];\n                let nNeighbors = buffer[iNW]+buffer[iNO]+buffer[iNE]+buffer[iEA]+buffer[iSE]+buffer[iSO]+buffer[iSW]+buffer[iWE];\n\n                if (nNeighbors == 3) {\n                    state = LED.STATE.ON;\n                } else if (nNeighbors != 2) {\n                    state = LED.STATE.OFF;\n                }\n                bufferClone[iCell] = state;\n                bufferClone[iCell+1] = buffer[iCell+1];\n                bufferClone[iCell+2] = buffer[iCell+2];\n                bufferClone[iCell+3] = buffer[iCell+3] | ((buffer[iCell] !== state)? LED.FLAGS.MODIFIED : 0);\n                iCell += nInc; iNW += nInc; iNO += nInc; iNE += nInc; iEA += nInc; iSE += nInc; iSO += nInc; iSW += nInc; iWE += nInc;\n                if (state == LED.STATE.ON) cActive++;\n            }\n            if (!this.fWrap) {\n                if (!row) {\n                    iNO = iCell - nIncPerRow; iNW = iNO - nInc; iNE = iNO + nInc;\n                }\n                iEA = iCell + nInc; iNE = iNO + nInc; iSE = iSO + nInc;\n            } else {\n                if (!row) {\n                    iNO -= nIncPerGrid; iNW -= nIncPerGrid; iNE -= nIncPerGrid;\n                }\n                iEA += nIncPerRow; iNE += nIncPerRow; iSE += nIncPerRow;\n            }\n        }\n\n        /*\n         * swapBuffers() takes care of setting the buffer-wide modified flags (leds.fBufferModified), so we don't have to.\n         */\n        leds.swapBuffers();\n        return cActive;\n    }\n\n    /**\n     * doCycling()\n     *\n     * Implements rule ANIM4 (animation using 4-bit counters for state/color cycling).\n     *\n     * @this {Chip}\n     * @returns {number}\n     */\n    doCycling()\n    {\n        let cActive = 0;\n        let leds = this.leds;\n        let nCols = leds.colsView, nRows = leds.rows;\n        let counts = this.countBuffer;\n        for (let row = 0; row < nRows; row++) {\n            for (let col = 0; col < nCols; col++) {\n                if (!leds.getLEDCounts(col, row, counts)) continue;\n                cActive++;\n                /*\n                 * Here's the layout of each cell's counts (which mirrors the Chip.COUNTS layout):\n                 *\n                 *      [0] is the \"working\" count\n                 *      [1] is the ON count\n                 *      [2] is the OFF count\n                 *      [3] is the color-cycle count\n                 *\n                 * Whenever the working count is zero, we examine the cell's state and advance it to\n                 * the next state: if it was ON, it goes to OFF (and the OFF count is loaded into\n                 * the working count); if it was OFF, then color-cycle count (if any) is applied, and\n                 * the state goes to ON (and the ON count is loaded).\n                 */\n                if (counts[0]) {\n                    counts[0]--;\n                }\n                else {\n                    let state = leds.getLEDState(col, row), stateNew = state || 0;\n                    switch(state) {\n                    case LED.STATE.ON:\n                        stateNew = LED.STATE.OFF;\n                        counts[0] = counts[2];\n                        if (counts[0]) {\n                            counts[0]--;\n                            break;\n                        }\n                        /* falls through */\n                    case LED.STATE.OFF:\n                        if (counts[3]) {\n                            let color = leds.getLEDColor(col, row);\n                            let iColor = this.colors.indexOf(color);\n                            if (iColor >= 0) {\n                                iColor = (iColor + counts[3]);\n                                while (iColor >= this.colors.length) iColor -= this.colors.length;\n                                leds.setLEDColor(col, row, this.colors[iColor]);\n                            }\n                        }\n                        stateNew = LED.STATE.ON;\n                        counts[0] = counts[1];\n                        if (counts[0]) {\n                            counts[0]--;\n                        }\n                        break;\n                    }\n                    if (stateNew !== state) leds.setLEDState(col, row, stateNew);\n                }\n                leds.setLEDCounts(col, row, counts);\n            }\n        }\n        return cActive;\n    }\n\n    /**\n     * doShifting()\n     *\n     * Implements rule LEFT1 (shift left one cell).\n     * \n     * Some of the state we maintain outside of the LED array includes the number of columns of data remaining\n     * in the \"offscreen\" portion of the array (nMessageCount).  Whenever we see that it's zero, we load it with the\n     * next chuck of data (ie, the LED pattern for the next symbol in sMessage).\n     * \n     * @this {Chip}\n     * @param {number} [shift] (default is 1, for a leftward shift of one cell)\n     * @returns {number}\n     */\n    doShifting(shift = 1)\n    {\n        let cActive = 0;\n        let leds = this.leds;\n        let nCols = leds.cols, nRows = leds.rows;\n\n        /*\n         * If nShiftedLeft is already set, we can't allow another shift until the display has been redrawn.\n         */\n        if (leds.nShiftedLeft) {\n            return 0;\n        }\n\n        /*\n         * The way the code is currently written, shifting more than two cells at a time creates gap issues.\n         */\n\n        if (!this.processMessageCmd(shift)) {\n            return 0;\n        }\n\n        //\n        // This is a very slow and simple shift-and-exchange loop, which through a series of exchanges,\n        // also migrates the left-most column to the right-most column.  Good for testing but not much else.\n        //\n        // for (let row = 0; row < nRows; row++) {\n        //     for (let col = 0; col < nCols - 1; col++) {\n        //         let stateLeft = leds.getLEDState(col, row) || LED.STATE.OFF;\n        //         let stateRight = leds.getLEDState(col + 1, row) || LED.STATE.OFF;\n        //         if (stateRight) cActive++;\n        //         leds.setLEDState(col, row, stateRight);\n        //         leds.setLEDState(col + 1, row, stateLeft);\n        //     }\n        // }\n        // leds.nShiftedLeft = 1;\n        //\n\n        let buffer = leds.getBuffer();\n        let nInc = leds.nBufferInc * shift;\n        let nIncPerRow = leds.nBufferInc * nCols;\n        \n        let col = 0, nEmptyCols = 0, iCell = 0;\n        this.nLeftEmpty = this.nRightEmpty = -1;\n\n        while (col < nCols - shift) {\n            let isEmptyCol = 1;\n            let iCellOrig = iCell;\n            for (let row = 0; row < nRows; row++) {\n                let stateOld = buffer[iCell];\n                let stateNew = (buffer[iCell] = buffer[iCell + nInc]);\n                let flagsNew = ((stateNew !== stateOld)? LED.FLAGS.MODIFIED : 0);\n                buffer[iCell + 1] = buffer[iCell + nInc + 1];\n                buffer[iCell + 2] = buffer[iCell + nInc + 2];\n                buffer[iCell + 3] = buffer[iCell + nInc + 3] | flagsNew;\n                if (stateNew) {\n                    cActive++;\n                    isEmptyCol = 0;\n                }\n                iCell += nIncPerRow;\n            }\n            iCell = iCellOrig + leds.nBufferInc;\n            if (col++ < leds.colsView) {\n                if (isEmptyCol) {\n                    nEmptyCols++;\n                } else {\n                    if (this.nLeftEmpty < 0) this.nLeftEmpty = nEmptyCols;\n                    nEmptyCols = 0;\n                }\n            }\n        }\n\n        if (this.nLeftEmpty < 0) this.nLeftEmpty = nEmptyCols;\n        this.nRightEmpty = nEmptyCols;\n\n        while (col < nCols) {\n            let iCellOrig = iCell;\n            for (let row = 0; row < nRows; row++) {\n                leds.initCell(buffer, iCell);\n                iCell += nIncPerRow;\n            }\n            iCell = iCellOrig + leds.nBufferInc;\n            col++;\n        }\n\n        leds.fBufferModified = true;\n        leds.nShiftedLeft = shift;\n        \n        return cActive;\n    }\n\n    /**\n     * getCount(binding)\n     * \n     * @this {Chip}\n     * @param {string} binding \n     * @returns {number}\n     */\n    getCount(binding)\n    {\n        let count = 0;\n        let element = this.bindings[binding];\n        if (element && element.options) {\n            let option = element.options[element.selectedIndex];\n            count = option && +option.value || 0;\n        }\n        return count;\n    }\n    \n    /**\n     * getCounts()\n     *\n     * @this {Chip}\n     * @param {boolean} [fAdvance]\n     * @returns {Array.<number>}\n     */\n    getCounts(fAdvance)\n    {\n        let init = 0;\n        if (fAdvance) {\n            let element = this.bindings[Chip.BINDING.COUNT_INIT];\n            if (element && element.options) {\n                let option = element.options[element.selectedIndex];\n                if (option) {\n                    init = +option.value || 0;\n                    /*\n                     * A more regular pattern results if we stick to a range of counts equal to the\n                     * sum of the ON and OFF counts.  Let's get that sum now.  However, this assumes\n                     * that the user is starting with an initial count of ZERO.  Also, we're only going\n                     * to do this if the sum of ON and OFF counts is EVEN; if it's odd, then we'll let\n                     * the user do their thing.\n                     */\n                    element.selectedIndex++;\n                    let range = this.getCount(Chip.BINDING.COUNT_ON) + this.getCount(Chip.BINDING.COUNT_OFF);\n                    let fReset = (!(range & 1) && init == range - 1);\n                    if (fReset || element.selectedIndex < 0 || element.selectedIndex >= element.options.length) {\n                        element.selectedIndex = 0;\n                    }\n                }\n            }\n        }\n        let counts = [init];\n        for (let i = 1; i < Chip.COUNTS.length; i++) {\n            counts.push(this.getCount(Chip.COUNTS[i]));\n        }\n        return counts;\n    }\n\n    /**\n     * loadPattern(id)\n     *\n     * If no id is specified, load the initialization pattern, if any, set via the LCConfig\n     * \"pattern\" property (which, in turn, can be set as URL override, if desired).\n     *\n     * NOTE: Our initialization pattern is a extended single-string version of the RLE pattern\n     * file format: \"col/row/width/height/tokens\".  The default rule is assumed.\n     *\n     * @this {Chip}\n     * @param {string} [id]\n     * @returns {boolean}\n     */\n    loadPattern(id)\n    {\n        let leds = this.leds;\n        let iCol = -1, iRow = -1, width, height, rule, sPattern = \"\";\n\n        if (!id) {\n            /*\n             * If no id is provided, then we fallback to sPattern, which can be either an\n             * id (if it doesn't start with a digit) or one of our own extended pattern strings.\n             */\n            if (!this.sPattern.match(/^[0-9]/)) id = /** @type {string} */ (this.sPattern);\n        }\n\n        if (!id) {\n            if (!this.sPattern) {\n                return false;\n            }\n            let i = 0;\n            let aParts = this.sPattern.split('/');\n            if (aParts.length == 5) {           // extended pattern string\n                iCol = +aParts[i++];\n                iRow = +aParts[i++];\n            }\n            if (aParts.length == 3 || aParts.length == 5) {\n                width = +aParts[i++];           // conventional pattern string\n                height = +aParts[i++];\n                sPattern = aParts[i];\n            }\n            else {\n                this.println(\"unrecognized pattern: \" + this.sPattern);\n                return false;\n            }\n            rule = this.sRule;  // TODO: If we ever support multiple rules, then allow rule overrides, too\n        }\n        else {\n            let patterns = this.config[Chip.BINDING.PATTERN_SELECTION];\n            let lines = patterns && patterns[id];\n            if (!lines) {\n                this.println(\"unknown pattern: \" + id);\n                return false;\n            }\n            this.println(\"loading pattern '\" + id + \"'\");\n            for (let i = 0, n = 0; i < lines.length; i++) {\n                let sLine = lines[i];\n                if (sLine[0] == '#') {\n                    this.println(sLine);\n                    continue;\n                }\n                if (!n++) {\n                    let match = sLine.match(/x\\s*=\\s*([0-9]+)\\s*,\\s*y\\s*=\\s*([0-9]+)\\s*(?:,\\s*rule\\s*=\\s*(\\S+)|)/i);\n                    if (!match) {\n                        this.println(\"unrecognized header line\");\n                        return false;\n                    }\n                    width = +match[1];\n                    height = +match[2];\n                    rule = match[3];\n                    continue;\n                }\n                let end = sLine.indexOf('!');\n                if (end >= 0) {\n                    sPattern += sLine.substr(0, end);\n                    break;\n                }\n                sPattern += sLine;\n            }\n        }\n\n        if (rule != this.sRule) {\n            this.println(\"unsupported rule: \" + rule);\n            return false;\n        }\n\n        if (iCol < 0) iCol = (leds.cols - width) >> 1;\n        if (iRow < 0) iRow = (leds.rows - height) >> 1;\n\n        if (iCol < 0 || iCol + width > leds.cols || iRow < 0 || iRow + height > leds.rows) {\n            this.printf(\"pattern too large (%d,%d)\\n\", width, height);\n            return false;\n        }\n\n        return this.loadPatternString(iCol, iRow, sPattern) > 0;\n    }\n\n    /**\n     * loadPatternString(col, row, sPattern, fOverwrite)\n     *\n     * @this {Chip}\n     * @param {number} col\n     * @param {number} row\n     * @param {string} sPattern\n     * @param {boolean} [fOverwrite]\n     * @returns {number} (number of columns changed, 0 if none)\n     */\n    loadPatternString(col, row, sPattern, fOverwrite = false)\n    {\n        let leds = this.leds;\n        let rgb = [0, 0, 0, 1], counts = 0;\n        let fColors = false, fCounts = false;\n\n        /*\n         * TODO: Cache these pattern splits.\n         */\n        let aTokens = sPattern.split(/([a-z$])/i);\n        \n        if (!fOverwrite) leds.clearBuffer();\n        \n        /*\n         * We could add checks that verify that col and row stay within the bounds of the specified\n         * width and height of the pattern, but it's possible that there are some legit patterns out\n         * there that didn't get their bounds quite right.  And in any case, no harm can come of it,\n         * because setLEDState() will ignore any parameters outside the LED's array bounds.\n         */\n        let i = 0, iCol = col, colMax = 0;\n        while (i < aTokens.length - 1) {\n            let n = aTokens[i++];\n            let token = aTokens[i++];\n            let v = +n, nRepeat = (n === \"\"? 1 : v);\n            while (nRepeat--) {\n                let nAdvance = 0, fModified = false;\n                switch(token) {\n                case '$':\n                    fColors = fCounts = false;\n                    col = iCol;\n                    row++;\n                    break;\n                case 'C':\n                    counts = v;\n                    fCounts = true;\n                    break;\n                case 'R':\n                    rgb[0] = v;\n                    fColors = true;\n                    break;\n                case 'G':\n                    rgb[1] = v;\n                    fColors = true;\n                    break;\n                case 'B':\n                    rgb[2] = v;\n                    fColors = true;\n                    break;\n                case 'A':\n                    rgb[3] = v;\n                    fColors = true;\n                    break;\n                case 'b':\n                    fModified = leds.setLEDState(col, row, LED.STATE.OFF);\n                    nAdvance++;\n                    break;\n                case 'o':\n                    fModified = leds.setLEDState(col, row, LED.STATE.ON);\n                    nAdvance++;\n                    break;\n                default:\n                    this.printf(\"unrecognized pattern token: %s\\n\", token);\n                    break;\n                }\n                if (fModified == null) {\n                    this.printf(\"invalid pattern position (%d,%d)\\n\", col, row);\n                } else {\n                    if (fColors) {\n                        let color = leds.getRGBColorString(rgb);\n                        leds.setLEDColor(col, row, color);\n                    }\n                    if (fCounts) {\n                        leds.setLEDCountsPacked(col, row, counts);\n                    }\n                    if (colMax < col) colMax = col;\n                    col += nAdvance;\n                }\n            }\n        }\n\n        if (!fOverwrite) leds.drawBuffer(true);\n\n        return ((colMax -= (iCol - 1)) < 0? 0 : colMax);\n    }\n    \n    /**\n     * loadState(state)\n     *\n     * If any saved values don't match (possibly overridden), abandon the given state and return false.\n     * \n     * @this {Chip}\n     * @param {Object|Array|null} state\n     * @returns {boolean}\n     */\n    loadState(state)\n    {\n        if (state) {\n            let stateChip = state['stateChip'] || state[0];\n            if (!stateChip || !stateChip.length) {\n                this.println(\"Invalid saved state\");\n                return false;\n            }\n            let version = stateChip.shift();\n            if ((version|0) !== (Chip.VERSION|0)) {\n                this.printf(\"Saved state version mismatch: %3.2f\\n\", version);\n                return false;\n            }\n            try {\n                this.sMessage = stateChip.shift();\n                this.iMessageNext = stateChip.shift();\n                this.sMessageCmd = stateChip.shift();\n                this.nMessageCount = stateChip.shift();\n            } catch(err) {\n                this.println(\"Chip state error: \" + err.message);\n                return false;\n            }\n            if (!this.getURLParms()['message'] && !this.getURLParms()['pattern'] && !this.getURLParms()[Chip.BINDING.IMAGE_SELECTION]) {\n                let stateLEDs = state['stateLEDs'] || state[1];\n                if (stateLEDs && this.leds) {\n                    if (!this.leds.loadState(stateLEDs)) return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * onCommand(aTokens, machine)\n     *\n     * Processes commands for our \"mini-debugger\".\n     *\n     * @this {Chip}\n     * @param {Array.<string>} aTokens\n     * @param {Device} [machine]\n     * @returns {boolean} (true if processed, false if not)\n     */\n    onCommand(aTokens, machine)\n    {\n        let sResult = \"\";\n        let s = aTokens.shift();\n        let c = aTokens.shift();\n\n        switch(c[0]) {\n        case 's':\n            this.setMessage(aTokens.join(' '));\n            break;\n\n        case '?':\n            sResult = \"\";\n            Chip.COMMANDS.forEach(cmd => {sResult += '\\n' + cmd;});\n            if (sResult) sResult = \"additional commands:\" + sResult;\n            break;\n\n        default:\n            if (s) sResult = \"unrecognized command '\" + s + \"' (try '?')\";\n            break;\n        }\n        if (sResult) this.println(sResult.trim());\n        return true;\n    }\n\n    /**\n     * onInput(col, row)\n     *\n     * @this {Chip}\n     * @param {number} col\n     * @param {number} row\n     */\n    onInput(col, row)\n    {\n        let leds = this.leds;\n        if (col >= 0 && row >= 0) {\n            if (this.colorSelected) {\n                if (!leds.setLEDColor(col, row, this.colorSelected)) {\n                    if (this.fToggleColor) {\n                        leds.setLEDColor(col, row);\n                    } else {\n                        leds.setLEDState(col, row, LED.STATE.ON - leds.getLEDState(col, row));\n                    }\n                } else {\n                    leds.setLEDState(col, row, LED.STATE.ON);\n                }\n            }\n            else {\n                leds.setLEDState(col, row, LED.STATE.ON - leds.getLEDState(col, row));\n            }\n            let fAdvance = !!leds.getLEDState(col, row);\n            leds.setLEDCounts(col, row, this.getCounts(fAdvance));\n            leds.drawBuffer();\n        }\n    }\n    \n    /**\n     * onLoad()\n     *\n     * @this {Chip}\n     */\n    onLoad()\n    {\n        this.loadState(this.loadLocalStorage());\n    }\n\n    /**\n     * onPower(fOn)\n     *\n     * Automatically called by the Machine device after all other devices have been powered up (eg, after\n     * a page load event), as well as when all devices are being powered down (eg, before a page unload event).\n     *\n     * May subsequently be called by the Input device to provide notification of a user-initiated power event\n     * (eg, toggling a power button); in this case, fOn should NOT be set, so that no state is loaded or saved.\n     *\n     * @this {Chip}\n     * @param {boolean} [fOn] (true to power on, false to power off; otherwise, toggle it)\n     */\n    onPower(fOn)\n    {\n        if (this.time) {\n            if (fOn) {\n                this.time.start();\n            } else {\n                this.time.stop();\n            }\n        }\n    }\n\n    /**\n     * onReset()\n     *\n     * Called by the Input device to provide notification of a reset event.\n     *\n     * @this {Chip}\n     */\n    onReset()\n    {\n        this.println(\"reset\");\n        this.leds.clearBuffer(true);\n        this.leds.enableDisplay(true);\n        if (this.sMessageInit) this.setMessage(this.sMessageInit);\n    }\n\n    /**\n     * onSave()\n     *\n     * @this {Chip}\n     */\n    onSave()\n    {\n        this.saveLocalStorage(this.saveState());\n    }\n\n    /**\n     * processMessageCmd(shift, cmd, count)\n     * \n     * @this {Chip}\n     * @param {number} [shift]\n     * @param {string} [cmd]\n     * @param {number} [count]\n     * @returns {boolean} (true to shift another cell, false if not)\n     */\n    processMessageCmd(shift = 1, cmd, count)\n    {\n        if (cmd) {\n            this.sMessageCmd = cmd;\n            this.nMessageCount = count;\n        }\n\n        // this.println(\"processing command '\" + this.sMessageCmd + \"', count \" + this.nMessageCount);\n\n        switch(this.sMessageCmd) {\n\n        case Chip.MESSAGE_CMD.HALT:\n            return false;\n\n        case Chip.MESSAGE_CMD.LOAD:\n        case Chip.MESSAGE_CMD.SCROLL:\n            if (this.nMessageCount > 0) {\n                this.nMessageCount -= shift;\n                return true;\n            }\n            break;\n\n        case Chip.MESSAGE_CMD.PAUSE:\n            if (this.nMessageCount > 0) {\n                this.nMessageCount -= shift;\n                return false;\n            }\n            break;\n\n        case Chip.MESSAGE_CMD.CENTER:\n            if (this.nLeftEmpty > this.nRightEmpty) return true;\n            break;\n\n        case Chip.MESSAGE_CMD.OFF:\n            this.leds.enableDisplay(false);\n            this.sMessageCmd = Chip.MESSAGE_CMD.PAUSE;\n            break;\n\n        case Chip.MESSAGE_CMD.ON:\n            this.leds.enableDisplay(true);\n            this.sMessageCmd = Chip.MESSAGE_CMD.PAUSE;\n            break;\n\n        default:\n\n            return false;\n        }\n\n        if (!cmd) return this.processMessageSymbol(shift);\n        return false;\n    }\n    \n    /**\n     * processMessageSymbol(shift)\n     * \n     * @this {Chip}\n     * @param {number} [shift]\n     * @returns {boolean} (true if another message symbol loaded)\n     */\n    processMessageSymbol(shift = 1)\n    {\n        if (this.sMessage) {\n            if (this.iMessageNext >= this.sMessage.length) {\n                this.iMessageNext = 0;\n            }\n            let chSymbol = this.sMessage[this.iMessageNext++];\n            if (chSymbol == '$') {\n                let cols = 0;\n                let i = this.iMessageNext;\n                while (i < this.sMessage.length) {\n                    let d = this.sMessage.charCodeAt(i) - 0x30;\n                    if (d < 0 || d > 9) break;\n                    cols = cols * 10 + d;\n                    i++;\n                }\n                if (i < this.sMessage.length) {\n                    let ch = this.sMessage[i++];\n                    if (ch == '$') {\n                        this.iMessageNext = i;\n                    } else {\n                        let cmd = Chip.MESSAGE_CODE[ch];\n                        if (cmd) {\n                            this.iMessageNext = i;\n                            return this.processMessageCmd(shift, cmd, cols);\n                        }\n                        this.println(\"unrecognized message code: $\" + ch);\n                    }\n                }\n            }\n            if (chSymbol == ' ') {\n                this.nMessageCount += 2;\n            } else {\n                let col = this.leds.colsView + 1;\n                let delta = (this.nMessageCount < 0? this.nMessageCount : 0);\n                let sPattern = this.font[chSymbol] || this.font[chSymbol.toUpperCase()];\n                let row = Math.round((this.leds.rowsView - this.font['height']) / 2);\n                if (sPattern) this.nMessageCount += this.loadPatternString(col + delta, (row < 0? 0 : row), sPattern, true);\n                this.nMessageCount += (2 - shift);\n                // this.printf(\"loaded symbol '%s' at offscreen column %d (%d), new count %d\\n\", chSymbol, (col - this.leds.colsView), delta, this.nMessageCount);\n            }\n            this.sMessageCmd = Chip.MESSAGE_CMD.SCROLL;\n            return true;\n        }\n        this.sMessageCmd = Chip.MESSAGE_CMD.HALT;\n        return false;\n    }\n    \n    /**\n     * savePattern(fMinWidth, fMinHeight)\n     *\n     * We save our patterns as a string that is largely compatible with the \"Game of Life RLE Format\"\n     * (refer to http://www.conwaylife.com/w/index.php?title=Run_Length_Encoded), which uses <repetition><tag>\n     * pairs to describes runs of identical cells; the <tag> is either 'o' for \"active\" cells, 'b' for \"inactive\"\n     * cells, or '$' for end of line.\n     *\n     * We say \"largely\" compatible because it's not really a goal for our pattern strings to be compatible\n     * with any other RLE reader.  For example, we don't break our string into lines of 70 characters or less,\n     * so that's already one incompatibility.  Also, we don't attempt to determine the minimum bounding\n     * rectangle for the current pattern, because we use these strings to save/restore the entire grid as it\n     * originally appeared, not just the pattern within the grid.  Both of those differences can be dealt with\n     * in the future with a special RLE-compatibility flag, if we ever care.\n     *\n     * Moreover, we must deal with grids containing multi-color cells and additional state (eg, internal counters)\n     * not found in typical \"Game of Life\" grids, so we may precede each <repetition><tag> pair with zero or more\n     * <value><modifier> pairs, where <modifier> can be:\n     *\n     *      'R':    red color value (assumed zero if not present)\n     *      'G':    green color value (assumed zero if not present)\n     *      'B':    blue color value (assumed zero if not present)\n     *      'C':    packed count value (ie, internal counts packed into a single unsigned 32-bit number)\n     *\n     * If we use any of the above modifiers, they are always preceded with a value unless the value is zero\n     * (unlike the <repetition><tag> pairs, where a repetition of 1 is assumed if omitted).\n     *\n     * Also, a modifier remains in effect until modified by another modifier, reducing the amount of\n     * \"modifier noise\" in the pattern string.\n     *\n     * @this {Chip}\n     * @param {boolean} [fMinWidth] (set to true to determine the minimum width)\n     * @param {boolean} [fMinHeight] (set to true to determine the minimum height)\n     * @returns {string}\n     */\n    savePattern(fMinWidth, fMinHeight)\n    {\n        let leds = this.leds;\n\n        let sPattern = \"\";\n        let iCol = 0, iRow = 0;\n        let nCols = this.leds.cols, nRows = this.leds.rows;\n\n        let fColors = !!this.colors.length;\n        let state, rgb = [0, 0, 0], counts;\n        let stateLast = 0, rgbLast = [0, 0, 0, 1], countsLast = 0;\n        let statePrev = 0, rgbPrev = [0, 0, 0, 1], countsPrev = 0, nPrev = 0;\n\n        /**\n         * flushRun(fEndRow)\n         * \n         * @param {boolean} [fEndRow]\n         */\n        let flushRun = function(fEndRow) {\n            let fDelta = false;\n            if (rgb[3] == null) rgb[3] = 1;\n            if (nPrev) {\n                if (fColors) {\n                    if (rgb[0] !== rgbPrev[0] || rgb[1] !== rgbPrev[1] || rgb[2] !== rgbPrev[2] || rgb[3] !== rgbPrev[3]) {\n                        fDelta = true;\n                    }\n                    if (counts !== countsPrev) {\n                        fDelta = true;\n                    }\n                }\n                if (state !== statePrev) {\n                    fDelta = true;\n                }\n                if (fDelta || fEndRow && statePrev) {\n                    if (fColors) {\n                        if (rgbLast[0] !== rgbPrev[0]) {\n                            rgbLast[0] = rgbPrev[0];\n                            sPattern += (rgbPrev[0] || \"\") + 'R';\n                        }\n                        if (rgbLast[1] !== rgbPrev[1]) {\n                            rgbLast[1] = rgbPrev[1];\n                            sPattern += (rgbPrev[1] || \"\") + 'G';\n                        }\n                        if (rgbLast[2] !== rgbPrev[2]) {\n                            rgbLast[2] = rgbPrev[2];\n                            sPattern += (rgbPrev[2] || \"\") + 'B';\n                        }\n                        if (rgbLast[3] !== rgbPrev[3]) {\n                            rgbLast[3] = rgbPrev[3];\n                            sPattern += (rgbPrev[3] || \"\") + 'A';\n                        }\n                        if (countsLast !== countsPrev) {\n                            countsLast = countsPrev;\n                            sPattern += (countsPrev || \"\") + 'C';\n                        }\n                    }\n                    if (nPrev > 1) sPattern += nPrev;\n                    sPattern += (statePrev === LED.STATE.ON? 'o' : 'b');\n                    stateLast = statePrev;\n                    fDelta = true;\n                }\n            }\n            if (fEndRow) {\n                sPattern += '$';\n                nPrev = 0;\n            } else {\n                if (!fDelta) {\n                    nPrev++;\n                } else {\n                    nPrev = 1;\n                }\n                statePrev = state;\n                rgbPrev[0] = rgb[0];\n                rgbPrev[1] = rgb[1];\n                rgbPrev[2] = rgb[2];\n                rgbPrev[3] = rgb[3];\n                countsPrev = counts;\n            }\n        };\n\n        /*\n         * Before we begin, see if either fMinWidth or fMinHeight are set, requiring a bounds prescan.\n         */\n        let colMin = 0, colMax = leds.cols - 1;\n        let rowMin = 0, rowMax = leds.rows - 1;\n        if (fMinWidth || fMinHeight) {\n            if (fMinWidth) {\n                colMin = colMax; colMax = 0;\n            }\n            if (fMinHeight) {\n                rowMin = rowMax; rowMax = 0;\n            }\n            for (let row = 0; row < leds.rows; row++) {\n                for (let col = 0; col < leds.cols; col++) {\n                    state = leds.getLEDState(col, row);\n                    if (state) {\n                        if (fMinWidth) {\n                            if (colMin > col) colMin = col;\n                            if (colMax < col) colMax = col;\n                        }\n                        if (fMinHeight) {\n                            if (rowMin > row) rowMin = row;\n                            if (rowMax < row) rowMax = row;\n                        }\n                    }\n                }\n            }\n            nCols = colMax - colMin + 1;\n            nRows = rowMax - rowMin + 1;\n            if (nCols < 0) nCols = 0;\n            if (nRows < 0) nRows = 0;\n        }\n\n        /*\n         * Begin pattern generation.\n         */\n        for (let row = rowMin; row <= rowMax; row++) {\n            for (let col = colMin; col <= colMax; col++) {\n                state = leds.getLEDState(col, row);\n                leds.getLEDColorValues(col, row, rgb);\n                counts = leds.getLEDCountsPacked(col, row);\n                flushRun();\n            }\n            flushRun(true);\n        }\n\n        /*\n         * Remove all '$' at the beginning of the pattern, if we've asked for the minimum height (or no minimums at all)\n         */\n        if (fMinHeight || !fMinWidth) {\n            while (sPattern[0] == '$') {\n                iRow++; nRows--;\n                sPattern = sPattern.slice(1);\n            }\n        }\n\n        /*\n         * Similarly, remove all '$$' at the end of the pattern.\n         */\n        while (sPattern.slice(-2) == '$$') {\n            nRows--;\n            sPattern = sPattern.slice(0, -1);\n        }\n        if (sPattern == '$') nRows = 0;\n\n        /*\n         * If we've asked for either the minimum width or height, then don't bother including starting col and row (which\n         * we only want for patterns used to save/restore the state of the entire grid).\n         */\n        sPattern = ((fMinWidth || fMinHeight)? \"\" : (iCol + '/' + iRow + '/')) + nCols + '/' + nRows + '/' + sPattern.slice(0, -1);\n        sPattern = sPattern.replace(/\\$+$/, '');\n        return sPattern;\n    }\n\n    /**\n     * saveState()\n     *\n     * @this {Chip}\n     * @returns {Array}\n     */\n    saveState()\n    {\n        let state = [[],[]];\n        let stateChip = state[0];\n        let stateLEDs = state[1];\n        stateChip.push(Chip.VERSION);\n        stateChip.push(this.sMessage);\n        stateChip.push(this.iMessageNext);\n        stateChip.push(this.sMessageCmd);\n        stateChip.push(this.nMessageCount);\n        if (this.leds) {\n            this.leds.saveState(stateLEDs);\n        }\n        return state;\n    }\n\n    /**\n     * setMessage(s)\n     *\n     * @this {Chip}\n     * @param {string} s\n     */\n    setMessage(s)\n    {\n        if (this.sMessage != s) {\n            if (s) this.println(\"new message: '\" + s + \"'\");\n            this.sMessage = s;\n        }\n        this.sMessageCmd = Chip.MESSAGE_CMD.LOAD;\n        this.iMessageNext = this.nMessageCount = 0;\n    }\n    \n    /**\n     * updateBackgroundImage(sImage)\n     *\n     * @this {Chip}\n     * @param {string} [sImage]\n     */\n    updateBackgroundImage(sImage)\n    {\n        let element = this.bindings[Chip.BINDING.IMAGE_SELECTION];\n        if (element && element.options.length) {\n            if (sImage) {\n                for (let i = 0; i < element.options.length; i++) {\n                    if (element.options[i].value == sImage) {\n                        element.selectedIndex = i;\n                        break;\n                    }\n                }\n            }\n            sImage = element.options[element.selectedIndex].value;\n            this.leds.setContainerStyle('backgroundImage', sImage? (\"url('\" + sImage + \"')\") : \"none\");\n        }\n    }\n\n    /**\n     * updateColorPalette(binding)\n     *\n     * In addition to being called whenever the COLOR_PALETTE or COLOR_SELECTION onChange handler is\n     * called, this is also called when any of the color controls are initialized, because we don't know\n     * in what order the elements will be bound.\n     *\n     * @this {Chip}\n     * @param {string} [binding] (if set, the selection for the specified binding has changed)\n     */\n    updateColorPalette(binding)\n    {\n        let elementPalette = this.bindings[Chip.BINDING.COLOR_PALETTE];\n        let elementSelection = this.bindings[Chip.BINDING.COLOR_SELECTION];\n\n        let fPaletteChange = (binding === Chip.BINDING.COLOR_PALETTE);\n        if (elementPalette && !elementPalette.options.length) {\n            this.addBindingOptions(elementPalette, this.config['colors'], true);\n            fPaletteChange = true;\n        }\n\n        if (elementPalette && elementSelection && (!elementSelection.options.length || fPaletteChange)) {\n            let sPalette = elementPalette.options[elementPalette.selectedIndex].value;\n            this.colorPalette = this.config['colors'][sPalette];\n            for (let color in this.colorPalette) {\n                let sColorOverride = this.config[color.toLowerCase()];\n                if (sColorOverride) {\n                    if (sColorOverride[0] != '#') sColorOverride = '#' + sColorOverride;\n                    this.println(\"overriding color '\" + color + \"' with \" + sColorOverride + \" (formerly \" + this.colorPalette[color] + \")\");\n                    this.colorPalette[color] = sColorOverride;\n                }\n            }\n            this.addBindingOptions(elementSelection, this.colorPalette, true);\n        }\n\n        if (elementPalette && elementSelection && elementSelection.options.length) {\n            this.colorSelected = elementSelection.options[elementSelection.selectedIndex].value;\n            this.updateColorSwatches();\n        }\n    }\n\n    /**\n     * updateColorSelection(color)\n     *\n     * @this {Chip}\n     * @param {string} color\n     */\n    updateColorSelection(color)\n    {\n        let element = this.bindings[Chip.BINDING.COLOR_SELECTION];\n        if (element) {\n            let i;\n            for (i = 0; i < element.options.length; i++) {\n                if (element.options[i].value == color) {\n                    this.colorSelected = color;\n                    if (element.selectedIndex != i) {\n                        element.selectedIndex = i;\n                    }\n                    break;\n                }\n            }\n            if (i == element.options.length) element.selectedIndex = 0;\n        }\n    }\n\n    /**\n     * updateColorSwatches(binding)\n     *\n     * @this {Chip}\n     * @param {string} [binding] (set if a specific color swatch was just clicked)\n     */\n    updateColorSwatches(binding)\n    {\n        let i = 1, elementSwatch;\n        /*\n         * Some machines use a single swatch called COLOR_SWATCH_SELECTED; update as appropriate.\n         */\n        if (!binding) {\n            if (this.colorSelected) {\n                elementSwatch = this.bindings[Chip.BINDING.COLOR_SWATCH_SELECTED];\n                if (elementSwatch) {\n                    elementSwatch.style.backgroundColor = this.colorSelected;\n                }\n            }\n        }\n        /*\n         * Other machines use a series of swatches named COLOR_SWATCH + \"1\", COLOR_SWATCH + \"2\", etc;\n         * for each color in colorPalette, update the next available swatch.\n         */\n        if (this.colorPalette) {\n            for (let idColor in this.colorPalette) {\n                let color = this.colorPalette[idColor];\n                if (this.colors) this.colors[i-1] = color;\n                let idSwatch = Chip.BINDING.COLOR_SWATCH + i++;\n                elementSwatch = this.bindings[idSwatch];\n                if (!elementSwatch) break;\n                elementSwatch.style.display = \"inline-block\";\n                if (idSwatch == binding) {\n                    this.updateColorSelection(color);\n                }\n                if (binding && binding != idSwatch || color != this.colorSelected) {\n                    color = this.leds.getRGBAColor(color, 1.0, 0.50);\n                }\n                elementSwatch.style.backgroundColor = color;\n            }\n        }\n        /*\n         * Finally, for any remaining swatches in the series (ie, because the current palette doesn't need\n         * them all), hide them.\n         */\n        while (true) {\n            let idSwatch = Chip.BINDING.COLOR_SWATCH + i++;\n            let elementSwatch = this.bindings[idSwatch];\n            if (!elementSwatch) break;\n            elementSwatch.style.display = \"none\";\n        }\n    }\n\n    /**\n     * updatePattern()\n     *\n     * @this {Chip}\n     */\n    updatePattern()\n    {\n        let element = this.bindings[Chip.BINDING.PATTERN_SELECTION];\n        if (element && element.options.length) {\n            let sPattern = element.options[element.selectedIndex].value;\n            if (!sPattern) {\n                this.onReset();\n            } else {\n                this.loadPattern(sPattern);\n            }\n        }\n    }\n\n    /**\n     * updateStatus(fTransition)\n     *\n     * Update the LEDs as needed.\n     *\n     * Called by Time's updateStatus() function whenever 1) its YIELDS_PER_UPDATE threshold is reached\n     * (default is twice per second), 2) a step() operation has just finished (ie, the device is being\n     * single-stepped), and 3) a start() or stop() transition has occurred.\n     *\n     * Of those, all we currently care about are step() and stop() notifications, because we want to make sure\n     * the LED display is in sync with the last LED buffer update.  In both of those cases, time has stopped.\n     * If time has NOT stopped, then the LED's normal animator function (ledAnimate()) takes care of updating\n     * the LED display.\n     *\n     * @this {Chip}\n     * @param {boolean} [fTransition]\n     */\n    updateStatus(fTransition)\n    {\n        if (!this.time.isRunning()) {\n            this.leds.drawBuffer();\n        }\n    }\n}\n\nChip.BINDING = {\n    COLOR_PALETTE:          \"colorPalette\",\n    COLOR_SELECTION:        \"colorSelection\",\n    COLOR_SWATCH:           \"colorSwatch\",\n    COLOR_SWATCH_SELECTED:  \"colorSwatchSelected\",\n    COUNT_INIT:             \"countInit\",\n    COUNT_ON:               \"countOn\",\n    COUNT_OFF:              \"countOff\",\n    COUNT_CYCLE:            \"countCycle\",\n    IMAGE_SELECTION:        \"backgroundImage\",\n    PATTERN_SELECTION:      \"patterns\",\n    SYMBOL_INPUT:           \"symbolInput\",\n    SYMBOL_PREVIEW:         \"symbolPreview\",\n    SAVE:                   \"save\",\n    SAVE_TO_URL:            \"saveToURL\"\n};\n\nChip.COUNTS = [null, Chip.BINDING.COUNT_ON, Chip.BINDING.COUNT_OFF, Chip.BINDING.COUNT_CYCLE];\n\nChip.COMMANDS = [\n    \"s\\tset string\"\n];\n\nChip.MESSAGE_CMD = {\n    LOAD:       \"load\",\n    SCROLL:     \"scroll\",\n    PAUSE:      \"pause\",\n    HALT:       \"halt\",\n    CENTER:     \"center\",\n    OFF:        \"off\",\n    ON:         \"on\"\n};\n\n/*\n * The symbol `$` is used as a prefix to embed \"command codes\" in an LED message.  Current command codes include:\n *\n *      $b (blank the display; turns all LEDs off)\n *      $c (center the current display contents; ie, continue scrolling until centered)\n *      $h (halt scrolling)\n *      $o (turn the display on; the opposite of blank)\n *      $p (pause scrolling)\n *      $s (scroll/shift the display one cell, without adding more symbols)\n *\n * The default operation is to scroll the display, adding new symbols to the vacated end of the display as needed.\n * When all symbols in the current message have been processed, processing returns to the beginning of the message.\n *\n * To change the default operation at any point, insert one or more command codes into the string.  Commands may also\n * include a count immediately after the `$` (eg, `$90s`), which determines how many \"steps\" (cycles) that command\n * should remain in effect before advancing to the next symbol (or command) in the message.  So, for example, `$90s`\n * will scroll the display 90 times (without adding new symbols) before continuing to the next symbol.  The default\n * count for an operation is 1.\n *\n * For convenience, commands that don't need a count (eg, `$b` and `$o`) automatically treat the count as a pause (`$p`).\n * In other words, `$30b` is equivalent to `$b$30p`.\n *\n * Finally, if you want to embed `$` as a normal symbol, use two of them (`$$`).\n */\nChip.MESSAGE_CODE = {\n    'b':        Chip.MESSAGE_CMD.OFF,\n    'c':        Chip.MESSAGE_CMD.CENTER,\n    'h':        Chip.MESSAGE_CMD.HALT,\n    'o':        Chip.MESSAGE_CMD.ON,\n    'p':        Chip.MESSAGE_CMD.PAUSE,\n    's':        Chip.MESSAGE_CMD.SCROLL\n};\n\nChip.RULES = {\n    ANIM4:      \"A4\",       // animation using 4-bit counters for state/color cycling\n    LEFT1:      \"L1\",       // shift left one cell\n    LIFE1:      \"B3/S23\"    // Game of Life v1.0 (births require 3 neighbors, survivors require 2 or 3)\n};\n\n/*\n * Symbols can be formed with the following grid patterns.\n */\nChip.FONTS = {\n    \"Helvetica\": {          // designed for 16x16 grids\n        \"width\": 16,\n        \"height\": 16,\n        \"0\":\"$2b2o$bo2bo$o4bo$o4bo$o4bo$o4bo$o4bo$o4bo$o4bo$bo2bo$2b2o\",\n        \"1\":\"$3bo$2b2o$4o$3bo$3bo$3bo$3bo$3bo$3bo$3bo$3bo\",\n        \"2\":\"$2b3o$bo3bo$o5bo$o5bo$6bo$5bo$3b2o$2bo$bo$o$7o\",\n        \"3\":\"$b4o$o4bo$o4bo$5bo$4bo$2b2o$4bo$5bo$o4bo$o4bo$b4o\",\n        \"4\":\"$5bo$4b2o$3bobo$2bo2bo$bo3bo$o4bo$o4bo$8o$5bo$5bo$5bo\",\n        \"5\":\"$6o$o$o$o$4o$4bo$5bo$5bo$5bo$o3bo$b3o\",\n        \"6\":\"$2b4o$bo4bo$o$o$o$ob4o$2o4bo$o5bo$o5bo$bo4bo$2b4o\",\n        \"7\":\"$8o$7bo$6bo$5bo$4bo$4bo$3bo$3bo$2bo$2bo$2bo\",\n        \"8\":\"$b4o$o4bo$o4bo$o4bo$bo2bo$2b2o$bo2bo$o4bo$o4bo$o4bo$b4o\",\n        \"9\":\"$b4o$o4bo$o5bo$o5bo$o4b2o$b4obo$6bo$6bo$6bo$o4bo$b4o\",\n        \"A\":\"$3b2o$2bo2bo$bo4bo$bo4bo$o6bo$o6bo$o6bo$8o$o6bo$o6bo$o6bo\",\n        \"B\":\"$6o$o5bo$o5bo$o5bo$o4bo$7o$o6bo$o6bo$o6bo$o6bo$7o\",\n        \"C\":\"$2b4o$bo4bo$o6bo$o$o$o$o$o$o6bo$bo4bo$2b4o\",\n        \"D\":\"$6o$o5bo$o6bo$o6bo$o6bo$o6bo$o6bo$o6bo$o6bo$o5bo$6o\",\n        \"E\":\"$7o$o$o$o$o$6o$o$o$o$o$7o\",\n        \"F\":\"$7o$o$o$o$o$6o$o$o$o$o$o\",\n        \"G\":\"$2b4o$bo4bo$o$o$o$o3b4o$o6bo$o6bo$o6bo$bo4bo$2b4o\",\n        \"H\":\"$o6bo$o6bo$o6bo$o6bo$o6bo$8o$o6bo$o6bo$o6bo$o6bo$o6bo\",\n        \"I\":\"$o$o$o$o$o$o$o$o$o$o$o\",\n        \"J\":\"$5bo$5bo$5bo$5bo$5bo$5bo$5bo$o4bo$o4bo$o4bo$b4o\",\n        \"K\":\"$o6bo$o5bo$o4bo$o3bo$o2bo$ob2o$2o2bo$o4bo$o5bo$o6bo$o7bo\",\n        \"L\":\"$o$o$o$o$o$o$o$o$o$o$7o\",\n        \"M\":\"$o8bo$2o6b2o$obo4bobo$obo4bobo$o2bo2bo2bo$o2bo2bo2bo$o3b2o3bo$o8bo$o8bo$o8bo$o8bo\",\n        \"N\":\"$2o5bo$obo4bo$obo4bo$o2bo3bo$o2bo3bo$o3bo2bo$o3bo2bo$o4bobo$o4bobo$o4bobo$o5b2o\",\n        \"O\":\"$3b4o$2bo4bo$bo6bo$o8bo$o8bo$o8bo$o8bo$o8bo$bo6bo$2bo4bo$3b4o\",\n        \"P\":\"$6o$o5bo$o6bo$o6bo$o6bo$o5bo$6o$o$o$o$o\",\n        \"Q\":\"$3b4o$2bo4bo$bo6bo$o8bo$o8bo$o8bo$o8bo$o8bo$bo4bobo$2bo4bo$3b4obo$9bo\",\n        \"R\":\"$6o$o5bo$o5bo$o5bo$o5bo$6o$o2bo$o3bo$o4bo$o5bo$o6bo\",\n        \"S\":\"$2b4o$bo4bo$o6bo$o$bo$2b4o$6bo$7bo$o6bo$bo4bo$2b4o\",\n        \"T\":\"$9o$4bo$4bo$4bo$4bo$4bo$4bo$4bo$4bo$4bo$4bo\",\n        \"U\":\"$o6bo$o6bo$o6bo$o6bo$o6bo$o6bo$o6bo$o6bo$o6bo$bo4bo$2b4o\",\n        \"V\":\"$o8bo$o8bo$bo6bo$bo6bo$bo6bo$2bo4bo$2bo4bo$2bo4bo$3bo2bo$3bo2bo$4b2o\",\n        \"W\":\"$o4b2o4bo$o4b2o4bo$o4b2o4bo$o3bo2bo3bo$bo2bo2bo2bo$bo2bo2bo2bo$bo2bo2bo2bo$bo2bo2bo2bo$2b2o4b2o$2b2o4b2o$2b2o4b2o\",\n        \"X\":\"$o8bo$bo6bo$2bo4bo$3bo2bo$4b2o$4b2o$4b2o$3bo2bo$2bo4bo$bo6bo$o8bo\",\n        \"Y\":\"$o5bo$o5bo$bo3bo$bo3bo$2bobo$2bobo$3bo$3bo$3bo$3bo$3bo\",\n        \"Z\":\"$9o$8bo$7bo$6bo$5bo$4bo$3bo$2bo$bo$o$9o\",\n        \"a\":\"$$$$b4o$o4bo$5bo$b5o$o4bo$o4bo$o3b2o$b3obo\",\n        \"b\":\"$o$o$o$ob3o$2o3bo$o5bo$o5bo$o5bo$o5bo$2o3bo$ob3o\",\n        \"c\":\"$$$$2b4o$bo4bo$o$o$o$o$bo4bo$2b4o\",\n        \"d\":\"$6bo$6bo$6bo$2b3obo$bo3b2o$o5bo$o5bo$o5bo$o5bo$bo3b2o$2b3obo\",\n        \"e\":\"$$$$2b3o$bo3bo$o5bo$7o$o$o$bo4bo$2b4o\",\n        \"f\":\"$2b2o$bo2bo$bo$bo$4o$bo$bo$bo$bo$bo$bo\",\n        \"g\":\"$$$$2b2obo$bo2b2o$o4bo$o4bo$o4bo$bo2b2o$2b2obo$5bo$5bo$o4bo$b4o\",\n        \"h\":\"$o$o$o$ob3o$2o3bo$o4bo$o4bo$o4bo$o4bo$o4bo$o4bo\",\n        \"i\":\"$$o$$o$o$o$o$o$o$o$o\",\n        \"j\":\"$$3bo$$3bo$3bo$3bo$3bo$3bo$3bo$3bo$3bo$3bo$o2bo$b2o\",\n        \"k\":\"$o$o$o$o4bo$o3bo$o2bo$obo$2obo$o3bo$o4bo$o5bo\",\n        \"l\":\"$o$o$o$o$o$o$o$o$o$o$o\",\n        \"m\":\"$$$$ob2o3b2o$2o2bobo2bo$o4bo4bo$o4bo4bo$o4bo4bo$o4bo4bo$o4bo4bo$o4bo4bo\",\n        \"n\":\"$$$$ob3o$2o3bo$o4bo$o4bo$o4bo$o4bo$o4bo$o4bo\",\n        \"o\":\"$$$$2b4o$bo4bo$o6bo$o6bo$o6bo$o6bo$bo4bo$2b4o\",\n        \"p\":\"$$$$ob3o$2o3bo$o5bo$o5bo$o5bo$o5bo$2o3bo$ob3o$o$o$o\",\n        \"q\":\"$$$$2b3obo$bo3b2o$o5bo$o5bo$o5bo$o5bo$bo3b2o$2b3obo$6bo$6bo$6bo\",\n        \"r\":\"$$$$ob2o$2o2bo$o$o$o$o$o$o\",\n        \"s\":\"$$$$b4o$o4bo$o$b4o$5bo$5bo$o4bo$b4o\",\n        \"t\":\"$$bo$bo$4o$bo$bo$bo$bo$bo$bo2bo$2b2o\",\n        \"u\":\"$$$$o4bo$o4bo$o4bo$o4bo$o4bo$o4bo$o3b2o$b3obo\",\n        \"v\":\"$$$$o5bo$o5bo$bo3bo$bo3bo$bo3bo$2bobo$2bobo$3bo\",\n        \"w\":\"$$$$o3b2o3bo$o3b2o3bo$o3b2o3bo$o3b2o3bo$bobo2bobo$bobo2bobo$bobo2bobo$2bo4bo\",\n        \"x\":\"$$$$$o5bo$bo3bo$2bobo$3bo$2bobo$bo3bo$o5bo\",\n        \"y\":\"$$$$o5bo$o5bo$bo3bo$bo3bo$2bobo$2bobo$3bo$3bo$3bo$2bo$2o\",\n        \"z\":\"$$$$6o$5bo$4bo$3bo$2bo$bo$o$6o\",\n        \"!\":\"$o$o$o$o$o$o$o$o$$o$o\",\n        \"\\\"\":\"$obo$obo$obo$obo\",\n        \"#\":\"$2bo2bo$2bo2bo$2bo2bo$8o$2bo2bo$2bo2bo$2bo2bo$8o$2bo2bo$2bo2bo$2bo2bo\",\n        \"$\":\"3bo$2b4o$bobo2bo$o2bo$o2bo$bobo$2b3o$3bobo$3bo2bo$3bo2bo$o2bobo$b4o$3bo\",\n        \"%\":\"$b2o7bo$o2bo5bo$o2bo4bo$o2bo3bo$o2bo2bo$b2o2bo2b2o$4bo2bo2bo$3bo3bo2bo$2bo4bo2bo$bo5bo2bo$o7b2o\",\n        \"&\":\"$b3o$o3bo$o3bo$o3bo$bobo$2bo$bobo$o3bobo$o4bo$o3bobo$b3o3bo\",\n        \"'\":\"$o$o$o$o\",\n        \"(\":\"$3bo$2bo$bo$bo$o$o$o$o$o$o$bo$bo$2bo$3bo\",\n        \")\":\"$o$bo$2bo$2bo$3bo$3bo$3bo$3bo$3bo$3bo$2bo$2bo$bo$o\",\n        \"*\":\"2bo$obobo$b3o$b3o$o3bo\",\n        \"+\":\"$$$$3bo$3bo$3bo$7o$3bo$3bo$3bo\",\n        \",\":\"$$$$$$$$$$2o$2o$bo$o\",\n        \".\":\"$$$$$$$$$$2o$2o\",\n        \"/\":\"$3bo$3bo$2bo$2bo$2bo$bo$bo$bo$o$o$o\",\n        \":\":\"$$$$2o$2o$$$$$2o$2o\",\n        \";\":\"$$$$2o$2o$$$$$2o$2o$bo$o\",\n        \"<\":\"$$$$6b2o$4b2o$2b2o$2o$2o$2b2o$4b2o$6b2o\",\n        \">\":\"$$$$2o$2b2o$4b2o$6b2o$6b2o$4b2o$2b2o$2o\",\n        \"=\":\"$$$$$$8o$$$8o\",\n        \"?\":\"$b4o$o4bo$o4bo$5bo$4bo$3bo$2bo$2bo$$2bo$2bo\",\n        \"@\":\"$3b4o$2bo4bo$bo6bo$o3b2o3bo$o2bo2bo2bo$o2bo2bo2bo$o3b2o3bo$o5b3o$bo$2bo5bo$3b5o\",\n        \"[\":\"$3o$o$o$o$o$o$o$o$o$o$o$o$o$3o\",\n        \"]\":\"$3o$2bo$2bo$2bo$2bo$2bo$2bo$2bo$2bo$2bo$2bo$2bo$2bo$3o\",\n        \"\\\\\":\"$o$o$bo$bo$bo$2bo$2bo$2bo$3bo$3bo$3bo\",\n        \"^\":\"$2b2o$2b2o$bo2bo$bo2bo$o4bo$o4bo\",\n        \"_\":\"$$$$$$$$$$$$$8o\",\n        \"`\":\"o$bo$2bo\",\n        \"{\":\"$2b2o$bo$bo$bo$bo$bo$bo$o$bo$bo$bo$bo$bo$2b2o\",\n        \"}\":\"$2o$2bo$2bo$2bo$2bo$2bo$2bo$3bo$2bo$2bo$2bo$2bo$2bo$2o\",\n        \"|\":\"o$o$o$o$o$o$o$o$o$o$o$o$o$o$o\",\n        \"~\":\"$$$$$$b3o3bo$o3b3o\"\n    },\n    \"ATT4425\": {            // designed for 9x13 grids\n        \"width\": 9,\n        \"height\": 13,\n        \"A\":\"$3bo$3bo$2bobo$2bobo$bo3bo$bo3bo$7o$o5bo$o5bo\",\n        \"B\":\"$6o$bo4bo$bo4bo$bo3bo$b4o$bo3bo$bo4bo$bo4bo$6o\",\n        \"C\":\"$2b5o$bo$o$o$o$o$o$bo$2b5o\",\n        \"D\":\"$5o$bo3bo$bo4bo$bo4bo$bo4bo$bo4bo$bo4bo$bo3bo$5o\",\n        \"E\":\"$6o$o$o$o$5o$o$o$o$6o\",\n        \"F\":\"$6o$o$o$o$5o$o$o$o$o\",\n        \"G\":\"$2b3o$bo3bo$o$o$o$o3b3o$o4bo$bo3bo$2b3o\",\n        \"H\":\"$o5bo$o5bo$o5bo$o5bo$7o$o5bo$o5bo$o5bo$o5bo\",\n        \"I\":\"$3o$bo$bo$bo$bo$bo$bo$bo$3o\",\n        \"J\":\"$4bo$4bo$4bo$4bo$4bo$4bo$o3bo$o3bo$b3o\",\n        \"K\":\"$o5bo$o4bo$o3bo$o2bo$3o$o2bo$o3bo$o4bo$o5bo\",\n        \"L\":\"$o$o$o$o$o$o$o$o$7o\",\n        \"M\":\"$o5bo$2o3b2o$obobobo$o2bo2bo$o5bo$o5bo$o5bo$o5bo$o5bo\",\n        \"N\":\"$o5bo$2o4bo$obo3bo$obo3bo$o2bo2bo$o3bobo$o3bobo$o4b2o$o5bo\",\n        \"O\":\"$2b3o$bo3bo$o5bo$o5bo$o5bo$o5bo$o5bo$bo3bo$2b3o\",\n        \"P\":\"$6o$o5bo$o5bo$o5bo$6o$o$o$o$o\",\n        \"Q\":\"$2b3o$bo3bo$o5bo$o5bo$o5bo$o5bo$o5bo$bo3bo$2b3o$3bo2bo$4b3o\",\n        \"R\":\"$6o$o5bo$o5bo$o5bo$6o$o2bo$o3bo$o4bo$o5bo\",\n        \"S\":\"$2b3o$bo3bo$bo$2bo$3bo$4bo$o4bo$bo3bo$2b3o\",\n        \"T\":\"$5o$2bo$2bo$2bo$2bo$2bo$2bo$2bo$2bo\",\n        \"U\":\"$o5bo$o5bo$o5bo$o5bo$o5bo$o5bo$o5bo$bo3bo$2b3o\",\n        \"V\":\"$o5bo$o5bo$bo3bo$bo3bo$bo3bo$2bobo$2bobo$3bo$3bo\",\n        \"W\":\"$o5bo$o5bo$o2bo2bo$o2bo2bo$obobobo$obobobo$2o3b2o$2o3b2o$o5bo\",\n        \"X\":\"$o5bo$bo3bo$bo3bo$2bobo$3bo$2bobo$bo3bo$bo3bo$o5bo\",\n        \"Y\":\"$o5bo$o5bo$bo3bo$2bobo$3bo$3bo$3bo$3bo$3bo\",\n        \"Z\":\"$7o$6bo$5bo$4bo$3bo$2bo$bo$o$7o\"\n    }\n};\n\nChip.VERSION = +VERSION || 1.20;\n\nMACHINE = \"LEDs\";\n\n/**\n * @copyright https://www.pcjs.org/modules/devices/machine.js (C) Jeff Parsons 2012-2018\n */\n\n/**\n * @class {Machine}\n * @unrestricted\n * @property {Chip} chip\n * @property {string} sConfigFile\n * @property {boolean} fConfigLoaded\n * @property {boolean} fPageLoaded\n */\nclass Machine extends Device {\n    /**\n     * Machine(idMachine, sConfig)\n     * \n     * If sConfig contains a JSON object definition, then we parse it immediately and save the result in this.config;\n     * otherwise, we assume it's the URL of an JSON object definition, so we request the resource, and once it's loaded,\n     * we parse it.\n     * \n     * Sample config:\n     *\n     *    {\n     *      \"ti57\": {\n     *        \"class\": \"Machine\",\n     *        \"type\": \"TI57\",\n     *        \"name\": \"TI-57 Programmable Calculator Simulation\",\n     *        \"version\": 1.10,\n     *        \"autoStart\": true,\n     *        \"autoRestore\": true,\n     *        \"bindings\": {\n     *          \"clear\": \"clearTI57\",\n     *          \"print\": \"printTI57\"\n     *        }\n     *      },\n     *      \"chip\": {\n     *        \"class\": \"Chip\",\n     *        \"type\": \"TMS-1500\",\n     *        \"input\": \"buttons\",\n     *        \"output\": \"display\"\n     *      },\n     *      \"clock\": {\n     *        \"class\": \"Time\",\n     *        \"cyclesPerSecond\": 650000\n     *        \"bindings\": {\n     *          \"run\": \"runTI57\",\n     *          \"speed\": \"speedTI57\",\n     *          \"step\": \"stepTI57\"\n     *        },\n     *        \"overrides\": [\"cyclesPerSecond\"]\n     *      },\n     *      \"display\": {\n     *        \"class\": \"LED\",\n     *        \"type\": 3,\n     *        \"cols\": 12,\n     *        \"rows\": 1,\n     *        \"color\": \"red\",\n     *        \"bindings\": {\n     *          \"container\": \"displayTI57\"\n     *        },\n     *        \"overrides\": [\"color\",\"backgroundColor\"]\n     *      },\n     *      \"buttons\": {\n     *        \"class\": \"Input\",\n     *        \"map\": [\n     *          [\"2nd\",  \"inv\",  \"lnx\",  \"\\\\b\",  \"clr\"],\n     *          [\"lrn\",  \"xchg\", \"sq\",   \"sqrt\", \"rcp\"],\n     *          [\"sst\",  \"sto\",  \"rcl\",  \"sum\",  \"exp\"],\n     *          [\"bst\",  \"ee\",   \"(\",    \")\",    \"/\"],\n     *          [\"gto\",  \"7\",    \"8\",    \"9\",    \"*\"],\n     *          [\"sbr\",  \"4\",    \"5\",    \"6\",    \"-\"],\n     *          [\"rst\",  \"1\",    \"2\",    \"3\",    \"+\"],\n     *          [\"r/s\",  \"0\",    \".\",    \"+/-\",  \"=|\\\\r\"]\n     *        ],\n     *        \"location\": [139, 325, 368, 478, 0.34, 0.5, 640, 853, 418, 180, 75, 36],\n     *        \"bindings\": {\n     *          \"surface\": \"imageTI57\",\n     *          \"power\": \"powerTI57\",\n     *          \"reset\": \"resetTI57\"\n     *        }\n     *      },\n     *      \"rom\": {\n     *        \"class\": \"ROM\",\n     *        \"wordSize\": 13,\n     *        \"valueSize\": 16,\n     *        \"valueTotal\": 2048,\n     *        \"littleEndian\": true,\n     *        \"file\": \"ti57le.bin\",\n     *        \"reference\": \"\",\n     *        \"values\": [\n     *        ]\n     *      }\n     *    }\n     *\n     * @this {Machine}\n     * @param {string} idMachine (of both the machine AND the <div> to contain it)\n     * @param {string} sConfig (JSON configuration for entire machine, including any static resources)\n     */\n    constructor(idMachine, sConfig)\n    {\n        super(idMachine, idMachine, Machine.VERSION);\n\n        let machine = this;\n        this.chip = null;\n        this.sConfigFile = \"\";\n        this.fConfigLoaded = this.fPageLoaded = false;\n        \n        sConfig = sConfig.trim();\n        \n        if (sConfig[0] == '{') {\n            this.loadConfig(sConfig);\n        } else {\n            this.sConfigFile = sConfig;\n            this.getResource(this.sConfigFile, function onLoadConfig(sURL, sResource, readyState, nErrorCode) {\n                if (readyState == 4) {\n                    if (!nErrorCode && sResource) {\n                        machine.loadConfig(sResource);\n                        machine.initDevices();\n                    }\n                    else {\n                        machine.printf(\"Error (%d) loading configuration: %s\\n\", nErrorCode, sURL);\n                    }\n                }\n            });\n        }\n        \n        /*\n         * Device initialization is now deferred until after the page is fully loaded, for the benefit\n         * of devices (eg, Input) that may be dependent on page resources.\n         *\n         * Strangely, for these page events, I must use the window object rather than the document object.\n         */\n        window.addEventListener('load', function onLoadPage(event) {\n            machine.fPageLoaded = true;\n            machine.initDevices();\n        });\n        let sEvent = this.isUserAgent(\"iOS\")? 'pagehide' : (this.isUserAgent(\"Opera\")? 'unload' : undefined);\n        window.addEventListener(sEvent || 'beforeunload', function onUnloadPage(event) {\n            machine.killDevices();\n        });\n    }\n\n    /**\n     * initDevices()\n     *\n     * Initializes devices in the proper order.  For example, any Time devices should be initialized first,\n     * to ensure that their timer services are available to other devices.\n     *\n     * @this {Machine}\n     */\n    initDevices()\n    {\n        if (this.fConfigLoaded && this.fPageLoaded) {\n            for (let iClass = 0; iClass < Machine.CLASSORDER.length; iClass++) {\n                for (let idDevice in this.config) {\n                    let device, sClass;\n                    try {\n                        let config = this.config[idDevice], sStatus = \"\";\n                        sClass = config['class'];\n                        if (sClass != Machine.CLASSORDER[iClass]) continue;\n                        switch (sClass) {\n                        case Machine.CLASS.CHIP:\n                            device = new Chip(this.idMachine, idDevice, config);\n                            this.chip = device;\n                            break;\n                        case Machine.CLASS.INPUT:\n                            device = new Input(this.idMachine, idDevice, config);\n                            break;\n                        case Machine.CLASS.LED:\n                            device = new LED(this.idMachine, idDevice, config);\n                            break;\n                        case Machine.CLASS.ROM:\n                            device = new ROM(this.idMachine, idDevice, config);\n                            if (device.config['revision']) sStatus = \"revision \" + device.config['revision'];\n                            break;\n                        case Machine.CLASS.TIME:\n                            device = new Time(this.idMachine, idDevice, config);\n                            break;\n                        case Machine.CLASS.MACHINE:\n                            this.printf(\"PCjs %s v%3.2f\\n\", config['name'], Machine.VERSION);\n                            this.println(Machine.COPYRIGHT);\n                            this.println(Machine.LICENSE);\n                            if (this.sConfigFile) this.println(\"Configuration: \" + this.sConfigFile);\n                            continue;\n                        default:\n                            this.println(\"unrecognized device class: \" + sClass);\n                            continue;\n                        }\n                        this.println(sClass + \" device initialized\" + (sStatus? \" (\" + sStatus + \")\" : \"\"));\n                    }\n                    catch (err) {\n                        this.println(\"error initializing \" + sClass + \" device '\" + idDevice + \"':\\n\" + err.message);\n                        this.removeDevice(idDevice);\n                    }\n                }\n            }\n            let chip = this.chip;\n            if (chip) {\n                if (chip.onLoad && this.fAutoRestore) chip.onLoad();\n                if (chip.onPower && this.fAutoStart) chip.onPower(true);\n            }\n        }\n    }\n\n    /**\n     * killDevices()\n     * \n     * @this {Machine}\n     */\n    killDevices()\n    {\n        let chip;\n        if (chip = this.chip) {\n            if (chip.onSave) chip.onSave();\n            if (chip.onPower) chip.onPower(false);\n        }\n        \n    }\n\n    /**\n     * loadConfig(sConfig)\n     *\n     * @this {Machine}\n     * @param {string} sConfig\n     */\n    loadConfig(sConfig)\n    {\n        try {\n            this.config = JSON.parse(sConfig);\n            let config = this.config[this.idMachine];\n            this.checkVersion(config);\n            this.checkOverrides(config);\n            this.addBindings(config['bindings']);\n            this.fAutoStart = (config['autoStart'] !== false);\n            this.fAutoRestore = (config['autoRestore'] !== false);\n            this.fConfigLoaded = true;\n        } catch(err) {\n            let sError = err.message;\n            let match = sError.match(/position ([0-9]+)/);\n            if (match) {\n                sError += \" ('\" + sConfig.substr(+match[1], 40).replace(/\\s+/g, ' ') + \"...')\";\n            }\n            this.println(\"machine '\" + this.idMachine + \"' initialization error: \" + sError);\n        }\n    }\n}\n\nMachine.CLASS = {\n    CHIP:       \"Chip\",\n    INPUT:      \"Input\",\n    LED:        \"LED\",\n    MACHINE:    \"Machine\",\n    ROM:        \"ROM\",\n    TIME:       \"Time\"\n};\n\nMachine.CLASSORDER = [\n    Machine.CLASS.MACHINE,\n    Machine.CLASS.TIME,\n    Machine.CLASS.LED,\n    Machine.CLASS.INPUT,\n    Machine.CLASS.ROM,\n    Machine.CLASS.CHIP\n];\n\nMachine.COPYRIGHT = \"Copyright © 2012-2018 Jeff Parsons <Jeff@pcjs.org>\";\nMachine.LICENSE = \"License: GPL version 3 or later <http://gnu.org/licenses/gpl.html>\";\n\nMachine.VERSION = +VERSION || 1.20;\n\nwindow[MACHINE] = Machine;\n"]}